{"task_id": "DSP/0", "completion": "def get_string(x,y):\n    return str(x)+str(y)\n    raise NotImplementedError()"}
{"task_id": "DSP/0", "completion": "def get_string(x,y):\n    return str(x)+str(y)\n    raise NotImplementedError()"}
{"task_id": "DSP/1", "completion": "def ypolynomial(x,p):\n    if x > 0:\n        return 4 + 5*x**p\n    else: \n        return 0\n    raise NotImplementedError()"}
{"task_id": "DSP/1", "completion": "def ypolynomial(x,p):\n    if x > 0:\n        return 4 + 5*x**p\n    else: \n        return 0\n    raise NotImplementedError()"}
{"task_id": "DSP/2", "completion": "def isObesse(weight, height):\n    if weight/height**2 >= 30:\n        return 'obese'\n    else:\n        return 'not obese'\n    raise NotImplementedError()"}
{"task_id": "DSP/2", "completion": "def isObesse(weight, height):\n    if weight/height**2 >= 30:\n        return 'obese'\n    else:\n        return 'not obese'\n    raise NotImplementedError()"}
{"task_id": "DSP/3", "completion": "def divisibles(N, p):\n    result = []\n    if N < 0:\n        N=20\n    else:\n        pass\n    \n    i = 0\n    while i <= N:\n        if i%p == 0:\n            result.append(i)\n        else:\n            pass\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/3", "completion": "def divisibles(N, p):\n    result = []\n    if N < 0:\n        N=20\n    else:\n        pass\n    \n    i = 0\n    while i <= N:\n        if i%p == 0:\n            result.append(i)\n        else:\n            pass\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/4", "completion": "def removeDuplicates(mylist):\n    return list(np.unique(np.array(mylist)))\n    raise NotImplementedError()"}
{"task_id": "DSP/4", "completion": "def removeDuplicates(mylist):\n    return list(np.unique(np.array(mylist)))\n    raise NotImplementedError()"}
{"task_id": "DSP/5", "completion": "def sumOfFirstAndLast(listx):\n    if len(listx) == 0:\n        return 0\n    else:\n        return listx[0] + listx[-1]\n    raise NotImplementedError()"}
{"task_id": "DSP/5", "completion": "def sumOfFirstAndLast(listx):\n    if len(listx) == 0:\n        return 0\n    else:\n        return listx[0] + listx[-1]\n    raise NotImplementedError()"}
{"task_id": "DSP/6", "completion": "def sumDigits(number):\n    listn = [int(i) for i in str(number)]\n    x = 0\n    for n in listn:\n        x+=n\n    return x\n    raise NotImplementedError()"}
{"task_id": "DSP/6", "completion": "def sumDigits(number):\n    listn = [int(i) for i in str(number)]\n    x = 0\n    for n in listn:\n        x+=n\n    return x\n    raise NotImplementedError()"}
{"task_id": "DSP/7", "completion": "def countEvenDigits(number):\n    listn = [int(i) for i in str(number)]\n    count = 0\n    for i in listn:\n        if i%2 == 0:\n            count+=1\n        else:\n            pass\n    return count\n    raise NotImplementedError()"}
{"task_id": "DSP/7", "completion": "def countEvenDigits(number):\n    listn = [int(i) for i in str(number)]\n    count = 0\n    for i in listn:\n        if i%2 == 0:\n            count+=1\n        else:\n            pass\n    return count\n    raise NotImplementedError()"}
{"task_id": "DSP/8", "completion": "def countOddEvenDigits(number):\n    listn = [int(i) for i in str(number)]\n    count_odd = 0\n    count_even = 0\n    for i in listn:\n        if i%2 == 0:\n            count_even+=1\n        else:\n            count_odd+=1\n    return {'odd':count_odd, 'even':count_even}\n    raise NotImplementedError()"}
{"task_id": "DSP/8", "completion": "def countOddEvenDigits(number):\n    listn = [int(i) for i in str(number)]\n    count_odd = 0\n    count_even = 0\n    for i in listn:\n        if i%2 == 0:\n            count_even+=1\n        else:\n            count_odd+=1\n    return {'odd':count_odd, 'even':count_even}\n    raise NotImplementedError()"}
{"task_id": "DSP/9", "completion": "def verify_ISBN13(ISBN):\n    isbn = str(ISBN)\n    ev = sum([int(i) for i in isbn[::2]])\n    od = 3*sum([int(i) for i in isbn[1::2]])\n    if 0 == (od + ev) % 10:\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n    raise NotImplementedError()"}
{"task_id": "DSP/9", "completion": "def verify_ISBN13(ISBN):\n    isbn = str(ISBN)\n    ev = sum([int(i) for i in isbn[::2]])\n    od = 3*sum([int(i) for i in isbn[1::2]])\n    if 0 == (od + ev) % 10:\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n    raise NotImplementedError()"}
{"task_id": "DSP/10", "completion": "floating_bubbles=1.6180339# YOUR CODE HERE"}
{"task_id": "DSP/10", "completion": "floating_bubbles=1.6180339# YOUR CODE HERE"}
{"task_id": "DSP/11", "completion": "the_string='Spamelot'# YOUR CODE HERE"}
{"task_id": "DSP/11", "completion": "the_string='Spamelot'# YOUR CODE HERE"}
{"task_id": "DSP/12", "completion": "square_root=math.sqrt(490490)# YOUR CODE HERE"}
{"task_id": "DSP/12", "completion": "square_root=math.sqrt(490490)# YOUR CODE HERE"}
{"task_id": "DSP/13", "completion": "sphere_radius=4.9# YOUR CODE HERE"}
{"task_id": "DSP/13", "completion": "sphere_radius=4.9# YOUR CODE HERE"}
{"task_id": "DSP/14", "completion": "sphere_volume = 4 / 3 * math.pi * sphere_radius ** 3 # YOUR CODE HERE"}
{"task_id": "DSP/14", "completion": "sphere_volume = 4 / 3 * math.pi * sphere_radius ** 3 # YOUR CODE HERE"}
{"task_id": "DSP/15", "completion": "the_volume_string = str(int(sphere_volume)) # YOUR CODE HERE"}
{"task_id": "DSP/15", "completion": "the_volume_string = str(int(sphere_volume)) # YOUR CODE HERE"}
{"task_id": "DSP/16", "completion": "def return_Weather(w):\n    '''\n    Takes a Weather object and returns the data contained within as a tuple\n    \n    Parameters\n    ----------\n    w: a weather object\n    \n    Returns\n    -------\n    a tuple\n    '''\n    # YOUR CODE HERE\n    # return a tuple of data contained in a Weather object\n    return (w.inch, w.ft, w.temp)"}
{"task_id": "DSP/16", "completion": "def return_Weather(w):\n    '''\n    Takes a Weather object and returns the data contained within as a tuple\n    \n    Parameters\n    ----------\n    w: a weather object\n    \n    Returns\n    -------\n    a tuple\n    '''\n    # YOUR CODE HERE\n    # return a tuple of data contained in a Weather object\n    return (w.inch, w.ft, w.temp)"}
{"task_id": "DSP/17", "completion": "def fix_inch(w):\n    '''\n    Takes a weather object and changes the \"inch\" attribute so that it does\n    not contain 12 or more inches in it, modifying the \"ft\" attribute in the \n    process.  It then returns the weather object.\n    \n    Parameters\n    ----------\n    a Weather object\n    \n    Returns\n    -------\n    a Weather object\n    '''\n    # YOUR CODE HERE\n    # If w.inch contains 12 or more inches\n    if w.inch >= 12:\n        # add proper amount to w.ft\n        w.ft = w.ft + w.inch // 12\n        # modify w.inch\n        w.inch = w.inch % 12\n    return w"}
{"task_id": "DSP/17", "completion": "def fix_inch(w):\n    '''\n    Takes a weather object and changes the \"inch\" attribute so that it does\n    not contain 12 or more inches in it, modifying the \"ft\" attribute in the \n    process.  It then returns the weather object.\n    \n    Parameters\n    ----------\n    a Weather object\n    \n    Returns\n    -------\n    a Weather object\n    '''\n    # YOUR CODE HERE\n    # If w.inch contains 12 or more inches\n    if w.inch >= 12:\n        # add proper amount to w.ft\n        w.ft = w.ft + w.inch // 12\n        # modify w.inch\n        w.inch = w.inch % 12\n    return w"}
{"task_id": "DSP/18", "completion": "def add_dat(w, inch, feet, temp):\n    '''\n    Adds inches and feet to a weather object, and changes the temperature of the \n    weather object to a new temperature.\n    \n    Parameters\n    ----------\n    w: a weather object\n    inch: an integer\n    feet: an integer\n    temp: an integer\n    \n    Returns\n    -------\n    A Weather object\n    '''\n    # YOUR CODE HERE\n    # Adds inches and feet to the weather object\n    w.inch = w.inch + inch\n    w.ft = w.ft + feet\n    # changes the temperature of the weather object to a new temperature.\n    w.temp = temp\n    # fix the inch\n    fix_inch(w)\n    return w"}
{"task_id": "DSP/18", "completion": "def add_dat(w, inch, feet, temp):\n    '''\n    Adds inches and feet to a weather object, and changes the temperature of the \n    weather object to a new temperature.\n    \n    Parameters\n    ----------\n    w: a weather object\n    inch: an integer\n    feet: an integer\n    temp: an integer\n    \n    Returns\n    -------\n    A Weather object\n    '''\n    # YOUR CODE HERE\n    # Adds inches and feet to the weather object\n    w.inch = w.inch + inch\n    w.ft = w.ft + feet\n    # changes the temperature of the weather object to a new temperature.\n    w.temp = temp\n    # fix the inch\n    fix_inch(w)\n    return w"}
{"task_id": "DSP/19", "completion": "class Circle:\n    \n    \"\"\"\n    A class for representing a circle\n    \n    Parameters\n    ----------\n    radius: the circle's radius\n    \n    \"\"\"\n    def __init__(self, radius):\n        \n        # assign the radius to itself\n        self.radius = radius\n        # create an attribute for diameter\n        self.diameter = 2 * radius\n        # create an attribute for area\n        self.area = 3.141592653589793 * radius * radius"}
{"task_id": "DSP/19", "completion": "class Circle:\n    \n    \"\"\"\n    A class for representing a circle\n    \n    Parameters\n    ----------\n    radius: the circle's radius\n    \n    \"\"\"\n    def __init__(self, radius):\n        \n        # assign the radius to itself\n        self.radius = radius\n        # create an attribute for diameter\n        self.diameter = 2 * radius\n        # create an attribute for area\n        self.area = 3.141592653589793 * radius * radius"}
{"task_id": "DSP/20", "completion": "class Circle2(Circle):\n    \n    \"\"\"\n    A new class for representing a circle\n    \n    Parameters\n    ----------\n    radius: the circle's radius\n    \n    \"\"\"\n    def plot(self, xlim, ylim):\n        \n        fig, ax = plt.subplots()\n        # plot the circle\n        c = plt.Circle((0,0), self.radius)\n        # add it to the plot\n        ax.add_patch(c)\n        # set x limit\n        ax.set_xlim(xlim)\n        # set y limit\n        ax.set_ylim(ylim)\n        return ax"}
{"task_id": "DSP/20", "completion": "class Circle2(Circle):\n    \n    \"\"\"\n    A new class for representing a circle\n    \n    Parameters\n    ----------\n    radius: the circle's radius\n    \n    \"\"\"\n    def plot(self, xlim, ylim):\n        \n        fig, ax = plt.subplots()\n        # plot the circle\n        c = plt.Circle((0,0), self.radius)\n        # add it to the plot\n        ax.add_patch(c)\n        # set x limit\n        ax.set_xlim(xlim)\n        # set y limit\n        ax.set_ylim(ylim)\n        return ax"}
{"task_id": "DSP/21", "completion": "def count_code_cells(filename, cell_type):\n    '''\n    Takes a filename and a cell type, and returns the number count of that cell type.\n    \n    Parameters\n    ----------\n    filename (str): a JSON file.\n    cell_type (str): \"code\", \"markdown\", etc.\n    \n    Returns\n    -------\n    An int.\n    '''\n    # YOUR CODE HERE\n    count = 0\n    # Open the file\n    with open(filename, 'r') as jsonfile:\n        # Read the data\n        data = json.load(jsonfile)\n        # Get cell\n        for cell in data['cells']:\n            # Count the specific cell_type\n            if cell[\"cell_type\"] == cell_type:\n                count +=1\n\n    return count"}
{"task_id": "DSP/21", "completion": "def count_code_cells(filename, cell_type):\n    '''\n    Takes a filename and a cell type, and returns the number count of that cell type.\n    \n    Parameters\n    ----------\n    filename (str): a JSON file.\n    cell_type (str): \"code\", \"markdown\", etc.\n    \n    Returns\n    -------\n    An int.\n    '''\n    # YOUR CODE HERE\n    count = 0\n    # Open the file\n    with open(filename, 'r') as jsonfile:\n        # Read the data\n        data = json.load(jsonfile)\n        # Get cell\n        for cell in data['cells']:\n            # Count the specific cell_type\n            if cell[\"cell_type\"] == cell_type:\n                count +=1\n\n    return count"}
{"task_id": "DSP/22", "completion": "def get_column(filename, n, header=True):\n    '''\n    Returns a list from reading the specified column in the CSV file.\n\n    Parameters\n    __________\n    filename (str): Input file name. The file is assumed to be in a \n                    Comma Separated Values (CSV) format with latin-1 encoding.\n    n (int): Column number. The first column starts at 0. The column must be\n             a list of integers.\n    header (bool): If True, the first line of file is column names.\n                   Default: True.\n    '''\n    result = []\n\n    # YOUR CODE HERE\n    import csv\n    with open(filename, 'r', encoding = 'latin-1') as csvfile:\n        for row in csv.reader(csvfile):\n            apd = row[n]\n            if header:                                  #if header = True, skip the first row.\n                header = False\n                continue\n            if apd != 'NA':\n                    result.append(int(apd))\n    return result"}
{"task_id": "DSP/22", "completion": "def get_column(filename, n, header=True):\n    '''\n    Returns a list from reading the specified column in the CSV file.\n\n    Parameters\n    __________\n    filename (str): Input file name. The file is assumed to be in a \n                    Comma Separated Values (CSV) format with latin-1 encoding.\n    n (int): Column number. The first column starts at 0. The column must be\n             a list of integers.\n    header (bool): If True, the first line of file is column names.\n                   Default: True.\n    '''\n    result = []\n\n    # YOUR CODE HERE\n    import csv\n    with open(filename, 'r', encoding = 'latin-1') as csvfile:\n        for row in csv.reader(csvfile):\n            apd = row[n]\n            if header:                                  #if header = True, skip the first row.\n                header = False\n                continue\n            if apd != 'NA':\n                    result.append(int(apd))\n    return result"}
{"task_id": "DSP/23", "completion": "def get_city(xml):\n    \"\"\"\n    Takes an XML and returns the city name.\n    \n    Parameters\n    ----------\n    xml (str): An XML script.\n    \n    Returns\n    -------\n    A string.\n    \"\"\"\n    # YOUR CODE HERE\n    # Create a Beautifulsoup object\n    soup = BeautifulSoup(xml, 'xml')\n    soup.prettify()\n    # Return the city name\n    result = soup.City.string\n    return result"}
{"task_id": "DSP/23", "completion": "def get_city(xml):\n    \"\"\"\n    Takes an XML and returns the city name.\n    \n    Parameters\n    ----------\n    xml (str): An XML script.\n    \n    Returns\n    -------\n    A string.\n    \"\"\"\n    # YOUR CODE HERE\n    # Create a Beautifulsoup object\n    soup = BeautifulSoup(xml, 'xml')\n    soup.prettify()\n    # Return the city name\n    result = soup.City.string\n    return result"}
{"task_id": "DSP/24", "completion": "def get_temp(xml):\n    \"\"\"\n    Takes an XML and returns the temperature.\n    \n    Parameters\n    ----------\n    xml (str): An XML script.\n    \n    Returns\n    -------\n    A float.\n    \"\"\"\n    # YOUR CODE HERE\n    # Create a Beautifulsoup object\n    soup = BeautifulSoup(xml, 'xml')\n    soup.prettify()\n    # Return the temperature\n    result = float(soup.Temp.string[0:4])\n    return result"}
{"task_id": "DSP/24", "completion": "def get_temp(xml):\n    \"\"\"\n    Takes an XML and returns the temperature.\n    \n    Parameters\n    ----------\n    xml (str): An XML script.\n    \n    Returns\n    -------\n    A float.\n    \"\"\"\n    # YOUR CODE HERE\n    # Create a Beautifulsoup object\n    soup = BeautifulSoup(xml, 'xml')\n    soup.prettify()\n    # Return the temperature\n    result = float(soup.Temp.string[0:4])\n    return result"}
{"task_id": "DSP/25", "completion": "def dict_from_lists(keys, values):\n    '''\n    Constructs a dictionary using the first input list as keys and second as values.\n    \n    Parameters\n    __________\n    keys: A list.\n    values: A list.\n    \n    Returns\n    _______\n    output: A dictionary.\n    '''\n    # YOUR CODE HERE\n    return dict(zip(keys, values))"}
{"task_id": "DSP/25", "completion": "def dict_from_lists(keys, values):\n    '''\n    Constructs a dictionary using the first input list as keys and second as values.\n    \n    Parameters\n    __________\n    keys: A list.\n    values: A list.\n    \n    Returns\n    _______\n    output: A dictionary.\n    '''\n    # YOUR CODE HERE\n    return dict(zip(keys, values))"}
{"task_id": "DSP/26", "completion": "def add_one(d, to_add):\n    '''\n    Adds the second dictionary to the first dictionary.\n    \n    Parameters\n    __________\n    d: A dictionary.\n    to_add: A dictionary that will be added to d.\n    \n    Returns\n    _______\n    output: The updated dictionary d. \n    '''\n    # YOUR CODE HERE\n    for key in to_add:\n        d[key] = to_add[key]\n    return d"}
{"task_id": "DSP/26", "completion": "def add_one(d, to_add):\n    '''\n    Adds the second dictionary to the first dictionary.\n    \n    Parameters\n    __________\n    d: A dictionary.\n    to_add: A dictionary that will be added to d.\n    \n    Returns\n    _______\n    output: The updated dictionary d. \n    '''\n    # YOUR CODE HERE\n    for key in to_add:\n        d[key] = to_add[key]\n    return d"}
{"task_id": "DSP/27", "completion": "def add_many(d, *dicts_to_add):\n    '''\n    Adds many dictionaries to the first dictionary.\n    \n    Parameters\n    __________\n    d: A dictionary.\n    *dicts_to_add: Arbitrary number of dictionaries (1 or more dictionaries) that will be added to d.\n    \n    Returns\n    _______\n    output: The updated dictionary d. \n    '''\n    # YOUR CODE HERE\n    for add in dicts_to_add:\n        d = add_one(d, add)\n    return d"}
{"task_id": "DSP/27", "completion": "def add_many(d, *dicts_to_add):\n    '''\n    Adds many dictionaries to the first dictionary.\n    \n    Parameters\n    __________\n    d: A dictionary.\n    *dicts_to_add: Arbitrary number of dictionaries (1 or more dictionaries) that will be added to d.\n    \n    Returns\n    _______\n    output: The updated dictionary d. \n    '''\n    # YOUR CODE HERE\n    for add in dicts_to_add:\n        d = add_one(d, add)\n    return d"}
{"task_id": "DSP/28", "completion": "def remove(d, to_remove):\n    '''\n    Removes the second dictionary from the first dictionary. \n    \n    Parameters\n    __________\n    d: A dicionary.\n    to_remove: A dictionary that will be removed from d. \n    \n    Returns\n    _______\n    output: The updated dictionary d. \n    '''\n    # YOUR CODE HERE\n    for key, value in to_remove.items():\n        if key in d and d[key] == value:\n            del d[key]\n    return d"}
{"task_id": "DSP/28", "completion": "def remove(d, to_remove):\n    '''\n    Removes the second dictionary from the first dictionary. \n    \n    Parameters\n    __________\n    d: A dicionary.\n    to_remove: A dictionary that will be removed from d. \n    \n    Returns\n    _______\n    output: The updated dictionary d. \n    '''\n    # YOUR CODE HERE\n    for key, value in to_remove.items():\n        if key in d and d[key] == value:\n            del d[key]\n    return d"}
{"task_id": "DSP/29", "completion": "eeveelution = dict_from_lists(names, types)\neeveelution = add_many(eeveelution, generationII, generationIV, generationVI)\neeveelution = remove(eeveelution, {\"Pikachu\": \"Electric\"})"}
{"task_id": "DSP/29", "completion": "eeveelution = dict_from_lists(names, types)\neeveelution = add_many(eeveelution, generationII, generationIV, generationVI)\neeveelution = remove(eeveelution, {\"Pikachu\": \"Electric\"})"}
{"task_id": "DSP/30", "completion": "def slice_string(a_string, ind1, ind2):\n    # YOUR CODE HERE\n    return a_string[ind1:ind2]"}
{"task_id": "DSP/30", "completion": "def slice_string(a_string, ind1, ind2):\n    # YOUR CODE HERE\n    return a_string[ind1:ind2]"}
{"task_id": "DSP/31", "completion": "def is_in(a_string, letter):\n    # YOUR CODE HERE\n    return letter in a_string"}
{"task_id": "DSP/31", "completion": "def is_in(a_string, letter):\n    # YOUR CODE HERE\n    return letter in a_string"}
{"task_id": "DSP/32", "completion": "def list_output(a_string, letter, ind1, ind2):\n    # YOUR CODE HERE\n    if letter in a_string:\n        answer = 'Yes'\n    else:\n        answer = 'No'\n    return 'The string is '+ a_string + '. Is the letter '+ letter + ' inside the string? ' + answer +'. The slice of the string is ' + a_string[ind1:ind2] + '.'"}
{"task_id": "DSP/32", "completion": "def list_output(a_string, letter, ind1, ind2):\n    # YOUR CODE HERE\n    if letter in a_string:\n        answer = 'Yes'\n    else:\n        answer = 'No'\n    return 'The string is '+ a_string + '. Is the letter '+ letter + ' inside the string? ' + answer +'. The slice of the string is ' + a_string[ind1:ind2] + '.'"}
{"task_id": "DSP/33", "completion": "def in_radians(degrees):\n    # YOUR CODE HERE\n    return math.pi * (degrees / 180)"}
{"task_id": "DSP/33", "completion": "def in_radians(degrees):\n    # YOUR CODE HERE\n    return math.pi * (degrees / 180)"}
{"task_id": "DSP/34", "completion": "def sine_of(degrees):\n    # YOUR CODE HERE\n    return math.sin(in_radians(degrees))"}
{"task_id": "DSP/34", "completion": "def sine_of(degrees):\n    # YOUR CODE HERE\n    return math.sin(in_radians(degrees))"}
{"task_id": "DSP/35", "completion": "def find_opp(degrees, hypo):\n    # YOUR CODE HERE\n    return hypo * sine_of(degrees)"}
{"task_id": "DSP/35", "completion": "def find_opp(degrees, hypo):\n    # YOUR CODE HERE\n    return hypo * sine_of(degrees)"}
{"task_id": "DSP/36", "completion": "def remove_hashtags(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where we discard all strings that are hashtags.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has a hashtag.\n    '''\n    # YOUR CODE HERE\n    # Substitues every word in words that contains a # with an empty string '' using list comprehension\n    words = [re.sub('\\#.*', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/36", "completion": "def remove_hashtags(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where we discard all strings that are hashtags.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has a hashtag.\n    '''\n    # YOUR CODE HERE\n    # Substitues every word in words that contains a # with an empty string '' using list comprehension\n    words = [re.sub('\\#.*', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/37", "completion": "def remove_users(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where we discard all strings that represent users.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has user tags.\n    '''\n    # YOUR CODE HERE\n    # Substitues every word in words that contains a @ with an empty string ''\n    words = [re.sub('@.*', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/37", "completion": "def remove_users(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where we discard all strings that represent users.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has user tags.\n    '''\n    # YOUR CODE HERE\n    # Substitues every word in words that contains a @ with an empty string ''\n    words = [re.sub('@.*', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/38", "completion": "def remove_links(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where we discard all strings that are http links.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list is an http link.\n    '''\n    # YOUR CODE HERE\n    # Substitues every word in words that contains 'http:' or 'https:' with an empty string ''\n    words = [re.sub('https?:.*', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/38", "completion": "def remove_links(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where we discard all strings that are http links.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list is an http link.\n    '''\n    # YOUR CODE HERE\n    # Substitues every word in words that contains 'http:' or 'https:' with an empty string ''\n    words = [re.sub('https?:.*', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/39", "completion": "def keep_letters(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where all strings have only alphabetical characters.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has any non-alphabetical characters.\n    '''\n    # YOUR CODE HERE\n    # Substitues every non-alphabetical characters in words with an empty string ''\n    words = [re.sub('[^A-Za-z]', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/39", "completion": "def keep_letters(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where all strings have only alphabetical characters.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has any non-alphabetical characters.\n    '''\n    # YOUR CODE HERE\n    # Substitues every non-alphabetical characters in words with an empty string ''\n    words = [re.sub('[^A-Za-z]', '', word) for word in words]\n    # Use filter to remove all empty strings\n    words = list(filter(None, words))\n    return words"}
{"task_id": "DSP/40", "completion": "def to_lower(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where all strings are lowercase.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has any capital letters.\n    '''\n    # YOUR CODE HERE\n    # Convert all strings to lowercase with string method .lower()\n    words = [word.lower() for word in words]\n    return words"}
{"task_id": "DSP/40", "completion": "def to_lower(words):\n    '''\n    Take a list of strings.\n    Returns a list of strings, where all strings are lowercase.\n    \n    Parameters\n    ----------\n    words: A list of strings.\n    \n    Returns\n    -------\n    A list of strings. None of the strings in the return list has any capital letters.\n    '''\n    # YOUR CODE HERE\n    # Convert all strings to lowercase with string method .lower()\n    words = [word.lower() for word in words]\n    return words"}
{"task_id": "DSP/41", "completion": "def gen_cosine(n):\n    standard_deviation = 0.2\n    x = np.linspace(0, 2*math.pi, n)\n    t = np.random.normal(np.cos(x), standard_deviation)\n    return x, t"}
{"task_id": "DSP/41", "completion": "def gen_cosine(n):\n    standard_deviation = 0.2\n    x = np.linspace(0, 2*math.pi, n)\n    t = np.random.normal(np.cos(x), standard_deviation)\n    return x, t"}
{"task_id": "DSP/42", "completion": "def designmatrix(x, M): # it is highly recommended to write a helper function that computes Phi\n    Phi = numpy.array([\n        np.array([x[i]**j for j in range(M+1)])\n        for i in range(x.shape[0])\n    ])\n    return Phi\n\ndef fit_polynomial(x, t, M):\n    Phi = designmatrix(x, M)\n    Phi_inv = np.linalg.pinv(Phi)\n    w_ml = np.dot(Phi_inv, t)\n    return w_ml, Phi"}
{"task_id": "DSP/42", "completion": "def designmatrix(x, M): # it is highly recommended to write a helper function that computes Phi\n    Phi = numpy.array([\n        np.array([x[i]**j for j in range(M+1)])\n        for i in range(x.shape[0])\n    ])\n    return Phi\n\ndef fit_polynomial(x, t, M):\n    Phi = designmatrix(x, M)\n    Phi_inv = np.linalg.pinv(Phi)\n    w_ml = np.dot(Phi_inv, t)\n    return w_ml, Phi"}
{"task_id": "DSP/43", "completion": "def fit_polynomial_reg(x, t, m, lamb):\n    Phi = designmatrix(x, m)\n    Phi_sq = np.dot(Phi.T, Phi)\n    inv_term = np.linalg.inv(lamb * np.identity(len(Phi_sq)) + Phi_sq)\n    w_ml = np.dot(np.dot(inv_term, Phi.T), t)\n    return w_ml, Phi"}
{"task_id": "DSP/43", "completion": "def fit_polynomial_reg(x, t, m, lamb):\n    Phi = designmatrix(x, m)\n    Phi_sq = np.dot(Phi.T, Phi)\n    inv_term = np.linalg.inv(lamb * np.identity(len(Phi_sq)) + Phi_sq)\n    w_ml = np.dot(np.dot(inv_term, Phi.T), t)\n    return w_ml, Phi"}
{"task_id": "DSP/44", "completion": "def pred_error(x_train, x_valid, t_train, t_valid, M, lamb):\n    w_ml, Phi_train = fit_polynomial_reg(x_train, t_train, M, lamb)\n    \n    Phi_valid = designmatrix(x_valid, M)\n    y_valid = np.dot(Phi_valid, w_ml)\n\n    diff = y_valid - t_valid\n    pred_err = np.dot(np.transpose(diff), diff)\n    return pred_err"}
{"task_id": "DSP/44", "completion": "def pred_error(x_train, x_valid, t_train, t_valid, M, lamb):\n    w_ml, Phi_train = fit_polynomial_reg(x_train, t_train, M, lamb)\n    \n    Phi_valid = designmatrix(x_valid, M)\n    y_valid = np.dot(Phi_valid, w_ml)\n\n    diff = y_valid - t_valid\n    pred_err = np.dot(np.transpose(diff), diff)\n    return pred_err"}
{"task_id": "DSP/45", "completion": "def gen_cosine2(N):\n    standard_deviation = 0.2\n    x = np.random.uniform(0, 2*math.pi, N)\n    x = np.sort(x)\n    t = np.random.normal(np.cos(x), standard_deviation)\n    return x, t"}
{"task_id": "DSP/45", "completion": "def gen_cosine2(N):\n    standard_deviation = 0.2\n    x = np.random.uniform(0, 2*math.pi, N)\n    x = np.sort(x)\n    t = np.random.normal(np.cos(x), standard_deviation)\n    return x, t"}
{"task_id": "DSP/46", "completion": "def fit_polynomial_bayes(x, t, M, alpha, beta):\n    Phi = designmatrix(x, M)\n    Phi_sq = np.dot(Phi.T, Phi)\n    S = np.linalg.inv(alpha * np.identity(len(Phi_sq)) + beta * Phi_sq)\n    m = np.dot(np.dot(beta * S, Phi.T), t)\n    \n    return m, S, Phi"}
{"task_id": "DSP/46", "completion": "def fit_polynomial_bayes(x, t, M, alpha, beta):\n    Phi = designmatrix(x, M)\n    Phi_sq = np.dot(Phi.T, Phi)\n    S = np.linalg.inv(alpha * np.identity(len(Phi_sq)) + beta * Phi_sq)\n    m = np.dot(np.dot(beta * S, Phi.T), t)\n    \n    return m, S, Phi"}
{"task_id": "DSP/47", "completion": "def predict_polynomial_bayes(x, m, S, beta):\n    Phi = designmatrix(x, len(m)-1)\n    \n    variance = np.array([1 / beta + np.dot(np.dot(phi.T, S), phi) for phi in Phi]) \n    mean = np.dot(Phi, m.T)\n\n    return mean, variance, Phi"}
{"task_id": "DSP/47", "completion": "def predict_polynomial_bayes(x, m, S, beta):\n    Phi = designmatrix(x, len(m)-1)\n    \n    variance = np.array([1 / beta + np.dot(np.dot(phi.T, S), phi) for phi in Phi]) \n    mean = np.dot(Phi, m.T)\n\n    return mean, variance, Phi"}
{"task_id": "DSP/48", "completion": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\n\nimport sklearn.datasets\nimport sklearn.feature_selection\n\nfrom sklearn.datasets import fetch_olivetti_faces\nfrom sklearn.feature_selection import SelectPercentile\nfrom sklearn.feature_selection import chi2\n\nfaces = fetch_olivetti_faces()\n\nplt.matshow(faces.data[0].reshape((64,64)))\nplt.colorbar()\nplt.show()\n\nX = faces.data\ny = faces.target\n\np75 = SelectPercentile(score_func=chi2, percentile=25)\nX_new = p75.fit_transform(faces.data, faces.target)\nreshaped = np.reshape(p75.scores_, (64, 64))\n\nplt.matshow(reshaped)\nplt.colorbar()\nplt.show()\n\nsns.heatmap(reshaped, cbar=True)\nplt.show()"}
{"task_id": "DSP/48", "completion": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\n\nimport sklearn.datasets\nimport sklearn.feature_selection\n\nfrom sklearn.datasets import fetch_olivetti_faces\nfrom sklearn.feature_selection import SelectPercentile\nfrom sklearn.feature_selection import chi2\n\nfaces = fetch_olivetti_faces()\n\nplt.matshow(faces.data[0].reshape((64,64)))\nplt.colorbar()\nplt.show()\n\nX = faces.data\ny = faces.target\n\np75 = SelectPercentile(score_func=chi2, percentile=25)\nX_new = p75.fit_transform(faces.data, faces.target)\nreshaped = np.reshape(p75.scores_, (64, 64))\n\nplt.matshow(reshaped)\nplt.colorbar()\nplt.show()\n\nsns.heatmap(reshaped, cbar=True)\nplt.show()"}
{"task_id": "DSP/49", "completion": "from sklearn import datasets\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n\ndigits = datasets.load_digits()\n\nX = digits.data\ny = digits.target\n    \nX_new = TSNE(n_components=2, perplexity=150, random_state=0).fit_transform(X)\nkmeans = KMeans(n_clusters=10, random_state=0).fit(X_new)\ny_new = kmeans.labels_\nscore = adjusted_rand_score(y, y_new)"}
{"task_id": "DSP/49", "completion": "from sklearn import datasets\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n\ndigits = datasets.load_digits()\n\nX = digits.data\ny = digits.target\n    \nX_new = TSNE(n_components=2, perplexity=150, random_state=0).fit_transform(X)\nkmeans = KMeans(n_clusters=10, random_state=0).fit(X_new)\ny_new = kmeans.labels_\nscore = adjusted_rand_score(y, y_new)"}
{"task_id": "DSP/50", "completion": "import pandas as pd\nimport numpy as np\n\n# Load the ames dataset into a pandas dataframe\n# Make sure to save as \"ames_data\"\n\names_data = pd.read_table(\"ames_train.csv\", sep=\",\")\n\n# You can make sure you loaded it correctly by looking at its first few rows, using the .head() function\nprint(ames_data.head())"}
{"task_id": "DSP/50", "completion": "import pandas as pd\nimport numpy as np\n\n# Load the ames dataset into a pandas dataframe\n# Make sure to save as \"ames_data\"\n\names_data = pd.read_table(\"ames_train.csv\", sep=\",\")\n\n# You can make sure you loaded it correctly by looking at its first few rows, using the .head() function\nprint(ames_data.head())"}
{"task_id": "DSP/51", "completion": "ames_data[\"sqft_sum\"] = ames_data[\"1stFlrSF\"] + ames_data[\"2ndFlrSF\"]\n\names_data = ames_data[((ames_data.sqft_sum > 4000) & (ames_data.SalePrice < 300000)) != True]"}
{"task_id": "DSP/51", "completion": "ames_data[\"sqft_sum\"] = ames_data[\"1stFlrSF\"] + ames_data[\"2ndFlrSF\"]\n\names_data = ames_data[((ames_data.sqft_sum > 4000) & (ames_data.SalePrice < 300000)) != True]"}
{"task_id": "DSP/52", "completion": "from sklearn.model_selection import train_test_split\n\nX = ames_data[[\"sqft_sum\", \"Fireplaces\"]]\n\ny = ames_data[\"SalePrice\"]\n\n# Now we will split your data into training and test, for evaluation\n# Note the function below\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state=12323)"}
{"task_id": "DSP/52", "completion": "from sklearn.model_selection import train_test_split\n\nX = ames_data[[\"sqft_sum\", \"Fireplaces\"]]\n\ny = ames_data[\"SalePrice\"]\n\n# Now we will split your data into training and test, for evaluation\n# Note the function below\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state=12323)"}
{"task_id": "DSP/53", "completion": "from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\n\nlr = LinearRegression()\nlr.fit(X_train, y_train)\n\ny_preds = lr.predict(X_test)\n\nrmse = np.sqrt(mean_squared_error(y_preds, y_test))"}
{"task_id": "DSP/53", "completion": "from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\n\nlr = LinearRegression()\nlr.fit(X_train, y_train)\n\ny_preds = lr.predict(X_test)\n\nrmse = np.sqrt(mean_squared_error(y_preds, y_test))"}
{"task_id": "DSP/54", "completion": "def bootstrap(boot_pop, statistic, resample, replicates = 1000):\n    \"\"\"\n    Args:\n        boot_pop: an array of shape n x d.\n        statistic: a function which takes boot_pop and returns a number.\n        resample: a function which takes n and returns a random sample from the integers [0, n)\n        \n    Return\n        an array of length replicates, each entry being the statistic computed on a bootstrap sample of the data.\n    \"\"\"\n    \n    return np.array([statistic(np.array([boot_pop[i] for i in resample(boot_pop.shape[0])])) for j in np.arange(replicates)])"}
{"task_id": "DSP/54", "completion": "def bootstrap(boot_pop, statistic, resample, replicates = 1000):\n    \"\"\"\n    Args:\n        boot_pop: an array of shape n x d.\n        statistic: a function which takes boot_pop and returns a number.\n        resample: a function which takes n and returns a random sample from the integers [0, n)\n        \n    Return\n        an array of length replicates, each entry being the statistic computed on a bootstrap sample of the data.\n    \"\"\"\n    \n    return np.array([statistic(np.array([boot_pop[i] for i in resample(boot_pop.shape[0])])) for j in np.arange(replicates)])"}
{"task_id": "DSP/55", "completion": "replicates = 1000\nboot_theta = bootstrap(d, estimator, simple_resample, replicates)"}
{"task_id": "DSP/55", "completion": "replicates = 1000\nboot_theta = bootstrap(d, estimator, simple_resample, replicates)"}
{"task_id": "DSP/56", "completion": "def model(theta, total_bill):\n    \"\"\"\n    Takes the parameter theta and the total bill returns the computed tip.\n    \"\"\"\n    ...\n    return theta * total_bill"}
{"task_id": "DSP/56", "completion": "def model(theta, total_bill):\n    \"\"\"\n    Takes the parameter theta and the total bill returns the computed tip.\n    \"\"\"\n    ...\n    return theta * total_bill"}
{"task_id": "DSP/57", "completion": "def squared_loss(y_obs, y_hat):\n    \"\"\"\n    y_obs: an array of observed valued\n    y_hat: an array of predicted values\n    return an array corresponding to the loss for each prediction\n    \"\"\"\n    ...\n    return (y_obs - y_hat)**2"}
{"task_id": "DSP/57", "completion": "def squared_loss(y_obs, y_hat):\n    \"\"\"\n    y_obs: an array of observed valued\n    y_hat: an array of predicted values\n    return an array corresponding to the loss for each prediction\n    \"\"\"\n    ...\n    return (y_obs - y_hat)**2"}
{"task_id": "DSP/58", "completion": "loss = np.array([squared_loss(y, model(theta,x)).mean() for theta in thetas])"}
{"task_id": "DSP/58", "completion": "loss = np.array([squared_loss(y, model(theta,x)).mean() for theta in thetas])"}
{"task_id": "DSP/59", "completion": "def abs_loss(y_obs, y_hat):\n    \"\"\"\n    y_obs: an array of observed valued\n    y_hat: an array of predicted values\n    return an array corresponding to the loss for each prediction\n    \"\"\"\n    ...\n    return abs(y_obs - y_hat)"}
{"task_id": "DSP/59", "completion": "def abs_loss(y_obs, y_hat):\n    \"\"\"\n    y_obs: an array of observed valued\n    y_hat: an array of predicted values\n    return an array corresponding to the loss for each prediction\n    \"\"\"\n    ...\n    return abs(y_obs - y_hat)"}
{"task_id": "DSP/60", "completion": "def linear_model(x, theta):\n    \"\"\"\n    Returns the estimate of y given x and theta\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta -- the scalar theta\n    \"\"\"\n    y_hat = x * theta\n    return y_hat"}
{"task_id": "DSP/60", "completion": "def linear_model(x, theta):\n    \"\"\"\n    Returns the estimate of y given x and theta\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta -- the scalar theta\n    \"\"\"\n    y_hat = x * theta\n    return y_hat"}
{"task_id": "DSP/61", "completion": "def l2_loss(y, y_hat):\n    \"\"\"\n    Returns the average l2 loss given y and y_hat\n\n    Keyword arguments:\n    y -- the vector of true values y\n    y_hat -- the vector of predicted values y_hat\n    \"\"\"\n    return np.mean((y - y_hat) ** 2)"}
{"task_id": "DSP/61", "completion": "def l2_loss(y, y_hat):\n    \"\"\"\n    Returns the average l2 loss given y and y_hat\n\n    Keyword arguments:\n    y -- the vector of true values y\n    y_hat -- the vector of predicted values y_hat\n    \"\"\"\n    return np.mean((y - y_hat) ** 2)"}
{"task_id": "DSP/62", "completion": "def visualize(x, y, thetas):\n    \"\"\"\n    Plots the average l2 loss for given x, y as a function of theta.\n    Use the functions you wrote for linear_model and l2_loss.\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    thetas -- the vector containing different estimates of theta\n    \"\"\"\n    avg_loss = [l2_loss(y, linear_model(theta, x)) for theta in thetas] # Calculate the loss here for each value of theta\n    \n    fig = plt.figure(figsize=(8,6))\n    ax = plt.axes()\n    plt.plot(thetas, avg_loss)\n    ax.set(xlabel = r\"$\\theta$\", ylabel = r\"Average Loss\")\n    \nthetas = np.linspace(-1, 5, 70)\nvisualize(x, y, thetas)\ntheta_star_guess = 1.5"}
{"task_id": "DSP/62", "completion": "def visualize(x, y, thetas):\n    \"\"\"\n    Plots the average l2 loss for given x, y as a function of theta.\n    Use the functions you wrote for linear_model and l2_loss.\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    thetas -- the vector containing different estimates of theta\n    \"\"\"\n    avg_loss = [l2_loss(y, linear_model(theta, x)) for theta in thetas] # Calculate the loss here for each value of theta\n    \n    fig = plt.figure(figsize=(8,6))\n    ax = plt.axes()\n    plt.plot(thetas, avg_loss)\n    ax.set(xlabel = r\"$\\theta$\", ylabel = r\"Average Loss\")\n    \nthetas = np.linspace(-1, 5, 70)\nvisualize(x, y, thetas)\ntheta_star_guess = 1.5"}
{"task_id": "DSP/63", "completion": "def find_theta(x, y):\n    \"\"\"\n    Find optimal theta given x and y\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    \"\"\"\n    theta_opt = (x * y).sum() / (x ** 2).sum()\n    return theta_opt"}
{"task_id": "DSP/63", "completion": "def find_theta(x, y):\n    \"\"\"\n    Find optimal theta given x and y\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    \"\"\"\n    theta_opt = (x * y).sum() / (x ** 2).sum()\n    return theta_opt"}
{"task_id": "DSP/64", "completion": "def sin_model(x, theta_1, theta_2):\n    \"\"\"\n    Predict the estimate of y given x, theta_1, theta_2\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta_1 -- the scalar value theta_1\n    theta_2 -- the scalar value theta_2\n    \"\"\"\n    y_hat = theta_1 * x + np.sin(theta_2 * x)\n    return y_hat"}
{"task_id": "DSP/64", "completion": "def sin_model(x, theta_1, theta_2):\n    \"\"\"\n    Predict the estimate of y given x, theta_1, theta_2\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta_1 -- the scalar value theta_1\n    theta_2 -- the scalar value theta_2\n    \"\"\"\n    y_hat = theta_1 * x + np.sin(theta_2 * x)\n    return y_hat"}
{"task_id": "DSP/65", "completion": "def grad_desc(x, y, theta, num_iter=20, alpha=0.1):\n    \"\"\"\n    Run gradient descent update for a finite number of iterations and static learning rate\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    theta -- the vector of values theta to use at first iteration\n    num_iter -- the max number of iterations\n    alpha -- the learning rate (also called the step size)\n    \n    Return:\n    theta -- the optimal value of theta after num_iter of gradient descent\n    theta_history -- the series of theta values over each iteration of gradient descent\n    loss_history -- the series of loss values over each iteration of gradient descent\n    \"\"\"\n    theta_history = []\n    loss_history = []\n    \n    for i in np.arange(num_iter):\n        theta_history.append(theta)\n        loss_history.append(l2_loss(y,sin_model(x, theta[0], theta[1])))     \n        theta = theta - alpha * dt(x, y, theta)\n    return theta, theta_history, loss_history"}
{"task_id": "DSP/65", "completion": "def grad_desc(x, y, theta, num_iter=20, alpha=0.1):\n    \"\"\"\n    Run gradient descent update for a finite number of iterations and static learning rate\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    theta -- the vector of values theta to use at first iteration\n    num_iter -- the max number of iterations\n    alpha -- the learning rate (also called the step size)\n    \n    Return:\n    theta -- the optimal value of theta after num_iter of gradient descent\n    theta_history -- the series of theta values over each iteration of gradient descent\n    loss_history -- the series of loss values over each iteration of gradient descent\n    \"\"\"\n    theta_history = []\n    loss_history = []\n    \n    for i in np.arange(num_iter):\n        theta_history.append(theta)\n        loss_history.append(l2_loss(y,sin_model(x, theta[0], theta[1])))     \n        theta = theta - alpha * dt(x, y, theta)\n    return theta, theta_history, loss_history"}
{"task_id": "DSP/66", "completion": "def grad_desc_decay(x, y, theta, num_iter=20, alpha=0.1):\n    \"\"\"\n    Run gradient descent update for a finite number of iterations and decaying learning rate\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    theta -- the vector of values theta\n    num_iter -- the max number of iterations\n    alpha -- the learning rate\n    \n    Return:\n    theta -- the optimal value of theta after num_iter of gradient descent\n    theta_history -- the series of theta values over each iteration of gradient descent\n    loss_history -- the series of loss values over each iteration of gradient descent\n    \"\"\"\n    theta_history = []\n    loss_history = []\n    \n    for i in np.arange(num_iter):\n        theta_history.append(theta)\n        loss_history.append(l2_loss(y,sin_model(x, theta[0], theta[1])))\n        theta = theta - alpha * dt(x, y, theta)\n        alpha = alpha / (i + 1)\n    return theta, theta_history, loss_history"}
{"task_id": "DSP/66", "completion": "def grad_desc_decay(x, y, theta, num_iter=20, alpha=0.1):\n    \"\"\"\n    Run gradient descent update for a finite number of iterations and decaying learning rate\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    theta -- the vector of values theta\n    num_iter -- the max number of iterations\n    alpha -- the learning rate\n    \n    Return:\n    theta -- the optimal value of theta after num_iter of gradient descent\n    theta_history -- the series of theta values over each iteration of gradient descent\n    loss_history -- the series of loss values over each iteration of gradient descent\n    \"\"\"\n    theta_history = []\n    loss_history = []\n    \n    for i in np.arange(num_iter):\n        theta_history.append(theta)\n        loss_history.append(l2_loss(y,sin_model(x, theta[0], theta[1])))\n        theta = theta - alpha * dt(x, y, theta)\n        alpha = alpha / (i + 1)\n    return theta, theta_history, loss_history"}
{"task_id": "DSP/67", "completion": "colours = []\n\n##BEGIN SOLUTION\ncolours = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"indigo\", \"violet\"]\n#END SOLUTION"}
{"task_id": "DSP/67", "completion": "colours = []\n\n##BEGIN SOLUTION\ncolours = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"indigo\", \"violet\"]\n#END SOLUTION"}
{"task_id": "DSP/68", "completion": "def get_string(x,y):\n    return str(x) + str(y)\n    raise NotImplementedError()"}
{"task_id": "DSP/68", "completion": "def get_string(x,y):\n    return str(x) + str(y)\n    raise NotImplementedError()"}
{"task_id": "DSP/69", "completion": "def ypolynomial(x,p):\n    if x > 0:\n        x = x**p\n        y = 4 + 5*x\n    else: \n        y = 0\n    return y\n    raise NotImplementedError()"}
{"task_id": "DSP/69", "completion": "def ypolynomial(x,p):\n    if x > 0:\n        x = x**p\n        y = 4 + 5*x\n    else: \n        y = 0\n    return y\n    raise NotImplementedError()"}
{"task_id": "DSP/70", "completion": "def divisibles(N, p):\n    result = []\n    if N < 0:\n        N=20\n    else:\n        pass\n    \n    i = 0\n    while i <= N:\n        if i%p == 0:\n            result.append(i)\n        else:\n            pass\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/70", "completion": "def divisibles(N, p):\n    result = []\n    if N < 0:\n        N=20\n    else:\n        pass\n    \n    i = 0\n    while i <= N:\n        if i%p == 0:\n            result.append(i)\n        else:\n            pass\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/71", "completion": "def divisibles2(s, N, p):\n    result = []\n    if N < 0:\n        N=20\n    else:\n        pass\n    \n    i = s\n    while i <= N:\n        if i%p == 0:\n            result.append(i)\n        else:\n            pass\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/71", "completion": "def divisibles2(s, N, p):\n    result = []\n    if N < 0:\n        N=20\n    else:\n        pass\n    \n    i = s\n    while i <= N:\n        if i%p == 0:\n            result.append(i)\n        else:\n            pass\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/72", "completion": "def divisibo(N):\n    result = []\n    divs = [5, 7, 11]\n    start = divs[2]\n    \n    while(len(result) < N):\n        if start%11 == 0:\n            if start%7 == 0:\n                if start%5 == 0:\n                    result.append(start)\n        start+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/72", "completion": "def divisibo(N):\n    result = []\n    divs = [5, 7, 11]\n    start = divs[2]\n    \n    while(len(result) < N):\n        if start%11 == 0:\n            if start%7 == 0:\n                if start%5 == 0:\n                    result.append(start)\n        start+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/73", "completion": "def primes_first(N):\n    result = [2]\n    i = 2\n    while(len(result) < N):\n        if(i%2 != 0):\n            result.append(i)\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/73", "completion": "def primes_first(N):\n    result = [2]\n    i = 2\n    while(len(result) < N):\n        if(i%2 != 0):\n            result.append(i)\n        i+=1\n    return result\n    raise NotImplementedError()"}
{"task_id": "DSP/74", "completion": "def flatten_list(superlist):\n    # Flatten array\n    sort = []\n    i = 0\n    while i < len(superlist):\n        z = 0\n        while(z < len(superlist[i])):\n            sort.append(superlist[i][z])\n            z+=1\n        i+=1\n    # Bubble sort\n    for p in range(len(sort)-1,0,-1):\n        for x in range(p):\n            if sort[x]>sort[x+1]:\n                tmp = sort[x]\n                sort[x] = sort[x+1]\n                sort[x+1] = tmp\n    return sort\n    raise NotImplementedError()"}
{"task_id": "DSP/74", "completion": "def flatten_list(superlist):\n    # Flatten array\n    sort = []\n    i = 0\n    while i < len(superlist):\n        z = 0\n        while(z < len(superlist[i])):\n            sort.append(superlist[i][z])\n            z+=1\n        i+=1\n    # Bubble sort\n    for p in range(len(sort)-1,0,-1):\n        for x in range(p):\n            if sort[x]>sort[x+1]:\n                tmp = sort[x]\n                sort[x] = sort[x+1]\n                sort[x+1] = tmp\n    return sort\n    raise NotImplementedError()"}
{"task_id": "DSP/75", "completion": "def longest_word(text):\n    words = text.split()\n    largest = 0\n    for word in words:\n        current_len = len(word)\n        if (current_len > largest):\n            final_word = word\n            largest = current_len\n        else:\n            largest = largest\n    return final_word\n    raise NotImplementedError()"}
{"task_id": "DSP/75", "completion": "def longest_word(text):\n    words = text.split()\n    largest = 0\n    for word in words:\n        current_len = len(word)\n        if (current_len > largest):\n            final_word = word\n            largest = current_len\n        else:\n            largest = largest\n    return final_word\n    raise NotImplementedError()"}
{"task_id": "DSP/76", "completion": "def dictionarize(alist):\n    diction = {}\n    for x in alist:\n        i = alist.count(x)\n        if i > 0:\n            diction[x] = i\n    return diction\n    raise NotImplementedError()"}
{"task_id": "DSP/76", "completion": "def dictionarize(alist):\n    diction = {}\n    for x in alist:\n        i = alist.count(x)\n        if i > 0:\n            diction[x] = i\n    return diction\n    raise NotImplementedError()"}
{"task_id": "DSP/77", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/77", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/78", "completion": "dictionary = dict(zip(var_a,var_b))"}
{"task_id": "DSP/78", "completion": "dictionary = dict(zip(var_a,var_b))"}
{"task_id": "DSP/79", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, item in enumerate(lst,0):\n    if index%2==0:\n        inds.append(item)"}
{"task_id": "DSP/79", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, item in enumerate(lst,0):\n    if index%2==0:\n        inds.append(item)"}
{"task_id": "DSP/80", "completion": "def add2(input1,input2):\n    return input1+input2"}
{"task_id": "DSP/80", "completion": "def add2(input1,input2):\n    return input1+input2"}
{"task_id": "DSP/81", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\nfor k,v in dictionary.items():\n    if v%2==1:\n        other_dictionary[k] = add2(v,1)\n    else:\n        other_dictionary[k] = v"}
{"task_id": "DSP/81", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\nfor k,v in dictionary.items():\n    if v%2==1:\n        other_dictionary[k] = add2(v,1)\n    else:\n        other_dictionary[k] = v"}
{"task_id": "DSP/82", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib as plt\nimport sklearn as skl"}
{"task_id": "DSP/82", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib as plt\nimport sklearn as skl"}
{"task_id": "DSP/83", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/83", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/84", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/84", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/85", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/85", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/86", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/86", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/87", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/87", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/88", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/88", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/89", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/89", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/90", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/90", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/91", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/91", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/92", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/92", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/93", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/93", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/94", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/94", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/95", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/95", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/96", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/96", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/97", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/97", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/98", "completion": "dictionary = dict(zip(var_a,var_b))"}
{"task_id": "DSP/98", "completion": "dictionary = dict(zip(var_a,var_b))"}
{"task_id": "DSP/99", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, item in enumerate(lst,0):\n    if index%2==0:\n        inds.append(item)"}
{"task_id": "DSP/99", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, item in enumerate(lst,0):\n    if index%2==0:\n        inds.append(item)"}
{"task_id": "DSP/100", "completion": "def add2(input1,input2):\n    return input1+input2"}
{"task_id": "DSP/100", "completion": "def add2(input1,input2):\n    return input1+input2"}
{"task_id": "DSP/101", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\nfor k,v in dictionary.items():\n    if v%2==1:\n        other_dictionary[k] = add2(v,1)\n    else:\n        other_dictionary[k] = v"}
{"task_id": "DSP/101", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\nfor k,v in dictionary.items():\n    if v%2==1:\n        other_dictionary[k] = add2(v,1)\n    else:\n        other_dictionary[k] = v"}
{"task_id": "DSP/102", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib as plt\nimport sklearn as skl"}
{"task_id": "DSP/102", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib as plt\nimport sklearn as skl"}
{"task_id": "DSP/103", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/103", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/104", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/104", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/105", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/105", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/106", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/106", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/107", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/107", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/108", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/108", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/109", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/109", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/110", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/110", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/111", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/111", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/112", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/112", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/113", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/113", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/114", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/114", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/115", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/115", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/116", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/116", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/117", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/117", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/118", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/118", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/119", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/119", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/120", "completion": "dictionary = dict(zip(var_a,var_b))"}
{"task_id": "DSP/120", "completion": "dictionary = dict(zip(var_a,var_b))"}
{"task_id": "DSP/121", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, item in enumerate(lst,0):\n    if index%2==0:\n        inds.append(item)"}
{"task_id": "DSP/121", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, item in enumerate(lst,0):\n    if index%2==0:\n        inds.append(item)"}
{"task_id": "DSP/122", "completion": "def add2(input1,input2):\n    return input1+input2"}
{"task_id": "DSP/122", "completion": "def add2(input1,input2):\n    return input1+input2"}
{"task_id": "DSP/123", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\nfor k,v in dictionary.items():\n    if v%2==1:\n        other_dictionary[k] = add2(v,1)\n    else:\n        other_dictionary[k] = v"}
{"task_id": "DSP/123", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\nfor k,v in dictionary.items():\n    if v%2==1:\n        other_dictionary[k] = add2(v,1)\n    else:\n        other_dictionary[k] = v"}
{"task_id": "DSP/124", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib as plt\nimport sklearn as skl"}
{"task_id": "DSP/124", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib as plt\nimport sklearn as skl"}
{"task_id": "DSP/125", "completion": "def separate_by_class(X, y):\n    '''\n    Separate the training set (\"X\") by class value (\"y\")\n    so that we can calculate statistics for each class.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array\n    y: A 1d numpy array\n    Returns\n    -------\n    A dictionary of 2d numpy arrays\n    '''\n    ##################\n    # YOUR CODE HERE\n    separated = {}\n    labels = np.unique(y)  # find all unique labels\n    for item in labels:\n        separated[item] = X[np.where(y == item)]  # use np.where to find index of all corresponding items in X\n    ##################\n\n    return separated"}
{"task_id": "DSP/125", "completion": "def separate_by_class(X, y):\n    '''\n    Separate the training set (\"X\") by class value (\"y\")\n    so that we can calculate statistics for each class.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array\n    y: A 1d numpy array\n    Returns\n    -------\n    A dictionary of 2d numpy arrays\n    '''\n    ##################\n    # YOUR CODE HERE\n    separated = {}\n    labels = np.unique(y)  # find all unique labels\n    for item in labels:\n        separated[item] = X[np.where(y == item)]  # use np.where to find index of all corresponding items in X\n    ##################\n\n    return separated"}
{"task_id": "DSP/126", "completion": "def calculate_mean(array):\n    '''\n    Calculates the mean of each column, i.e. each attribute.\n    \n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    ##################\n    # YOUR CODE HERE\n    mean = np.mean(array, axis=0)\n    ##################\n    return mean"}
{"task_id": "DSP/126", "completion": "def calculate_mean(array):\n    '''\n    Calculates the mean of each column, i.e. each attribute.\n    \n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    ##################\n    # YOUR CODE HERE\n    mean = np.mean(array, axis=0)\n    ##################\n    return mean"}
{"task_id": "DSP/127", "completion": "def calculate_stdev(array):\n    '''\n    Calculates the standard deviation of each column, i.e. each attribute.\n\n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    ##################\n    # YOUR CODE HERE\n    stdev = np.std(array, axis=0, ddof=1)   # need to set the delta degree of freedom to be 1\n    ##################\n\n    return stdev"}
{"task_id": "DSP/127", "completion": "def calculate_stdev(array):\n    '''\n    Calculates the standard deviation of each column, i.e. each attribute.\n\n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    ##################\n    # YOUR CODE HERE\n    stdev = np.std(array, axis=0, ddof=1)   # need to set the delta degree of freedom to be 1\n    ##################\n\n    return stdev"}
{"task_id": "DSP/128", "completion": "def summarize(X):\n    '''\n    For a given list of instances (for a class value),\n    calculates the mean and the standard deviation for each attribute.\n    \n    Parameters\n    ----------\n    A 2d numpy array\n    \n    Returns\n    -------\n    A 2d numpy array\n    '''\n    ##################\n    # YOUR CODE HERE\n    mean = calculate_mean(X)\n    std = calculate_stdev(X)\n    summary = np.vstack((mean, std)).T    # stack it, and then transpose\n    ##################\n    return summary"}
{"task_id": "DSP/128", "completion": "def summarize(X):\n    '''\n    For a given list of instances (for a class value),\n    calculates the mean and the standard deviation for each attribute.\n    \n    Parameters\n    ----------\n    A 2d numpy array\n    \n    Returns\n    -------\n    A 2d numpy array\n    '''\n    ##################\n    # YOUR CODE HERE\n    mean = calculate_mean(X)\n    std = calculate_stdev(X)\n    summary = np.vstack((mean, std)).T    # stack it, and then transpose\n    ##################\n    return summary"}
{"task_id": "DSP/129", "completion": "def summarize_by_class(X, y):\n    '''\n    Separates a training set into instances grouped by class.\n    It then calculates the summaries for each attribute.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array. Represents training attributes.\n    y: A 1d numpy array. Represents class labels.\n    Returns\n    -------\n    A dictionary of 2d numpy arrays\n    '''\n    ##################\n    # YOUR CODE HERE\n    summaries = {}\n    X_separated = separate_by_class(X, y)\n    for key in X_separated:\n        summaries[key] = summarize(X_separated[key])\n    ##################\n\n    return summaries"}
{"task_id": "DSP/129", "completion": "def summarize_by_class(X, y):\n    '''\n    Separates a training set into instances grouped by class.\n    It then calculates the summaries for each attribute.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array. Represents training attributes.\n    y: A 1d numpy array. Represents class labels.\n    Returns\n    -------\n    A dictionary of 2d numpy arrays\n    '''\n    ##################\n    # YOUR CODE HERE\n    summaries = {}\n    X_separated = separate_by_class(X, y)\n    for key in X_separated:\n        summaries[key] = summarize(X_separated[key])\n    ##################\n\n    return summaries"}
{"task_id": "DSP/130", "completion": "def calculate_log_probability(x, mean, stdev):\n    '''\n    Calculates log of Gaussian function to estimate\n    the log probability of a given attribute value.\n    \n    Parameters\n    ----------\n    x: A float or 1d numpy array\n    mean: A float or 1d numpy array\n    stdev: A float or 1d numpy array\n    \n    Returns\n    -------\n    A float or 1d numpy array\n    '''\n\n    ##################\n    # YOUR CODE HERE\n    from scipy.stats import norm\n    \n    temp = np.vstack([x, mean, stdev]).T  # stack vertically and transpose, so that each row contains a set of x, mean, stdev\n    log_probability = list(map(lambda x: norm.logpdf(*x), temp))  # map logpdf function to the list\n    \n    ##################\n\n    return log_probability"}
{"task_id": "DSP/130", "completion": "def calculate_log_probability(x, mean, stdev):\n    '''\n    Calculates log of Gaussian function to estimate\n    the log probability of a given attribute value.\n    \n    Parameters\n    ----------\n    x: A float or 1d numpy array\n    mean: A float or 1d numpy array\n    stdev: A float or 1d numpy array\n    \n    Returns\n    -------\n    A float or 1d numpy array\n    '''\n\n    ##################\n    # YOUR CODE HERE\n    from scipy.stats import norm\n    \n    temp = np.vstack([x, mean, stdev]).T  # stack vertically and transpose, so that each row contains a set of x, mean, stdev\n    log_probability = list(map(lambda x: norm.logpdf(*x), temp))  # map logpdf function to the list\n    \n    ##################\n\n    return log_probability"}
{"task_id": "DSP/131", "completion": "def calculate_class_log_probabilities(summaries, input_array):\n    '''\n    Combines the probabilities of all of the attribute values for a data instance\n    and comes up with a probability of the entire data instance belonging to the class.\n\n    Parameters\n    ----------\n    summaries: A dictionary of 2d numpy arrays\n    input_array: A 1d numpy array\n    \n    Returns\n    -------\n    A dictionary of log probabilities\n    '''\n\n    ##################\n    # YOUR CODE HERE \n    log_probabilities = {}\n    for key in summaries:\n        for summary_item in summaries[key]:\n            log_probabilities[key] = calculate_log_probability(input_array, summary_item[0], summary_item[1])\n    ##################\n\n    return log_probabilities"}
{"task_id": "DSP/131", "completion": "def calculate_class_log_probabilities(summaries, input_array):\n    '''\n    Combines the probabilities of all of the attribute values for a data instance\n    and comes up with a probability of the entire data instance belonging to the class.\n\n    Parameters\n    ----------\n    summaries: A dictionary of 2d numpy arrays\n    input_array: A 1d numpy array\n    \n    Returns\n    -------\n    A dictionary of log probabilities\n    '''\n\n    ##################\n    # YOUR CODE HERE \n    log_probabilities = {}\n    for key in summaries:\n        for summary_item in summaries[key]:\n            log_probabilities[key] = calculate_log_probability(input_array, summary_item[0], summary_item[1])\n    ##################\n\n    return log_probabilities"}
{"task_id": "DSP/132", "completion": "def predict(summaries, input_array):\n    '''\n    Calculates the probability of each data instance belonging to each class value,\n    looks for the largest probability, and return the associated class.\n    \n    Parameters\n    ----------\n    summaries: A dictionary of numpy arrays\n    input_array: A 1d numpy array\n    \n    Returns\n    -------\n    A 1d numpy array\n    '''\n\n    ##################\n    # YOUR CODE HERE\n    log_prob_temp = list(map(lambda x: calculate_class_log_probabilities(summaries, np.array(x)), input_array))\n    log_prob = {}\n    for key in summaries:\n        temp_list = []\n        for index in range(len(input_array)):\n            temp_list += log_prob_temp[index][key]\n        log_prob[key] = np.array(temp_list)\n    best_label = list(range(len(input_array)))\n    for index in range(len(input_array)):\n        temp_max_label = None\n        for key in summaries:\n            if (temp_max_label is None) or (log_prob[temp_max_label][index] < log_prob[key][index]):\n                temp_max_label = key\n        best_label[index] = temp_max_label\n    ##################\n\n    return best_label"}
{"task_id": "DSP/132", "completion": "def predict(summaries, input_array):\n    '''\n    Calculates the probability of each data instance belonging to each class value,\n    looks for the largest probability, and return the associated class.\n    \n    Parameters\n    ----------\n    summaries: A dictionary of numpy arrays\n    input_array: A 1d numpy array\n    \n    Returns\n    -------\n    A 1d numpy array\n    '''\n\n    ##################\n    # YOUR CODE HERE\n    log_prob_temp = list(map(lambda x: calculate_class_log_probabilities(summaries, np.array(x)), input_array))\n    log_prob = {}\n    for key in summaries:\n        temp_list = []\n        for index in range(len(input_array)):\n            temp_list += log_prob_temp[index][key]\n        log_prob[key] = np.array(temp_list)\n    best_label = list(range(len(input_array)))\n    for index in range(len(input_array)):\n        temp_max_label = None\n        for key in summaries:\n            if (temp_max_label is None) or (log_prob[temp_max_label][index] < log_prob[key][index]):\n                temp_max_label = key\n        best_label[index] = temp_max_label\n    ##################\n\n    return best_label"}
{"task_id": "DSP/133", "completion": "nerve_data_url='http://www.stat.cmu.edu/~larry/all-of-statistics/=data/nerve.dat'\ndef read_data(url):\n    #url retrieve read the ressource on the server abd save it in the disk\n    local_file_name, header = urllib.request.urlretrieve(nerve_data_url)    \n    return np.fromfile(local_file_name, dtype=float, sep='\t')"}
{"task_id": "DSP/133", "completion": "nerve_data_url='http://www.stat.cmu.edu/~larry/all-of-statistics/=data/nerve.dat'\ndef read_data(url):\n    #url retrieve read the ressource on the server abd save it in the disk\n    local_file_name, header = urllib.request.urlretrieve(nerve_data_url)    \n    return np.fromfile(local_file_name, dtype=float, sep='\t')"}
{"task_id": "DSP/134", "completion": "def prob_x(x, data):\n    # YOUR CODE HERE\n    return len(data[np.where(data <= x)])/len(data)"}
{"task_id": "DSP/134", "completion": "def prob_x(x, data):\n    # YOUR CODE HERE\n    return len(data[np.where(data <= x)])/len(data)"}
{"task_id": "DSP/135", "completion": "def prob_xy(x,y,data):\n    return len(data[np.where(np.logical_and(data > x, data <= y))])/len(data)"}
{"task_id": "DSP/135", "completion": "def prob_xy(x,y,data):\n    return len(data[np.where(np.logical_and(data > x, data <= y))])/len(data)"}
{"task_id": "DSP/136", "completion": "def dist_properties(data):\n    \"\"\" the\"\"\"\n    \"\"\"the skwenss of a distrution is the the third order momen\"\"\"\n    stan_dev = np.std(nerve_data)\n    mean_ = np.mean(nerve_data)\n    skewness =( np.sum(np.power( (nerve_data - mean_), 3)) / len(nerve_data) )/ np.power(stan_dev, 3)\n    return  np.mean(nerve_data), np.power(stan_dev, 2), skewness"}
{"task_id": "DSP/136", "completion": "def dist_properties(data):\n    \"\"\" the\"\"\"\n    \"\"\"the skwenss of a distrution is the the third order momen\"\"\"\n    stan_dev = np.std(nerve_data)\n    mean_ = np.mean(nerve_data)\n    skewness =( np.sum(np.power( (nerve_data - mean_), 3)) / len(nerve_data) )/ np.power(stan_dev, 3)\n    return  np.mean(nerve_data), np.power(stan_dev, 2), skewness"}
{"task_id": "DSP/137", "completion": "def get_string(x,y):\n    # YOUR CODE HERE\n    return str(x) + str(y)"}
{"task_id": "DSP/137", "completion": "def get_string(x,y):\n    # YOUR CODE HERE\n    return str(x) + str(y)"}
{"task_id": "DSP/138", "completion": "def ypolynomial(x,p):\n    if isinstance(x, (int, float, complex)) and  isinstance(p, (int, float, complex)):\n        if x < 0:\n            return 0\n        else:\n            return 4 + 5 * np.power(x, p)\n    else:\n        raise TypeError('I works only with string as input')"}
{"task_id": "DSP/138", "completion": "def ypolynomial(x,p):\n    if isinstance(x, (int, float, complex)) and  isinstance(p, (int, float, complex)):\n        if x < 0:\n            return 0\n        else:\n            return 4 + 5 * np.power(x, p)\n    else:\n        raise TypeError('I works only with string as input')"}
{"task_id": "DSP/139", "completion": "def divisibles(N, p):\n    if isinstance(N, (int, float, complex)) and  isinstance(p, (int, float, complex)):\n        if  N < 0:\n            N = 20\n        return list(filter(lambda x : x % p == 0, range(N+1)))"}
{"task_id": "DSP/139", "completion": "def divisibles(N, p):\n    if isinstance(N, (int, float, complex)) and  isinstance(p, (int, float, complex)):\n        if  N < 0:\n            N = 20\n        return list(filter(lambda x : x % p == 0, range(N+1)))"}
{"task_id": "DSP/140", "completion": "def divisibles2(s, N, p):\n    if isinstance(N, (int, float, complex)) and  isinstance(p, (int, float, complex)):\n        if  N < 0:\n            N = 20\n        return list(filter(lambda x : x % p == 0, range(s, N+1)))"}
{"task_id": "DSP/140", "completion": "def divisibles2(s, N, p):\n    if isinstance(N, (int, float, complex)) and  isinstance(p, (int, float, complex)):\n        if  N < 0:\n            N = 20\n        return list(filter(lambda x : x % p == 0, range(s, N+1)))"}
{"task_id": "DSP/141", "completion": "def divisibo(N):\n    if isinstance(N, int):\n        candidate = 1;\n        final_candidates = []\n        count = 0\n        while count  < N:\n            if ((candidate % 5 ==0) & (candidate % 7 ==0) & (candidate % 11 ==0)):\n                count +=1\n                final_candidates.append(candidate)\n            candidate +=1\n        return final_candidates\n    else:\n        raise TypeError('only works with integer')"}
{"task_id": "DSP/141", "completion": "def divisibo(N):\n    if isinstance(N, int):\n        candidate = 1;\n        final_candidates = []\n        count = 0\n        while count  < N:\n            if ((candidate % 5 ==0) & (candidate % 7 ==0) & (candidate % 11 ==0)):\n                count +=1\n                final_candidates.append(candidate)\n            candidate +=1\n        return final_candidates\n    else:\n        raise TypeError('only works with integer')"}
{"task_id": "DSP/142", "completion": "def primes_upto(N):\n    \"\"\"\n    srieve of erathostene????\n    This implies that all the number greater than 1 \n    and less than X shouldn\u2019t divide X to remainder 0. (X % num != 0)\n    \"\"\"\n    if isinstance(N, int):\n        sieve = [True] * (N + 1)\n        sieve[0:1] = [False, False]\n        for start in range(2, N + 1):\n            if sieve[start]:\n                for i in range(start * start, N + 1, start):\n                    sieve[i] = False\n        primes = []\n        for i in range(2, N + 1):\n            if sieve[i]:\n                primes.append(i)\n        return primes\n    else:\n        raise TypeError('Only works with integer')"}
{"task_id": "DSP/142", "completion": "def primes_upto(N):\n    \"\"\"\n    srieve of erathostene????\n    This implies that all the number greater than 1 \n    and less than X shouldn\u2019t divide X to remainder 0. (X % num != 0)\n    \"\"\"\n    if isinstance(N, int):\n        sieve = [True] * (N + 1)\n        sieve[0:1] = [False, False]\n        for start in range(2, N + 1):\n            if sieve[start]:\n                for i in range(start * start, N + 1, start):\n                    sieve[i] = False\n        primes = []\n        for i in range(2, N + 1):\n            if sieve[i]:\n                primes.append(i)\n        return primes\n    else:\n        raise TypeError('Only works with integer')"}
{"task_id": "DSP/143", "completion": "def primes_first(N):\n    def is_prime(n):\n        if n % 2 == 0 and n > 2: \n            return False\n        return all(n % i for i in range(3, int(np.sqrt(n)) + 1, 2))\n    if isinstance(N, int):\n        candidate = 2;\n        final_candidates = []\n        count = 0\n        while count  < N:\n            if (is_prime(candidate)):\n                count +=1\n                final_candidates.append(candidate)\n            candidate +=1\n        return final_candidates\n    else:\n        raise TypeError('only works with integer')"}
{"task_id": "DSP/143", "completion": "def primes_first(N):\n    def is_prime(n):\n        if n % 2 == 0 and n > 2: \n            return False\n        return all(n % i for i in range(3, int(np.sqrt(n)) + 1, 2))\n    if isinstance(N, int):\n        candidate = 2;\n        final_candidates = []\n        count = 0\n        while count  < N:\n            if (is_prime(candidate)):\n                count +=1\n                final_candidates.append(candidate)\n            candidate +=1\n        return final_candidates\n    else:\n        raise TypeError('only works with integer')"}
{"task_id": "DSP/144", "completion": "def flatten_list(superlist):\n    \"\"\"\n    Make an iterator that returns elements from the first iterable until it is exhausted, \n    then proceeds to the next iterable, until all of the iterables are exhausted. \n    Used for treating consecutive sequences as a single sequence:\n    \"\"\"\n    from collections import Iterable\n    from itertools import chain\n    if isinstance(superlist, Iterable):\n        return sorted(list(chain.from_iterable(superlist)))\n    else :\n        raise TypeError('Accept only list')"}
{"task_id": "DSP/144", "completion": "def flatten_list(superlist):\n    \"\"\"\n    Make an iterator that returns elements from the first iterable until it is exhausted, \n    then proceeds to the next iterable, until all of the iterables are exhausted. \n    Used for treating consecutive sequences as a single sequence:\n    \"\"\"\n    from collections import Iterable\n    from itertools import chain\n    if isinstance(superlist, Iterable):\n        return sorted(list(chain.from_iterable(superlist)))\n    else :\n        raise TypeError('Accept only list')"}
{"task_id": "DSP/145", "completion": "def longest_word(text):\n    \"\"\"implement a merge sort from scratch???\n    \"\"\"\n    if isinstance(text, str):\n        text_list = text.split(' ')\n        m = max(list(map(len, text_list)))\n        return [x  for x in text_list if len(x) == m][0]\n    else :\n        raise TypeError('Only works with string ')"}
{"task_id": "DSP/145", "completion": "def longest_word(text):\n    \"\"\"implement a merge sort from scratch???\n    \"\"\"\n    if isinstance(text, str):\n        text_list = text.split(' ')\n        m = max(list(map(len, text_list)))\n        return [x  for x in text_list if len(x) == m][0]\n    else :\n        raise TypeError('Only works with string ')"}
{"task_id": "DSP/146", "completion": "def dictionarize(alist):\n    if isinstance(alist, list):\n        from collections import Counter\n        return Counter(alist)\n    else:\n        raise TypeError('Only works with list')"}
{"task_id": "DSP/146", "completion": "def dictionarize(alist):\n    if isinstance(alist, list):\n        from collections import Counter\n        return Counter(alist)\n    else:\n        raise TypeError('Only works with list')"}
{"task_id": "DSP/147", "completion": "def valid_markings(solution, graph):\n    marked = []\n    for idx, i in enumerate(solution):\n        if  i == 1:\n            #add elme,t as marked by him\n            for edx_j, j in enumerate(graph[i]):\n                if graph[idx][edx_j] == 1:\n                    marked.append(edx_j)\n    return list(set(marked)) == list(range(0, len(graph)))"}
{"task_id": "DSP/147", "completion": "def valid_markings(solution, graph):\n    marked = []\n    for idx, i in enumerate(solution):\n        if  i == 1:\n            #add elme,t as marked by him\n            for edx_j, j in enumerate(graph[i]):\n                if graph[idx][edx_j] == 1:\n                    marked.append(edx_j)\n    return list(set(marked)) == list(range(0, len(graph)))"}
{"task_id": "DSP/148", "completion": "def optimal_markings(input_graph):\n    \"\"\"\n    the following function will return the most optimal marking for an input \n    graph , \n    to do it we will try all possibles marking , and check if they are valid markings by using the previous function\n    once all valid marking are found , we need to sort them according to the number of element it need to do,marking\n    the most optimal marking are the marking with the lowest 1 elements\n    \"\"\"\n    results_counts = []\n    for combination in itertools.product([1, 0], repeat=len(input_graph)):\n        results = combination\n        if valid_markings(results, input_graph):\n            results_counts.append((results.count(1), results))\n    optimal_required = sorted(results_counts, key = lambda x : x[0] )[0][0]\n    optimal_marking = list(filter( lambda x : x[0] == optimal_required, results_counts))\n    return optimal_marking[0]"}
{"task_id": "DSP/148", "completion": "def optimal_markings(input_graph):\n    \"\"\"\n    the following function will return the most optimal marking for an input \n    graph , \n    to do it we will try all possibles marking , and check if they are valid markings by using the previous function\n    once all valid marking are found , we need to sort them according to the number of element it need to do,marking\n    the most optimal marking are the marking with the lowest 1 elements\n    \"\"\"\n    results_counts = []\n    for combination in itertools.product([1, 0], repeat=len(input_graph)):\n        results = combination\n        if valid_markings(results, input_graph):\n            results_counts.append((results.count(1), results))\n    optimal_required = sorted(results_counts, key = lambda x : x[0] )[0][0]\n    optimal_marking = list(filter( lambda x : x[0] == optimal_required, results_counts))\n    return optimal_marking[0]"}
{"task_id": "DSP/149", "completion": "def incr_list_by_1(x):\n    return [i+1 for i in x]"}
{"task_id": "DSP/149", "completion": "def incr_list_by_1(x):\n    return [i+1 for i in x]"}
{"task_id": "DSP/150", "completion": "def change_evens_to_zeros(list):\n    try:\n        return [0 if i % 2 == 0 else i for i in list]\n    except TypeError as err_msg:\n        return 'Can not transform list with non-numeric elements'"}
{"task_id": "DSP/150", "completion": "def change_evens_to_zeros(list):\n    try:\n        return [0 if i % 2 == 0 else i for i in list]\n    except TypeError as err_msg:\n        return 'Can not transform list with non-numeric elements'"}
{"task_id": "DSP/151", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    if len(x) != len(y):\n        return False\n    isSame = True\n    sameCount = 0\n    for d1 in str(x):\n        for d2 in str(y):\n            if d1 == d2:\n                sameCount += 1\n                break;\n    if sameCount != len(x):\n        isSame = False\n    return isSame"}
{"task_id": "DSP/151", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    if len(x) != len(y):\n        return False\n    isSame = True\n    sameCount = 0\n    for d1 in str(x):\n        for d2 in str(y):\n            if d1 == d2:\n                sameCount += 1\n                break;\n    if sameCount != len(x):\n        isSame = False\n    return isSame"}
{"task_id": "DSP/152", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', delimiter=',')"}
{"task_id": "DSP/152", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', delimiter=',')"}
{"task_id": "DSP/153", "completion": "s4 = df1.iloc[0::2]['cell_phone']\n#s4 = s4['cell_phone']\ns4"}
{"task_id": "DSP/153", "completion": "s4 = df1.iloc[0::2]['cell_phone']\n#s4 = s4['cell_phone']\ns4"}
{"task_id": "DSP/154", "completion": "ce = create_engine('sqlite:///data/Chinook_Sqlite.sqlite')"}
{"task_id": "DSP/154", "completion": "ce = create_engine('sqlite:///data/Chinook_Sqlite.sqlite')"}
{"task_id": "DSP/155", "completion": "inspector = inspect(ce)"}
{"task_id": "DSP/155", "completion": "inspector = inspect(ce)"}
{"task_id": "DSP/156", "completion": "t1 = table_info('Genre', inspector)"}
{"task_id": "DSP/156", "completion": "t1 = table_info('Genre', inspector)"}
{"task_id": "DSP/157", "completion": "t2 = sql.read_sql_query(\"\"\"\n    SELECT *\n    FROM genre\n    LIMIT 10;\n\"\"\", ce)"}
{"task_id": "DSP/157", "completion": "t2 = sql.read_sql_query(\"\"\"\n    SELECT *\n    FROM genre\n    LIMIT 10;\n\"\"\", ce)"}
{"task_id": "DSP/158", "completion": "t3 = table_info('Track', inspector)"}
{"task_id": "DSP/158", "completion": "t3 = table_info('Track', inspector)"}
{"task_id": "DSP/159", "completion": "t4 = sql.read_sql_query(\"\"\"\n    SELECT *\n    FROM track\n    LIMIT 10;\n\"\"\", ce)"}
{"task_id": "DSP/159", "completion": "t4 = sql.read_sql_query(\"\"\"\n    SELECT *\n    FROM track\n    LIMIT 10;\n\"\"\", ce)"}
{"task_id": "DSP/160", "completion": "t5 = table_info('MediaType', inspector)"}
{"task_id": "DSP/160", "completion": "t5 = table_info('MediaType', inspector)"}
{"task_id": "DSP/161", "completion": "t6 = sql.read_sql_query(\"\"\"\n    SELECT *\n    FROM mediatype\n    LIMIT 10;\n\"\"\", ce)"}
{"task_id": "DSP/161", "completion": "t6 = sql.read_sql_query(\"\"\"\n    SELECT *\n    FROM mediatype\n    LIMIT 10;\n\"\"\", ce)"}
{"task_id": "DSP/162", "completion": "t7 = sql.read_sql_query(\"\"\"\n    SELECT name, composer, unitPrice\n    FROM track\n    WHERE unitPrice > 0.99\n\"\"\", ce)"}
{"task_id": "DSP/162", "completion": "t7 = sql.read_sql_query(\"\"\"\n    SELECT name, composer, unitPrice\n    FROM track\n    WHERE unitPrice > 0.99\n\"\"\", ce)"}
{"task_id": "DSP/163", "completion": "j2 = sql.read_sql_query(\"\"\"\n    SELECT MediaType.name, COUNT(MediaType.name) AS Count\n    FROM MediaType\n    INNER JOIN Track\n    ON Track.mediaTypeID = MediaType.mediaTypeID\n    GROUP BY MediaType.name\n    ORDER BY Count\n\"\"\", ce)"}
{"task_id": "DSP/163", "completion": "j2 = sql.read_sql_query(\"\"\"\n    SELECT MediaType.name, COUNT(MediaType.name) AS Count\n    FROM MediaType\n    INNER JOIN Track\n    ON Track.mediaTypeID = MediaType.mediaTypeID\n    GROUP BY MediaType.name\n    ORDER BY Count\n\"\"\", ce)"}
{"task_id": "DSP/164", "completion": "def soliton(x, t, c, a):\n    \"\"\"Return phi(x, t) for a soliton wave with constants c and a.\"\"\"\n    coeff = .5 * c\n    cosh = np.cosh((c**(-.5)*.5)*(x - c * t - a))\n    f = 1 / np.power(cosh, 2)\n    phi = coeff * f\n    return phi"}
{"task_id": "DSP/164", "completion": "def soliton(x, t, c, a):\n    \"\"\"Return phi(x, t) for a soliton wave with constants c and a.\"\"\"\n    coeff = .5 * c\n    cosh = np.cosh((c**(-.5)*.5)*(x - c * t - a))\n    f = 1 / np.power(cosh, 2)\n    phi = coeff * f\n    return phi"}
{"task_id": "DSP/165", "completion": "phi = soliton(xn, tn, c, a)"}
{"task_id": "DSP/165", "completion": "phi = soliton(xn, tn, c, a)"}
{"task_id": "DSP/166", "completion": "df2 = df.dropna()"}
{"task_id": "DSP/166", "completion": "df2 = df.dropna()"}
{"task_id": "DSP/167", "completion": "df5 = df5.fillna(-9)\n#df5"}
{"task_id": "DSP/167", "completion": "df5 = df5.fillna(-9)\n#df5"}
{"task_id": "DSP/168", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = np.sqrt(3*sigma**2)\n    a = mu - d\n    b = mu + d\n    n = np.random.uniform(a, b, size)\n    return n"}
{"task_id": "DSP/168", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = np.sqrt(3*sigma**2)\n    a = mu - d\n    b = mu + d\n    n = np.random.uniform(a, b, size)\n    return n"}
{"task_id": "DSP/169", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/169", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/170", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/170", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/171", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    assert len(x)==len(y)\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen: #could use len(x) directly\n        Vsum.append(x[i] + y[i])\n        i += 1\n    return Vsum"}
{"task_id": "DSP/171", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    assert len(x)==len(y)\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen: #could use len(x) directly\n        Vsum.append(x[i] + y[i])\n        i += 1\n    return Vsum"}
{"task_id": "DSP/172", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    assert len(x)==len(y)\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen:\n        Vsum.append(x[i] - y[i])\n        i += 1\n    return Vsum"}
{"task_id": "DSP/172", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    assert len(x)==len(y)\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen:\n        Vsum.append(x[i] - y[i])\n        i += 1\n    return Vsum"}
{"task_id": "DSP/173", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen:\n        Vsum.append(x[i] * a)\n        i += 1\n    return Vsum"}
{"task_id": "DSP/173", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen:\n        Vsum.append(x[i] * a)\n        i += 1\n    return Vsum"}
{"task_id": "DSP/174", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    assert len(x)==len(y)\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen:\n        Vsum.append(x[i] * y[i])\n        i += 1\n    return sum(Vsum)"}
{"task_id": "DSP/174", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    assert len(x)==len(y)\n    i = 0\n    Vlen = len(x)\n    Vsum = []\n    while i < Vlen:\n        Vsum.append(x[i] * y[i])\n        i += 1\n    return sum(Vsum)"}
{"task_id": "DSP/175", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    norm = 0\n    Vlen = len(x)\n    i = 0\n    while i < Vlen:\n        norm += abs(x[i])\n        i += 1\n    return norm"}
{"task_id": "DSP/175", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    norm = 0\n    Vlen = len(x)\n    i = 0\n    while i < Vlen:\n        norm += abs(x[i])\n        i += 1\n    return norm"}
{"task_id": "DSP/176", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    norm = 0\n    Vlen = len(x)\n    i = 0\n    ans = 0\n    while i < Vlen:\n        norm += x[i] **2\n        i += 1\n    ans = math.sqrt(norm)\n    return ans"}
{"task_id": "DSP/176", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    norm = 0\n    Vlen = len(x)\n    i = 0\n    ans = 0\n    while i < Vlen:\n        norm += x[i] **2\n        i += 1\n    ans = math.sqrt(norm)\n    return ans"}
{"task_id": "DSP/177", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    i = 0\n    L = []\n    while i < len(x):\n        sub = x[i] - y[i]\n        L.append(sub **2)\n        i += 1\n    return sum(L) / len(x)"}
{"task_id": "DSP/177", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    i = 0\n    L = []\n    while i < len(x):\n        sub = x[i] - y[i]\n        L.append(sub **2)\n        i += 1\n    return sum(L) / len(x)"}
{"task_id": "DSP/178", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    return sum(x) / len(x)"}
{"task_id": "DSP/178", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    return sum(x) / len(x)"}
{"task_id": "DSP/179", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    ans = 0\n    i = 0\n    while i < len(x):\n        ans += ((x[i] - mean(x)) **2)\n        i += 1\n    return ans / len(x)"}
{"task_id": "DSP/179", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    ans = 0\n    i = 0\n    while i < len(x):\n        ans += ((x[i] - mean(x)) **2)\n        i += 1\n    return ans / len(x)"}
{"task_id": "DSP/180", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/180", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/181", "completion": "(t, W) = wiener(1.0, 1000)\nlen(W)"}
{"task_id": "DSP/181", "completion": "(t, W) = wiener(1.0, 1000)\nlen(W)"}
{"task_id": "DSP/182", "completion": "mpg_data = None\nmpg_data = pd.read_fwf(\"http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data\", header = None)\nmpg_data.columns = [\"mpg\", \"cylinders\", \"displacement\", \"horsepower\", \"weight\", \"acceleration\", \"model_year\", \"origin\", \"car_name\"]"}
{"task_id": "DSP/182", "completion": "mpg_data = None\nmpg_data = pd.read_fwf(\"http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data\", header = None)\nmpg_data.columns = [\"mpg\", \"cylinders\", \"displacement\", \"horsepower\", \"weight\", \"acceleration\", \"model_year\", \"origin\", \"car_name\"]"}
{"task_id": "DSP/183", "completion": "mpg_data.horsepower = mpg_data.horsepower.astype(float)\nmpg_data.horsepower.unique()"}
{"task_id": "DSP/183", "completion": "mpg_data.horsepower = mpg_data.horsepower.astype(float)\nmpg_data.horsepower.unique()"}
{"task_id": "DSP/184", "completion": "mpg_data = mpg_data.drop(mpg_data[pd.isnull(mpg_data['horsepower'])].index)"}
{"task_id": "DSP/184", "completion": "mpg_data = mpg_data.drop(mpg_data[pd.isnull(mpg_data['horsepower'])].index)"}
{"task_id": "DSP/185", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/185", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/186", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\", header = None, sep = \", \")\nincome_data.columns = [\"age\", \"workclass\", \"fnlwgt\", \"education\", \"education_num\", \"marital_status\", \"occupation\", \"relationship\", \"race\", \"sex\", \"capital_gain\", \"capital_loss\", \"hours_per_week\", \"native_country\", \"label\"\n]\nincome_data.head()"}
{"task_id": "DSP/186", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\", header = None, sep = \", \")\nincome_data.columns = [\"age\", \"workclass\", \"fnlwgt\", \"education\", \"education_num\", \"marital_status\", \"occupation\", \"relationship\", \"race\", \"sex\", \"capital_gain\", \"capital_loss\", \"hours_per_week\", \"native_country\", \"label\"\n]\nincome_data.head()"}
{"task_id": "DSP/187", "completion": "def get_mean_working_hours_by_income(dataframe):\n    grouped = dataframe.groupby('occupation')['hours_per_week'].mean()\n    \n    return grouped.sort_values(ascending = False)"}
{"task_id": "DSP/187", "completion": "def get_mean_working_hours_by_income(dataframe):\n    grouped = dataframe.groupby('occupation')['hours_per_week'].mean()\n    \n    return grouped.sort_values(ascending = False)"}
{"task_id": "DSP/188", "completion": "titanic_data = pd.read_csv(\"data/titanic.csv\")\ntitanic_data.set_index('PassengerId', inplace = True)\ntitanic_data.rename(columns = {\"Pclass\": \"Class\", \"Parch\": \"ParCh\"}, inplace = True)\ntitanic_data.loc[titanic_data.Embarked == 'C', 'Embarked'] = 'Cherbourg'\ntitanic_data.loc[titanic_data.Embarked == 'Q', 'Embarked'] = 'Queenstown'\ntitanic_data.loc[titanic_data.Embarked == 'S', 'Embarked'] = 'Southampton'\n\ntitanic_data.head()"}
{"task_id": "DSP/188", "completion": "titanic_data = pd.read_csv(\"data/titanic.csv\")\ntitanic_data.set_index('PassengerId', inplace = True)\ntitanic_data.rename(columns = {\"Pclass\": \"Class\", \"Parch\": \"ParCh\"}, inplace = True)\ntitanic_data.loc[titanic_data.Embarked == 'C', 'Embarked'] = 'Cherbourg'\ntitanic_data.loc[titanic_data.Embarked == 'Q', 'Embarked'] = 'Queenstown'\ntitanic_data.loc[titanic_data.Embarked == 'S', 'Embarked'] = 'Southampton'\n\ntitanic_data.head()"}
{"task_id": "DSP/189", "completion": "ages_by_class = titanic_data.groupby('Class')['Age']"}
{"task_id": "DSP/189", "completion": "ages_by_class = titanic_data.groupby('Class')['Age']"}
{"task_id": "DSP/190", "completion": "test_result = ttest_ind(first_class_ages, third_class_ages)\n\nprint(test_result.pvalue)\nif test_result.pvalue <= 0.01:\n    print(\"The differences in age are significant. Reject H0.\")\nelse:\n    print(\"There's not enough evidence to reject H0. Don't accept or reject anything else.\")"}
{"task_id": "DSP/190", "completion": "test_result = ttest_ind(first_class_ages, third_class_ages)\n\nprint(test_result.pvalue)\nif test_result.pvalue <= 0.01:\n    print(\"The differences in age are significant. Reject H0.\")\nelse:\n    print(\"There's not enough evidence to reject H0. Don't accept or reject anything else.\")"}
{"task_id": "DSP/191", "completion": "titanic_data_for_modelling.drop(\"Sex_female\", axis = 1, inplace = True)"}
{"task_id": "DSP/191", "completion": "titanic_data_for_modelling.drop(\"Sex_female\", axis = 1, inplace = True)"}
{"task_id": "DSP/192", "completion": "scaler = MinMaxScaler()\ntitanic_data_features_scaled = scaler.fit_transform(titanic_data_features)"}
{"task_id": "DSP/192", "completion": "scaler = MinMaxScaler()\ntitanic_data_features_scaled = scaler.fit_transform(titanic_data_features)"}
{"task_id": "DSP/193", "completion": "model = LogisticRegression()\nmodel.fit(features_train, target_train)"}
{"task_id": "DSP/193", "completion": "model = LogisticRegression()\nmodel.fit(features_train, target_train)"}
{"task_id": "DSP/194", "completion": "score = model.score(features_test, target_test)\nscore"}
{"task_id": "DSP/194", "completion": "score = model.score(features_test, target_test)\nscore"}
{"task_id": "DSP/195", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\ndef concatenate_images(images):\n    \"\"\"\n    Concatenates all images vertically (one below the other)\n    \"\"\"\n    return np.vstack(resize_images(images))"}
{"task_id": "DSP/195", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\ndef concatenate_images(images):\n    \"\"\"\n    Concatenates all images vertically (one below the other)\n    \"\"\"\n    return np.vstack(resize_images(images))"}
{"task_id": "DSP/196", "completion": "menu_content = \"\"\nwith open(\"output/menu.txt\", \"r\", encoding = \"utf-8\") as f:\n    menu_content = f.read()\n\nprint(menu_content)"}
{"task_id": "DSP/196", "completion": "menu_content = \"\"\nwith open(\"output/menu.txt\", \"r\", encoding = \"utf-8\") as f:\n    menu_content = f.read()\n\nprint(menu_content)"}
{"task_id": "DSP/197", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    df = pd.read_csv(io.StringIO(meals_string), sep=\"|\", header=None)\n    df.columns = ['category', 'meal_name', 'price']\n    df['category'] = df['category'].str.lower()\n\n    return df"}
{"task_id": "DSP/197", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    df = pd.read_csv(io.StringIO(meals_string), sep=\"|\", header=None)\n    df.columns = ['category', 'meal_name', 'price']\n    df['category'] = df['category'].str.lower()\n\n    return df"}
{"task_id": "DSP/198", "completion": "num_items_total = meals_table.shape[0]\nnum_categories_total = meals_table.category.nunique()\nnum_items_by_category = meals_table.groupby(['category'])['meal_name'].count()\nmean_price_by_category = meals_table.groupby(['category'])['price'].mean()"}
{"task_id": "DSP/198", "completion": "num_items_total = meals_table.shape[0]\nnum_categories_total = meals_table.category.nunique()\nnum_items_by_category = meals_table.groupby(['category'])['meal_name'].count()\nmean_price_by_category = meals_table.groupby(['category'])['price'].mean()"}
{"task_id": "DSP/199", "completion": "def simulate(transitions):\n    # >>>>> YOUR CODE HERE\n    import random\n    random.seed(123)\n    state_sequence = []\n    current_state = 'A'\n    for i in range(1999):\n        r = random.randint(0, 2)\n        current_state = transitions[current_state][r % len(transitions[current_state])]\n        state_sequence.append(current_state)\n    # <<<<< END YOUR CODE\n    return state_sequence"}
{"task_id": "DSP/199", "completion": "def simulate(transitions):\n    # >>>>> YOUR CODE HERE\n    import random\n    random.seed(123)\n    state_sequence = []\n    current_state = 'A'\n    for i in range(1999):\n        r = random.randint(0, 2)\n        current_state = transitions[current_state][r % len(transitions[current_state])]\n        state_sequence.append(current_state)\n    # <<<<< END YOUR CODE\n    return state_sequence"}
{"task_id": "DSP/200", "completion": "def compute_histogram(state_sequence):\n    # >>>>> YOUR CODE HERE\n    histogram = [state_sequence.count(state) / len(state_sequence) for state in S]\n    # <<<<< END YOUR CODE\n    return histogram"}
{"task_id": "DSP/200", "completion": "def compute_histogram(state_sequence):\n    # >>>>> YOUR CODE HERE\n    histogram = [state_sequence.count(state) / len(state_sequence) for state in S]\n    # <<<<< END YOUR CODE\n    return histogram"}
{"task_id": "DSP/201", "completion": "def get_stationary(matrix):\n    # >>>>> YOUR CODE HERE\n    import utils\n    stationary_distribution = utils.getstationary(matrix)\n    # <<<<< END YOUR CODE\n    return stationary_distribution"}
{"task_id": "DSP/201", "completion": "def get_stationary(matrix):\n    # >>>>> YOUR CODE HERE\n    import utils\n    stationary_distribution = utils.getstationary(matrix)\n    # <<<<< END YOUR CODE\n    return stationary_distribution"}
{"task_id": "DSP/202", "completion": "import utils\nP = build_transition_matrix()\nutils.getstationary(P)\n# <<<<< END YOUR CODE"}
{"task_id": "DSP/202", "completion": "import utils\nP = build_transition_matrix()\nutils.getstationary(P)\n# <<<<< END YOUR CODE"}
{"task_id": "DSP/203", "completion": "def simulate_1000():\n    # >>>>> YOUR CODE HERE\n    import utils\n    initial_states = utils.getinitialstate() # 1000 x 8 initial state in 1000 trials\n    transitions = build_transition_matrix() # transitions\n    pad_shape = ((0, 0), (1, 0)) \n    transitions = numpy.pad(transitions, pad_shape, mode='constant')\n    for time_step in range(500):\n        initial_states = utils.mcstep(initial_states, transitions, time_step)\n    state_amount = transitions.shape[0]\n    estimated_stationary_distribution = numpy.zeros(state_amount)\n    for state in range(state_amount):\n        estimated_stationary_distribution[state] = numpy.count_nonzero(initial_states[:,state]) / initial_states.shape[0]\n    # <<<<< END YOUR CODE\n    return estimated_stationary_distribution"}
{"task_id": "DSP/203", "completion": "def simulate_1000():\n    # >>>>> YOUR CODE HERE\n    import utils\n    initial_states = utils.getinitialstate() # 1000 x 8 initial state in 1000 trials\n    transitions = build_transition_matrix() # transitions\n    pad_shape = ((0, 0), (1, 0)) \n    transitions = numpy.pad(transitions, pad_shape, mode='constant')\n    for time_step in range(500):\n        initial_states = utils.mcstep(initial_states, transitions, time_step)\n    state_amount = transitions.shape[0]\n    estimated_stationary_distribution = numpy.zeros(state_amount)\n    for state in range(state_amount):\n        estimated_stationary_distribution[state] = numpy.count_nonzero(initial_states[:,state]) / initial_states.shape[0]\n    # <<<<< END YOUR CODE\n    return estimated_stationary_distribution"}
{"task_id": "DSP/204", "completion": "def simulate(transitions):\n    # >>>>> YOUR CODE HERE\n    import random\n    random.seed(123)\n    state_sequence = []\n    current_state = 'A'\n    for i in range(1999):\n        r = random.randint(0, 2)\n        current_state = transitions[current_state][r % len(transitions[current_state])]\n        state_sequence.append(current_state)\n    # <<<<< END YOUR CODE\n    return state_sequence"}
{"task_id": "DSP/204", "completion": "def simulate(transitions):\n    # >>>>> YOUR CODE HERE\n    import random\n    random.seed(123)\n    state_sequence = []\n    current_state = 'A'\n    for i in range(1999):\n        r = random.randint(0, 2)\n        current_state = transitions[current_state][r % len(transitions[current_state])]\n        state_sequence.append(current_state)\n    # <<<<< END YOUR CODE\n    return state_sequence"}
{"task_id": "DSP/205", "completion": "def compute_histogram(state_sequence):\n    # >>>>> YOUR CODE HERE\n    histogram = [state_sequence.count(state) / len(state_sequence) for state in S]\n    # <<<<< END YOUR CODE\n    return histogram"}
{"task_id": "DSP/205", "completion": "def compute_histogram(state_sequence):\n    # >>>>> YOUR CODE HERE\n    histogram = [state_sequence.count(state) / len(state_sequence) for state in S]\n    # <<<<< END YOUR CODE\n    return histogram"}
{"task_id": "DSP/206", "completion": "def get_stationary(matrix):\n    # >>>>> YOUR CODE HERE\n    import utils\n    stationary_distribution = utils.getstationary(matrix)\n    # <<<<< END YOUR CODE\n    return stationary_distribution"}
{"task_id": "DSP/206", "completion": "def get_stationary(matrix):\n    # >>>>> YOUR CODE HERE\n    import utils\n    stationary_distribution = utils.getstationary(matrix)\n    # <<<<< END YOUR CODE\n    return stationary_distribution"}
{"task_id": "DSP/207", "completion": "import utils\nP = build_transition_matrix()\nutils.getstationary(P)\n# <<<<< END YOUR CODE"}
{"task_id": "DSP/207", "completion": "import utils\nP = build_transition_matrix()\nutils.getstationary(P)\n# <<<<< END YOUR CODE"}
{"task_id": "DSP/208", "completion": "def simulate_1000():\n    # >>>>> YOUR CODE HERE\n    import utils\n    X = utils.getinitialstate()\n    P = build_transition_matrix()\n    pad_shape = ((0, 0), (1, 0)) \n    P = numpy.pad(P, pad_shape, mode='constant')\n    for i in range(500):\n        X = utils.mcstep(X, P, i)\n    n = P.shape[0]\n    estimated_stationary_distribution = numpy.zeros(n)\n    for i in range(n):\n        estimated_stationary_distribution[i] = numpy.count_nonzero(X[:,i]) / X.shape[0]\n    # <<<<< END YOUR CODE\n    return estimated_stationary_distribution"}
{"task_id": "DSP/208", "completion": "def simulate_1000():\n    # >>>>> YOUR CODE HERE\n    import utils\n    X = utils.getinitialstate()\n    P = build_transition_matrix()\n    pad_shape = ((0, 0), (1, 0)) \n    P = numpy.pad(P, pad_shape, mode='constant')\n    for i in range(500):\n        X = utils.mcstep(X, P, i)\n    n = P.shape[0]\n    estimated_stationary_distribution = numpy.zeros(n)\n    for i in range(n):\n        estimated_stationary_distribution[i] = numpy.count_nonzero(X[:,i]) / X.shape[0]\n    # <<<<< END YOUR CODE\n    return estimated_stationary_distribution"}
{"task_id": "DSP/209", "completion": "import pickle, gzip\n\n# YOUR CODE HERE\ndef write_pickle(obj, destination=\"temp.pickle\", write_over=True):\n    \"\"\"\n    Saves an object to a compressed pickle file\n    Arguments:\n        obj: the object to pickle\n        destination: the destination of the pickle file\n        write_over: a flag that if True will write over an existing file and if False will raise a `FileExistsError`` if a file with that name exists\n    Returns:\n        p_file: the pickled file\n    \n    \"\"\"\n    directoryFiles = os.listdir(os.getcwd())\n    if destination in directoryFiles:\n        if write_over == True:\n            f=gzip.open(destination,'wb')\n            pickle.dump(obj,f)  \n            f.close()\n        else:\n            raise FileExistsError\n    else:\n        f=gzip.open(destination,'wb')\n        pickle.dump(obj,f)  \n        f.close()"}
{"task_id": "DSP/209", "completion": "import pickle, gzip\n\n# YOUR CODE HERE\ndef write_pickle(obj, destination=\"temp.pickle\", write_over=True):\n    \"\"\"\n    Saves an object to a compressed pickle file\n    Arguments:\n        obj: the object to pickle\n        destination: the destination of the pickle file\n        write_over: a flag that if True will write over an existing file and if False will raise a `FileExistsError`` if a file with that name exists\n    Returns:\n        p_file: the pickled file\n    \n    \"\"\"\n    directoryFiles = os.listdir(os.getcwd())\n    if destination in directoryFiles:\n        if write_over == True:\n            f=gzip.open(destination,'wb')\n            pickle.dump(obj,f)  \n            f.close()\n        else:\n            raise FileExistsError\n    else:\n        f=gzip.open(destination,'wb')\n        pickle.dump(obj,f)  \n        f.close()"}
{"task_id": "DSP/210", "completion": "import numpy as np\nimport numbers\n\ndef d1a(s, h=1):\n    \"\"\"\n    Computes the 1st derivative of a 1-D numpy array using a backward difference approximation of the derivative.\n    Arguments:\n        s: the 1-D numpy array we will take the first derivative of.\n        h: the unit step size (i.e. what the length of one step in the array represents).\n    Returns:\n        d1: thd 1st derivative of s.\n    \"\"\"\n    if not isinstance(s, np.ndarray) or not isinstance(h, numbers.Number):\n        raise TypeError\n    elif h<0:\n        raise ValueError\n\n    d1 = np.zeros(len(s))\n    d1[1:] = (s[1:]-s[:-1]) / h\n    \n    return d1\n\nplt.plot(tt, d1a(fp1(tt)))"}
{"task_id": "DSP/210", "completion": "import numpy as np\nimport numbers\n\ndef d1a(s, h=1):\n    \"\"\"\n    Computes the 1st derivative of a 1-D numpy array using a backward difference approximation of the derivative.\n    Arguments:\n        s: the 1-D numpy array we will take the first derivative of.\n        h: the unit step size (i.e. what the length of one step in the array represents).\n    Returns:\n        d1: thd 1st derivative of s.\n    \"\"\"\n    if not isinstance(s, np.ndarray) or not isinstance(h, numbers.Number):\n        raise TypeError\n    elif h<0:\n        raise ValueError\n\n    d1 = np.zeros(len(s))\n    d1[1:] = (s[1:]-s[:-1]) / h\n    \n    return d1\n\nplt.plot(tt, d1a(fp1(tt)))"}
{"task_id": "DSP/211", "completion": "import numpy as np\nimport numbers\n\ndef d1b(s, h=1):\n    \"\"\"\n    Computes the 1st derivative of a 1-D numpy array using a centered difference approximation of the derivative.\n    Arguments:\n        s: the 1-D numpy array we will take the first derivative of.\n        h: the unit step size (i.e. what the length of one step in the array represents).\n    Returns:\n        d1: thd 1st derivative of s.\n    \"\"\"\n    if not isinstance(s, np.ndarray) or not isinstance(h, numbers.Number):\n        raise TypeError\n    elif h<0:\n        raise ValueError\n\n    d1 = np.zeros(len(s))\n    d1[1:-1] = (s[2:]-s[:-2]) / (2*h)\n    \n    return d1\n\nplt.plot(tt, d1b(fp1(tt), h=0.1))"}
{"task_id": "DSP/211", "completion": "import numpy as np\nimport numbers\n\ndef d1b(s, h=1):\n    \"\"\"\n    Computes the 1st derivative of a 1-D numpy array using a centered difference approximation of the derivative.\n    Arguments:\n        s: the 1-D numpy array we will take the first derivative of.\n        h: the unit step size (i.e. what the length of one step in the array represents).\n    Returns:\n        d1: thd 1st derivative of s.\n    \"\"\"\n    if not isinstance(s, np.ndarray) or not isinstance(h, numbers.Number):\n        raise TypeError\n    elif h<0:\n        raise ValueError\n\n    d1 = np.zeros(len(s))\n    d1[1:-1] = (s[2:]-s[:-2]) / (2*h)\n    \n    return d1\n\nplt.plot(tt, d1b(fp1(tt), h=0.1))"}
{"task_id": "DSP/212", "completion": "import numpy as np\nimport numbers\n\ndef d1c(s, h=1):\n    \"\"\"\n    Computes the 1st derivative of a 1-D numpy array using a Taylor series expansion of the 1st derivative.\n    Arguments:\n        s: the 1-D numpy array we will take the first derivative of.\n        h: the unit step size (i.e. what the length of one step in the array represents).\n    Returns:\n        d1: thd 1st derivative of s.\n    \"\"\"\n    if not isinstance(s, np.ndarray) or not isinstance(h, numbers.Number):\n        raise TypeError\n    elif h<0:\n        raise ValueError\n\n    d1 = np.zeros(len(s))\n    d1[2:-2] = ( -s[4:] + (8*s[3:-1]) - (8*s[1:-3]) + s[:-4] ) / (12*h)\n    \n    return d1\n\nplt.plot(tt, d1c(fp1(tt)))"}
{"task_id": "DSP/212", "completion": "import numpy as np\nimport numbers\n\ndef d1c(s, h=1):\n    \"\"\"\n    Computes the 1st derivative of a 1-D numpy array using a Taylor series expansion of the 1st derivative.\n    Arguments:\n        s: the 1-D numpy array we will take the first derivative of.\n        h: the unit step size (i.e. what the length of one step in the array represents).\n    Returns:\n        d1: thd 1st derivative of s.\n    \"\"\"\n    if not isinstance(s, np.ndarray) or not isinstance(h, numbers.Number):\n        raise TypeError\n    elif h<0:\n        raise ValueError\n\n    d1 = np.zeros(len(s))\n    d1[2:-2] = ( -s[4:] + (8*s[3:-1]) - (8*s[1:-3]) + s[:-4] ) / (12*h)\n    \n    return d1\n\nplt.plot(tt, d1c(fp1(tt)))"}
{"task_id": "DSP/213", "completion": "ts = symbols('ts')\ndef kinetics(t, A=200, b=0.46, k=0.35):\n    # YOUR CODE HERE\n    \"\"\"\n    Represents a pharmokinetic model of drug absorption and clearance.\n    \n    Arguments:\n        t: time\n        A: constant\n        b: clearance rate for the digestive system with b > k typically.\n        k: time constant representing how the drug is cleared from body (e.g. through urine)\n        \n    Returns: the max dose time\n        \"\"\"\n    return (A*b/(b-k))*( (exp(-k*t)) - (exp(-b*t)) )"}
{"task_id": "DSP/213", "completion": "ts = symbols('ts')\ndef kinetics(t, A=200, b=0.46, k=0.35):\n    # YOUR CODE HERE\n    \"\"\"\n    Represents a pharmokinetic model of drug absorption and clearance.\n    \n    Arguments:\n        t: time\n        A: constant\n        b: clearance rate for the digestive system with b > k typically.\n        k: time constant representing how the drug is cleared from body (e.g. through urine)\n        \n    Returns: the max dose time\n        \"\"\"\n    return (A*b/(b-k))*( (exp(-k*t)) - (exp(-b*t)) )"}
{"task_id": "DSP/214", "completion": "sequences = {\"seq1\": sequence1, \"seq2\": sequence2, \"seq3\": sequence3}"}
{"task_id": "DSP/214", "completion": "sequences = {\"seq1\": sequence1, \"seq2\": sequence2, \"seq3\": sequence3}"}
{"task_id": "DSP/215", "completion": "sequences = {\"seq1\":sequence1, \"seq2\":sequence2, \"seq3\":sequence3}\n# YOUR CODE HERE\ndef count_kmers(sequences, kmers):\n    rslts = {} #rslts = {seq1:{kmer1:freq, kmer2:freq, kmer3 freq}, seq2:{kmer1:freq, kmer2:freq}}\n    if kmers == None:\n        kmers = ('A')\n    for seq in sequences:\n        sequence = sequences[seq]\n        \"\".join(sequence.split())\n        entry = {}\n        for kmer in kmers:\n            entry[kmer] = 0\n            l = len(kmer)\n            for i in range(0, len(sequence)):\n                test = sequence[i:i+l]\n                if len(test) != l:\n                    break\n                if test == kmer:\n                    entry[kmer] += 1\n                    \n        rslts[seq] = entry\n    \n    print(rslts)\n    return rslts\n#raise NotImplementedError()"}
{"task_id": "DSP/215", "completion": "sequences = {\"seq1\":sequence1, \"seq2\":sequence2, \"seq3\":sequence3}\n# YOUR CODE HERE\ndef count_kmers(sequences, kmers):\n    rslts = {} #rslts = {seq1:{kmer1:freq, kmer2:freq, kmer3 freq}, seq2:{kmer1:freq, kmer2:freq}}\n    if kmers == None:\n        kmers = ('A')\n    for seq in sequences:\n        sequence = sequences[seq]\n        \"\".join(sequence.split())\n        entry = {}\n        for kmer in kmers:\n            entry[kmer] = 0\n            l = len(kmer)\n            for i in range(0, len(sequence)):\n                test = sequence[i:i+l]\n                if len(test) != l:\n                    break\n                if test == kmer:\n                    entry[kmer] += 1\n                    \n        rslts[seq] = entry\n    \n    print(rslts)\n    return rslts\n#raise NotImplementedError()"}
{"task_id": "DSP/216", "completion": "def validate_alpha(alpha):\n    # YOUR CODE HERE\n    alpha = float(alpha)\n    if alpha > 0 and alpha < 1:\n        return alpha\n    else:\n        raise ValueError"}
{"task_id": "DSP/216", "completion": "def validate_alpha(alpha):\n    # YOUR CODE HERE\n    alpha = float(alpha)\n    if alpha > 0 and alpha < 1:\n        return alpha\n    else:\n        raise ValueError"}
{"task_id": "DSP/217", "completion": "def validate_color(color):    \n    # YOUR CODE HERE\n    color = int(color)\n    if color >= 0 and color <= 255:\n        return color\n    else:\n        raise ValueError"}
{"task_id": "DSP/217", "completion": "def validate_color(color):    \n    # YOUR CODE HERE\n    color = int(color)\n    if color >= 0 and color <= 255:\n        return color\n    else:\n        raise ValueError"}
{"task_id": "DSP/218", "completion": "from collections import namedtuple\nimport math\nrgbalpha = namedtuple(\"rgbalpha\",['r','g','b','alpha'])\nclass rgba(rgbalpha):\n    def __new__(cls, *args, **kwargs):\n        return super().__new__(cls, validate_color(args[0]),\n                          validate_color(args[1]),\n                          validate_color(args[2]),\n                          validate_alpha(args[3]))\n    def __init__(self, *args, name=\"null\"):\n        # YOUR CODE HERE\n        self.r = args[0]\n        self.g = args[1]\n        self.b = args[2]\n        self.alpha = args[3]\n        \n    @property\n    # YOUR CODE HERE\n    def alpha(self):\n        return self.__alpha\n    @alpha.setter\n    # YOUR CODE HERE\n    def alpha(self,alpha):\n        self.__alpha = alpha\n        \n    @property\n    # YOUR CODE HERE\n    def r(self):\n        return self.__r\n    @r.setter\n    # YOUR CODE HERE\n    def r(self,r):\n        self.__r = int(r)\n        \n    @property\n    # YOUR CODE HERE\n    def g(self):\n        return self.__g\n    @g.setter\n    # YOUR CODE HERE\n    def g(self,g):\n        self.__g = int(g)\n      \n    @property\n    # YOUR CODE HERE\n    def b(self):\n        return self.__b\n    @b.setter\n    # YOUR CODE HERE\n    def b(self,b):\n        self.__b = int(b)\n    \n    \n    def invert_rgb(self): \n        \"\"\"\n        this function inverts the RGB color by subtracting \n        all color values from 255 and returns a new rgba object with the \n        new color values.\n        \n        alpha is not modified\n        \n        name\n        \"\"\"\n        # YOUR CODE HERE\n        self.r = 255 - self.r\n        self.g = 255 - self.g\n        self.b = 255 - self.b\n        return self\n    \n    def grayscale(self): \n        \"\"\"\n        this function converts RGB color to grayscale by using a \n        weight average formula: 0.299Red+0.587Green+0.114Blue\n        \"\"\"\n        # YOUR CODE HERE\n        gray = int((self.r * 0.299) + (self.g * 0.587) + (self.b * 0.114))\n        self.r = gray\n        self.g = gray\n        self.b = gray\n        return self\n        \n    def __str__(self):\n        # YOUR CODE HERE\n        alphas = str(self.alpha)\n        rs = str(self.r).zfill(3)\n        gs = str(self.g).zfill(3)\n        bs = str(self.b).zfill(3)\n        return rs + \" \" + gs + \" \" + bs + \" \" + alphas\n        \n    def __repr__(self):\n        # YOUR CODE HERE\n        return str(type(self)) + self.__str__()\n        \n        \n    def __add__(self,color):\n        # YOUR CODE HERE\n        \"\"\"\n        When adding two rgba instances (e.g. c1 and c2) to create a new rgba instance (e.g. c3), the color channels of c3 should be the sum of the two values mod 256. For example,  c3=(c1.r+c2.r)mod256 .\n        The alpha value should be the maximum of the two alpha values ( c3.alpha=max(c1.alpha,c2.alpha) )\n        \"\"\"\n        r_new = (self.r + color.r) % 256\n        g_new = (self.g + color.g) % 256\n        b_new = (self.b + color.b) % 256\n        alpha_new = max(self.alpha, color.alpha)\n        \n        return rgba(r_new, g_new, b_new, alpha_new)\n        \n    def __eq__(self,color):\n        # YOUR CODE HERE\n        if self.r == color.r and self.g == color.g and self.b == color.b:\n            return True\n        else:\n            return False\n        \n    def __abs__(self):\n        # YOUR CODE HERE\n        return math.sqrt( (self.r**2) + (self.g**2) + (self.b**2) )"}
{"task_id": "DSP/218", "completion": "from collections import namedtuple\nimport math\nrgbalpha = namedtuple(\"rgbalpha\",['r','g','b','alpha'])\nclass rgba(rgbalpha):\n    def __new__(cls, *args, **kwargs):\n        return super().__new__(cls, validate_color(args[0]),\n                          validate_color(args[1]),\n                          validate_color(args[2]),\n                          validate_alpha(args[3]))\n    def __init__(self, *args, name=\"null\"):\n        # YOUR CODE HERE\n        self.r = args[0]\n        self.g = args[1]\n        self.b = args[2]\n        self.alpha = args[3]\n        \n    @property\n    # YOUR CODE HERE\n    def alpha(self):\n        return self.__alpha\n    @alpha.setter\n    # YOUR CODE HERE\n    def alpha(self,alpha):\n        self.__alpha = alpha\n        \n    @property\n    # YOUR CODE HERE\n    def r(self):\n        return self.__r\n    @r.setter\n    # YOUR CODE HERE\n    def r(self,r):\n        self.__r = int(r)\n        \n    @property\n    # YOUR CODE HERE\n    def g(self):\n        return self.__g\n    @g.setter\n    # YOUR CODE HERE\n    def g(self,g):\n        self.__g = int(g)\n      \n    @property\n    # YOUR CODE HERE\n    def b(self):\n        return self.__b\n    @b.setter\n    # YOUR CODE HERE\n    def b(self,b):\n        self.__b = int(b)\n    \n    \n    def invert_rgb(self): \n        \"\"\"\n        this function inverts the RGB color by subtracting \n        all color values from 255 and returns a new rgba object with the \n        new color values.\n        \n        alpha is not modified\n        \n        name\n        \"\"\"\n        # YOUR CODE HERE\n        self.r = 255 - self.r\n        self.g = 255 - self.g\n        self.b = 255 - self.b\n        return self\n    \n    def grayscale(self): \n        \"\"\"\n        this function converts RGB color to grayscale by using a \n        weight average formula: 0.299Red+0.587Green+0.114Blue\n        \"\"\"\n        # YOUR CODE HERE\n        gray = int((self.r * 0.299) + (self.g * 0.587) + (self.b * 0.114))\n        self.r = gray\n        self.g = gray\n        self.b = gray\n        return self\n        \n    def __str__(self):\n        # YOUR CODE HERE\n        alphas = str(self.alpha)\n        rs = str(self.r).zfill(3)\n        gs = str(self.g).zfill(3)\n        bs = str(self.b).zfill(3)\n        return rs + \" \" + gs + \" \" + bs + \" \" + alphas\n        \n    def __repr__(self):\n        # YOUR CODE HERE\n        return str(type(self)) + self.__str__()\n        \n        \n    def __add__(self,color):\n        # YOUR CODE HERE\n        \"\"\"\n        When adding two rgba instances (e.g. c1 and c2) to create a new rgba instance (e.g. c3), the color channels of c3 should be the sum of the two values mod 256. For example,  c3=(c1.r+c2.r)mod256 .\n        The alpha value should be the maximum of the two alpha values ( c3.alpha=max(c1.alpha,c2.alpha) )\n        \"\"\"\n        r_new = (self.r + color.r) % 256\n        g_new = (self.g + color.g) % 256\n        b_new = (self.b + color.b) % 256\n        alpha_new = max(self.alpha, color.alpha)\n        \n        return rgba(r_new, g_new, b_new, alpha_new)\n        \n    def __eq__(self,color):\n        # YOUR CODE HERE\n        if self.r == color.r and self.g == color.g and self.b == color.b:\n            return True\n        else:\n            return False\n        \n    def __abs__(self):\n        # YOUR CODE HERE\n        return math.sqrt( (self.r**2) + (self.g**2) + (self.b**2) )"}
{"task_id": "DSP/219", "completion": "from math import *\n\ndef bmi(h, w):\n    # YOUR CODE HERE\n    bmis = []\n    for x in range(0,len(h)):\n        bmis.append(w[x] / (h[x]*2.54/100.0)**2)\n    \n    bmis = np.array(bmis)\n    \n    return bmis\n    raise NotImplementedError()"}
{"task_id": "DSP/219", "completion": "from math import *\n\ndef bmi(h, w):\n    # YOUR CODE HERE\n    bmis = []\n    for x in range(0,len(h)):\n        bmis.append(w[x] / (h[x]*2.54/100.0)**2)\n    \n    bmis = np.array(bmis)\n    \n    return bmis\n    raise NotImplementedError()"}
{"task_id": "DSP/220", "completion": "import math\n\ndef find_roots(a=1,b=1,c=1):\n    \"\"\"\n    This is a docstring. It is what the help() function returns\n    about this function.\n    \"\"\"\n    # YOUR CODE HERE\n    x = b**2-4*a*c\n    \n    r1 = (-b - math.sqrt(x))/(2*a)\n    r2 = (-b + math.sqrt(x)) /(2*a)\n    \n    return r1, r2\n    \n    raise NotImplementedError()"}
{"task_id": "DSP/220", "completion": "import math\n\ndef find_roots(a=1,b=1,c=1):\n    \"\"\"\n    This is a docstring. It is what the help() function returns\n    about this function.\n    \"\"\"\n    # YOUR CODE HERE\n    x = b**2-4*a*c\n    \n    r1 = (-b - math.sqrt(x))/(2*a)\n    r2 = (-b + math.sqrt(x)) /(2*a)\n    \n    return r1, r2\n    \n    raise NotImplementedError()"}
{"task_id": "DSP/221", "completion": "def age_string(age):\n    decade = None\n    # YOUR CODE HERE\n    age = str(age)\n    if len(age) == 1:\n        decade = 0\n    else:\n        decade = str(age)[0] + \"0\"\n    \n    return \"Age in %ds\"%int(decade)\n    raise NotImplementedError()"}
{"task_id": "DSP/221", "completion": "def age_string(age):\n    decade = None\n    # YOUR CODE HERE\n    age = str(age)\n    if len(age) == 1:\n        decade = 0\n    else:\n        decade = str(age)[0] + \"0\"\n    \n    return \"Age in %ds\"%int(decade)\n    raise NotImplementedError()"}
{"task_id": "DSP/222", "completion": "def hounsfield(I, I0, L):\n    # YOUR CODE HERE\n    mu = -math.log(I / I0) / L\n    print (mu)\n    muwater = 0.1928\n    muair = 0.0002\n    \n    #hu = 1000 * ((mu - muwater) / (muwater - muair))\n    \n    return mu\n    raise NotImplementedError()"}
{"task_id": "DSP/222", "completion": "def hounsfield(I, I0, L):\n    # YOUR CODE HERE\n    mu = -math.log(I / I0) / L\n    print (mu)\n    muwater = 0.1928\n    muair = 0.0002\n    \n    #hu = 1000 * ((mu - muwater) / (muwater - muair))\n    \n    return mu\n    raise NotImplementedError()"}
{"task_id": "DSP/223", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\", header = None, skipinitialspace= True)\n# Giving meaningful column names, as per the `auto_mpg.names` file\nincome_data = income_data.rename(columns={0: \"age\",1: \"workclass\", 2: \"fnlwgt\", 3: \"education\", 4: \"education_num\", 5: \"marital_status\", 6: \"occupation\", 7: \"relationship\", 8: \"race\", 9: \"sex\", 10: \"capital_gain\", 11: \"capital_loss\", 12: \"hours_per_week\", 13:\"native_country\", 14: \"income\"})\n#income_data['income'] = income_data['income'].map({' <=50K': 0, ' >50K': 1}).astype(int) #convert type to int"}
{"task_id": "DSP/223", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\", header = None, skipinitialspace= True)\n# Giving meaningful column names, as per the `auto_mpg.names` file\nincome_data = income_data.rename(columns={0: \"age\",1: \"workclass\", 2: \"fnlwgt\", 3: \"education\", 4: \"education_num\", 5: \"marital_status\", 6: \"occupation\", 7: \"relationship\", 8: \"race\", 9: \"sex\", 10: \"capital_gain\", 11: \"capital_loss\", 12: \"hours_per_week\", 13:\"native_country\", 14: \"income\"})\n#income_data['income'] = income_data['income'].map({' <=50K': 0, ' >50K': 1}).astype(int) #convert type to int"}
{"task_id": "DSP/224", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    highpayed = len(dataframe[dataframe.capital_gain >= threshold_gain]) # put the threshold_gain\n    return highpayed\nhighpayed = get_num_people_with_higher_gain(income_data, 60000)\nprint(highpayed)"}
{"task_id": "DSP/224", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    highpayed = len(dataframe[dataframe.capital_gain >= threshold_gain]) # put the threshold_gain\n    return highpayed\nhighpayed = get_num_people_with_higher_gain(income_data, 60000)\nprint(highpayed)"}
{"task_id": "DSP/225", "completion": "def most_prominent_marital_status(dataframe):\n    status = dataframe['marital_status'].value_counts().sort_index().sort_values(ascending=False).index[0] # get the first row of sorted values for marital status\n    num_people = dataframe['marital_status'].value_counts().sort_index().sort_values(ascending=False).values[0] # get the first row value of sorted values for marital status\n    return status, num_people\nprint(most_prominent_marital_status(income_data))"}
{"task_id": "DSP/225", "completion": "def most_prominent_marital_status(dataframe):\n    status = dataframe['marital_status'].value_counts().sort_index().sort_values(ascending=False).index[0] # get the first row of sorted values for marital status\n    num_people = dataframe['marital_status'].value_counts().sort_index().sort_values(ascending=False).values[0] # get the first row value of sorted values for marital status\n    return status, num_people\nprint(most_prominent_marital_status(income_data))"}
{"task_id": "DSP/226", "completion": "def get_num_people_by_age_category(dataframe):\n    #young, middle_aged, old = (len(dataframe[ dataframe.age <=30]), len(dataframe[(dataframe.age >30) & (dataframe.age <=60)]), len(dataframe[ dataframe.age >60]))\n    young = dataframe['age'][dataframe['age'] <= 30].count()\n    middle_aged = dataframe['age'][(dataframe.age > 30) & (dataframe.age <= 60)].count()\n    #middle_aged = dataframe['age'][(dataframe.age <= 60)].count()\n    old = dataframe['age'][dataframe['age'] > 60].count()\n    return young, middle_aged, old\nprint(get_num_people_by_age_category(income_data))"}
{"task_id": "DSP/226", "completion": "def get_num_people_by_age_category(dataframe):\n    #young, middle_aged, old = (len(dataframe[ dataframe.age <=30]), len(dataframe[(dataframe.age >30) & (dataframe.age <=60)]), len(dataframe[ dataframe.age >60]))\n    young = dataframe['age'][dataframe['age'] <= 30].count()\n    middle_aged = dataframe['age'][(dataframe.age > 30) & (dataframe.age <= 60)].count()\n    #middle_aged = dataframe['age'][(dataframe.age <= 60)].count()\n    old = dataframe['age'][dataframe['age'] > 60].count()\n    return young, middle_aged, old\nprint(get_num_people_by_age_category(income_data))"}
{"task_id": "DSP/227", "completion": "def get_second_highest_num_people(dataframe):\n    num_people = dataframe['native_country'].value_counts().sort_index().sort_values(ascending=False).values[1]# get the second row of sorted values for marital status\n    country = dataframe['native_country'].value_counts().sort_index().sort_values(ascending=False).index[1] # get the second row value of sorted values for marital status\n    return num_people, country\nprint(get_second_highest_num_people(income_data))"}
{"task_id": "DSP/227", "completion": "def get_second_highest_num_people(dataframe):\n    num_people = dataframe['native_country'].value_counts().sort_index().sort_values(ascending=False).values[1]# get the second row of sorted values for marital status\n    country = dataframe['native_country'].value_counts().sort_index().sort_values(ascending=False).index[1] # get the second row value of sorted values for marital status\n    return num_people, country\nprint(get_second_highest_num_people(income_data))"}
{"task_id": "DSP/228", "completion": "def get_mean_working_hours_by_income(dataframe):\n    hours = dataframe.groupby(['occupation'])['hours_per_week'].mean().sort_values(ascending=False) # calculate average values for each occupation\n    return hours\nprint(get_mean_working_hours_by_income(income_data))"}
{"task_id": "DSP/228", "completion": "def get_mean_working_hours_by_income(dataframe):\n    hours = dataframe.groupby(['occupation'])['hours_per_week'].mean().sort_values(ascending=False) # calculate average values for each occupation\n    return hours\nprint(get_mean_working_hours_by_income(income_data))"}
{"task_id": "DSP/229", "completion": "mpg_data = pd.read_fwf(\"http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data\",header = None, \nnames=[\"mpg\",\"cylinders\",\"displacement\",\"horsepower\",\"weight\",\"acceleration\",\"model_year\",\"origin\",\"car_name\"],na_values = [\"?\"])\n\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/229", "completion": "mpg_data = pd.read_fwf(\"http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data\",header = None, \nnames=[\"mpg\",\"cylinders\",\"displacement\",\"horsepower\",\"weight\",\"acceleration\",\"model_year\",\"origin\",\"car_name\"],na_values = [\"?\"])\n\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/230", "completion": "mpg_data['horsepower'] = mpg_data['horsepower'].apply(pd.to_numeric, errors='coerce' )\n#raise NotImplementedError()"}
{"task_id": "DSP/230", "completion": "mpg_data['horsepower'] = mpg_data['horsepower'].apply(pd.to_numeric, errors='coerce' )\n#raise NotImplementedError()"}
{"task_id": "DSP/231", "completion": "mpg_data =mpg_data[pd.notnull(mpg_data['horsepower'])]\n#raise NotImplementedError()"}
{"task_id": "DSP/231", "completion": "mpg_data =mpg_data[pd.notnull(mpg_data['horsepower'])]\n#raise NotImplementedError()"}
{"task_id": "DSP/232", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    selection = dataframe.cylinders.min()\n    car_names = dataframe.loc[dataframe['cylinders'] == selection].car_name\n    # YOUR CODE HERE\n    # raise NotImplementedError()\n    return car_names"}
{"task_id": "DSP/232", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    selection = dataframe.cylinders.min()\n    car_names = dataframe.loc[dataframe['cylinders'] == selection].car_name\n    # YOUR CODE HERE\n    # raise NotImplementedError()\n    return car_names"}
{"task_id": "DSP/233", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return correlation"}
{"task_id": "DSP/233", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return correlation"}
{"task_id": "DSP/234", "completion": "income_data = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',header=None,\n                          na_values=[\"?\"],\n    names=[\"age\",\"working_class\",\"fmlgtw\",\"education\",\"education_num\",\"marital_status\",\"occupation\",\"relationship\"\n                              ,\"race\",\"sex\",\"capital_gain\",\"capital_loss\",\"hours_per_week\",\"native_country\",\"total_income\"]\n                         , skipinitialspace= True)\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/234", "completion": "income_data = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',header=None,\n                          na_values=[\"?\"],\n    names=[\"age\",\"working_class\",\"fmlgtw\",\"education\",\"education_num\",\"marital_status\",\"occupation\",\"relationship\"\n                              ,\"race\",\"sex\",\"capital_gain\",\"capital_loss\",\"hours_per_week\",\"native_country\",\"total_income\"]\n                         , skipinitialspace= True)\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/235", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    # YOUR CODE HERE\n      return  len(dataframe[ dataframe.capital_gain >=threshold_gain])\n    #raise NotImplementedError()"}
{"task_id": "DSP/235", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    # YOUR CODE HERE\n      return  len(dataframe[ dataframe.capital_gain >=threshold_gain])\n    #raise NotImplementedError()"}
{"task_id": "DSP/236", "completion": "def most_prominent_marital_status(dataframe):\n    #status = \"\"\n    #num_people = 0\n    values = dataframe['marital_status'].value_counts().sort_values(ascending=False)\n\n    status =values.index[0]\n    num_people =values[0]\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return (status, num_people)"}
{"task_id": "DSP/236", "completion": "def most_prominent_marital_status(dataframe):\n    #status = \"\"\n    #num_people = 0\n    values = dataframe['marital_status'].value_counts().sort_values(ascending=False)\n\n    status =values.index[0]\n    num_people =values[0]\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return (status, num_people)"}
{"task_id": "DSP/237", "completion": "def get_num_people_by_age_category(dataframe):\n    #young, middle_aged, old = (0, 0, 0)\n    young, middle_aged, old = (len(dataframe[ dataframe.age <=30])\n                           , len(dataframe[(dataframe.age >30) & (dataframe.age <=60)]),\n                           len(dataframe[dataframe.age >60]))\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return young, middle_aged, old"}
{"task_id": "DSP/237", "completion": "def get_num_people_by_age_category(dataframe):\n    #young, middle_aged, old = (0, 0, 0)\n    young, middle_aged, old = (len(dataframe[ dataframe.age <=30])\n                           , len(dataframe[(dataframe.age >30) & (dataframe.age <=60)]),\n                           len(dataframe[dataframe.age >60]))\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return young, middle_aged, old"}
{"task_id": "DSP/238", "completion": "def get_second_highest_num_people(dataframe):\n    #num_people, country = 0, \"\"\n    # YOUR CODE HERE\n    countries=dataframe['native_country'].value_counts().sort_values(ascending=False)\n    num_people,country = countries[1],countries.index[1]\n    #raise NotImplementedError()\n    return num_people, country"}
{"task_id": "DSP/238", "completion": "def get_second_highest_num_people(dataframe):\n    #num_people, country = 0, \"\"\n    # YOUR CODE HERE\n    countries=dataframe['native_country'].value_counts().sort_values(ascending=False)\n    num_people,country = countries[1],countries.index[1]\n    #raise NotImplementedError()\n    return num_people, country"}
{"task_id": "DSP/239", "completion": "def get_mean_working_hours_by_income(dataframe):\n        hours = dataframe.groupby(['occupation'])['hours_per_week'].mean().sort_values(ascending=False)\n        return hours\n   #raise NotImplementedError()"}
{"task_id": "DSP/239", "completion": "def get_mean_working_hours_by_income(dataframe):\n        hours = dataframe.groupby(['occupation'])['hours_per_week'].mean().sort_values(ascending=False)\n        return hours\n   #raise NotImplementedError()"}
{"task_id": "DSP/240", "completion": "income_data =pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',header=None,na_values=[\"?\"],\n    names=[\"age\",\"working_class\",\"fmlgtw\",\"education\",\"education_num\",\"marital_status\",\"occupation\",\"relationship\"\n                              ,\"race\",\"sex\",\"capital_gain\",\"capital_loss\",\"hours_per_week\",\"native_country\",\"total_income\"]\n                        ,sep=\", \")\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/240", "completion": "income_data =pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',header=None,na_values=[\"?\"],\n    names=[\"age\",\"working_class\",\"fmlgtw\",\"education\",\"education_num\",\"marital_status\",\"occupation\",\"relationship\"\n                              ,\"race\",\"sex\",\"capital_gain\",\"capital_loss\",\"hours_per_week\",\"native_country\",\"total_income\"]\n                        ,sep=\", \")\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/241", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n \n        return len(dataframe[ dataframe.capital_gain >=threshold_gain])\n    # raise NotImplementedError()"}
{"task_id": "DSP/241", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n \n        return len(dataframe[ dataframe.capital_gain >=threshold_gain])\n    # raise NotImplementedError()"}
{"task_id": "DSP/242", "completion": "def most_prominent_marital_status(dataframe):\n    \n    values = income_data['marital_status'].value_counts().sort_index().sort_values(ascending=False)\n\n    status =values.index[0]\n    num_people =values[0]\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return (status, num_people)"}
{"task_id": "DSP/242", "completion": "def most_prominent_marital_status(dataframe):\n    \n    values = income_data['marital_status'].value_counts().sort_index().sort_values(ascending=False)\n\n    status =values.index[0]\n    num_people =values[0]\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return (status, num_people)"}
{"task_id": "DSP/243", "completion": "def get_num_people_by_age_category(dataframe):\n    #young, middle_aged, old = (0, 0, 0)\n    # YOUR CODE HERE\n    young, middle_aged, old = (len(dataframe[ dataframe.age <=30])\n                           , len(dataframe[(dataframe.age >30) & (dataframe.age <=60)]),\n                           len(dataframe[dataframe.age >60]))\n    #raise NotImplementedError()\n    return young, middle_aged, old"}
{"task_id": "DSP/243", "completion": "def get_num_people_by_age_category(dataframe):\n    #young, middle_aged, old = (0, 0, 0)\n    # YOUR CODE HERE\n    young, middle_aged, old = (len(dataframe[ dataframe.age <=30])\n                           , len(dataframe[(dataframe.age >30) & (dataframe.age <=60)]),\n                           len(dataframe[dataframe.age >60]))\n    #raise NotImplementedError()\n    return young, middle_aged, old"}
{"task_id": "DSP/244", "completion": "def get_second_highest_num_people(dataframe):\n    countries=dataframe['native_country'].value_counts().sort_values(ascending=False)\n    num_people, country = countries[1],countries.index[1]\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return num_people, country"}
{"task_id": "DSP/244", "completion": "def get_second_highest_num_people(dataframe):\n    countries=dataframe['native_country'].value_counts().sort_values(ascending=False)\n    num_people, country = countries[1],countries.index[1]\n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return num_people, country"}
{"task_id": "DSP/245", "completion": "def get_mean_working_hours_by_income(dataframe):\n    # YOUR CODE HERE\n    return dataframe.groupby(['occupation'])['hours_per_week'].mean().sort_values( ascending=False)\n    #raise NotImplementedError()"}
{"task_id": "DSP/245", "completion": "def get_mean_working_hours_by_income(dataframe):\n    # YOUR CODE HERE\n    return dataframe.groupby(['occupation'])['hours_per_week'].mean().sort_values( ascending=False)\n    #raise NotImplementedError()"}
{"task_id": "DSP/246", "completion": "sequences = {\"seq1\": sequence1, \"seq2\": sequence2, \"seq3\": sequence3}"}
{"task_id": "DSP/246", "completion": "sequences = {\"seq1\": sequence1, \"seq2\": sequence2, \"seq3\": sequence3}"}
{"task_id": "DSP/247", "completion": "def bootstrap(x, y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    x: ndarray\n        Input x array.\n    y: ndarray\n        Input y array.\n    \n    Returns\n    -------\n    xx: ndarray\n        The boostrapped x array with the same shape as x and correlated random samples\n        drawn with replacement.\n    yy: ndarray\n        The bootstrapped y array with the same shape as y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    idx = np.random.choice(x.size, size=x.size, replace=True)\n    return x[idx], y[idx]"}
{"task_id": "DSP/247", "completion": "def bootstrap(x, y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    x: ndarray\n        Input x array.\n    y: ndarray\n        Input y array.\n    \n    Returns\n    -------\n    xx: ndarray\n        The boostrapped x array with the same shape as x and correlated random samples\n        drawn with replacement.\n    yy: ndarray\n        The bootstrapped y array with the same shape as y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    idx = np.random.choice(x.size, size=x.size, replace=True)\n    return x[idx], y[idx]"}
{"task_id": "DSP/248", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/248", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/249", "completion": "numeric_features = ['pclass', 'age', 'sibsp', 'parch', 'fare', 'alone', 'child']\nX = raw_data.loc[:, numeric_features]"}
{"task_id": "DSP/249", "completion": "numeric_features = ['pclass', 'age', 'sibsp', 'parch', 'fare', 'alone', 'child']\nX = raw_data.loc[:, numeric_features]"}
{"task_id": "DSP/250", "completion": "y = raw_data.survived"}
{"task_id": "DSP/250", "completion": "y = raw_data.survived"}
{"task_id": "DSP/251", "completion": "from sklearn.model_selection import train_test_split\n\nXtrain, Xtest, ytrain, ytest = train_test_split(X, y, train_size=0.70, random_state=0)"}
{"task_id": "DSP/251", "completion": "from sklearn.model_selection import train_test_split\n\nXtrain, Xtest, ytrain, ytest = train_test_split(X, y, train_size=0.70, random_state=0)"}
{"task_id": "DSP/252", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', delimiter=',', dtype=np.float64)"}
{"task_id": "DSP/252", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', delimiter=',', dtype=np.float64)"}
{"task_id": "DSP/253", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    return sorted(x) == sorted(y)"}
{"task_id": "DSP/253", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    return sorted(x) == sorted(y)"}
{"task_id": "DSP/254", "completion": "g1 = titanic.groupby(['sex']).aggregate({'age': pd.DataFrame.mean})"}
{"task_id": "DSP/254", "completion": "g1 = titanic.groupby(['sex']).aggregate({'age': pd.DataFrame.mean})"}
{"task_id": "DSP/255", "completion": "(t, W) = wiener(1.0, 1000)\nprint(len(t), len(W))"}
{"task_id": "DSP/255", "completion": "(t, W) = wiener(1.0, 1000)\nprint(len(t), len(W))"}
{"task_id": "DSP/256", "completion": "def find_peaks(a):\n    \"\"\"Find the indices of the local maxima in a sequence.\"\"\"\n    a_diff = np.full(len(a), np.inf)\n    a_rev_diff = np.full(len(a), np.inf)\n    \n    for index in range(len(a) - 1):\n        a_diff[index] = a[index] - a[index + 1]\n        a_rev_diff[index + 1] = a[index + 1] - a[index]\n\n    indices = np.where(np.logical_and(a_diff > 0, a_rev_diff > 0))[0]\n    return indices"}
{"task_id": "DSP/256", "completion": "def find_peaks(a):\n    \"\"\"Find the indices of the local maxima in a sequence.\"\"\"\n    a_diff = np.full(len(a), np.inf)\n    a_rev_diff = np.full(len(a), np.inf)\n    \n    for index in range(len(a) - 1):\n        a_diff[index] = a[index] - a[index + 1]\n        a_rev_diff[index + 1] = a[index + 1] - a[index]\n\n    indices = np.where(np.logical_and(a_diff > 0, a_rev_diff > 0))[0]\n    return indices"}
{"task_id": "DSP/257", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    assert len(x) == len(y)\n    return [pair[0] + pair[1] for pair in zip(x, y)]"}
{"task_id": "DSP/257", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    assert len(x) == len(y)\n    return [pair[0] + pair[1] for pair in zip(x, y)]"}
{"task_id": "DSP/258", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    assert len(x) == len(y)\n    return [pair[0] - pair[1] for pair in zip(x, y)]"}
{"task_id": "DSP/258", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    assert len(x) == len(y)\n    return [pair[0] - pair[1] for pair in zip(x, y)]"}
{"task_id": "DSP/259", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    return [a * elem for elem in x]"}
{"task_id": "DSP/259", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    return [a * elem for elem in x]"}
{"task_id": "DSP/260", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    assert len(x) == len(y)\n    return sum([pair[0] * pair[1] for pair in zip(x, y)])"}
{"task_id": "DSP/260", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    assert len(x) == len(y)\n    return sum([pair[0] * pair[1] for pair in zip(x, y)])"}
{"task_id": "DSP/261", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    return sum([abs(elem) for elem in x])"}
{"task_id": "DSP/261", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    return sum([abs(elem) for elem in x])"}
{"task_id": "DSP/262", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    return math.sqrt(sum([elem ** 2 for elem in x]))"}
{"task_id": "DSP/262", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    return math.sqrt(sum([elem ** 2 for elem in x]))"}
{"task_id": "DSP/263", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    assert len(x) == len(y)\n    return sum([elem ** 2 for elem in vector_diff(x, y)]) / len(x)"}
{"task_id": "DSP/263", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    assert len(x) == len(y)\n    return sum([elem ** 2 for elem in vector_diff(x, y)]) / len(x)"}
{"task_id": "DSP/264", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    return sum(x) / len(x)"}
{"task_id": "DSP/264", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    return sum(x) / len(x)"}
{"task_id": "DSP/265", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    m = mean(x)\n    return sum([(elem - m) ** 2 for elem in x]) / len(x)"}
{"task_id": "DSP/265", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    m = mean(x)\n    return sum([(elem - m) ** 2 for elem in x]) / len(x)"}
{"task_id": "DSP/266", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/266", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/267", "completion": "np.random.seed(0) # keep this line to reset the random number generator\n\nsim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/267", "completion": "np.random.seed(0) # keep this line to reset the random number generator\n\nsim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/268", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/268", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/269", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = np.sqrt(3 * sigma ** 2)\n    a = mu - d\n    b = mu + d\n    return np.random.uniform(a, b, size=size)"}
{"task_id": "DSP/269", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = np.sqrt(3 * sigma ** 2)\n    a = mu - d\n    b = mu + d\n    return np.random.uniform(a, b, size=size)"}
{"task_id": "DSP/270", "completion": "data = None\nwith open('speed_of_light.txt', 'r') as speed_file:\n    data_list = []\n    for line in speed_file:\n        for string_time in line.split(\" \"):\n            data_list.append({'raw': int(string_time)})\n    data = pd.DataFrame.from_records(data_list)"}
{"task_id": "DSP/270", "completion": "data = None\nwith open('speed_of_light.txt', 'r') as speed_file:\n    data_list = []\n    for line in speed_file:\n        for string_time in line.split(\" \"):\n            data_list.append({'raw': int(string_time)})\n    data = pd.DataFrame.from_records(data_list)"}
{"task_id": "DSP/271", "completion": "data['time'] = data['raw'] + offset\ndata['speed'] = distance / data['time']"}
{"task_id": "DSP/271", "completion": "data['time'] = data['raw'] + offset\ndata['speed'] = distance / data['time']"}
{"task_id": "DSP/272", "completion": "df.state = df.state.where(df.state != '', None)"}
{"task_id": "DSP/272", "completion": "df.state = df.state.where(df.state != '', None)"}
{"task_id": "DSP/273", "completion": "df2 = df.dropna(how='any')"}
{"task_id": "DSP/273", "completion": "df2 = df.dropna(how='any')"}
{"task_id": "DSP/274", "completion": "df3 = df.dropna(how='all')"}
{"task_id": "DSP/274", "completion": "df3 = df.dropna(how='all')"}
{"task_id": "DSP/275", "completion": "df4 = df.loc[:, df.count() >= 7]"}
{"task_id": "DSP/275", "completion": "df4 = df.loc[:, df.count() >= 7]"}
{"task_id": "DSP/276", "completion": "df5 = df.select_dtypes(include=[np.number]).fillna(value=-9)"}
{"task_id": "DSP/276", "completion": "df5 = df.select_dtypes(include=[np.number]).fillna(value=-9)"}
{"task_id": "DSP/277", "completion": "def count_null(column):\n    \"\"\"Count the number of missing values in a column (Series).\"\"\"\n    return column.isnull().sum()"}
{"task_id": "DSP/277", "completion": "def count_null(column):\n    \"\"\"Count the number of missing values in a column (Series).\"\"\"\n    return column.isnull().sum()"}
{"task_id": "DSP/278", "completion": "ce = create_engine('sqlite:///data/Chinook_Sqlite.sqlite')"}
{"task_id": "DSP/278", "completion": "ce = create_engine('sqlite:///data/Chinook_Sqlite.sqlite')"}
{"task_id": "DSP/279", "completion": "inspector = inspect(ce)"}
{"task_id": "DSP/279", "completion": "inspector = inspect(ce)"}
{"task_id": "DSP/280", "completion": "def soliton(x, t, c, a):\n    \"\"\"Return phi(x, t) for a soliton wave with constants c and a.\"\"\"\n    return (1 / 2) * c * (1 / np.power(np.cosh((np.sqrt(c) / 2) * (x - c * t - a)), 2))"}
{"task_id": "DSP/280", "completion": "def soliton(x, t, c, a):\n    \"\"\"Return phi(x, t) for a soliton wave with constants c and a.\"\"\"\n    return (1 / 2) * c * (1 / np.power(np.cosh((np.sqrt(c) / 2) * (x - c * t - a)), 2))"}
{"task_id": "DSP/281", "completion": "X, T = np.meshgrid(x, t, indexing='ij')\nphi = soliton(X, T, c, a)"}
{"task_id": "DSP/281", "completion": "X, T = np.meshgrid(x, t, indexing='ij')\nphi = soliton(X, T, c, a)"}
{"task_id": "DSP/282", "completion": "def add_1(x):\n    return x+1\ndef incr_list_by_1(x):\n    return[add_1(i) for i in x]"}
{"task_id": "DSP/282", "completion": "def add_1(x):\n    return x+1\ndef incr_list_by_1(x):\n    return[add_1(i) for i in x]"}
{"task_id": "DSP/283", "completion": "def generate(n, seed):\n    \"\"\"Generate a dataset with two dependent but uncorrelated features.\n    \n    Parameters\n    ----------\n    n : int\n        Number of samples to generate.\n    seed : int\n        Seed to use for reproducible random numbers.\n        \n    Returns\n    -------\n    tuple\n        Tuple (X, rho) of generated data X with shape (n, 2) and the\n        correlation coefficient rho of the generated data.\n    \"\"\"\n    gen = np.random.RandomState(seed=seed)\n    x1 = gen.uniform(-1,1,n)\n    x2 = abs(x1)\n    X = np.vstack((x1,x2))\n    print(np.corrcoef(X))\n    return (X.T,np.corrcoef(X)[0,1])\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/283", "completion": "def generate(n, seed):\n    \"\"\"Generate a dataset with two dependent but uncorrelated features.\n    \n    Parameters\n    ----------\n    n : int\n        Number of samples to generate.\n    seed : int\n        Seed to use for reproducible random numbers.\n        \n    Returns\n    -------\n    tuple\n        Tuple (X, rho) of generated data X with shape (n, 2) and the\n        correlation coefficient rho of the generated data.\n    \"\"\"\n    gen = np.random.RandomState(seed=seed)\n    x1 = gen.uniform(-1,1,n)\n    x2 = abs(x1)\n    X = np.vstack((x1,x2))\n    print(np.corrcoef(X))\n    return (X.T,np.corrcoef(X)[0,1])\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/284", "completion": "def metropolis_update(x, y, s, gen, sigma=1):\n    \"\"\"Perform a single Metropolis update.\n    \n    Parameters\n    ----------\n    x : float\n        Value of x from the previous step.\n    y : float\n        Value of y from the previous step.\n    s : float\n        Value of the hyperparameter s.\n    gen : np.random.RandomState\n        Random state to use for reproducible random samples.\n    sigma : float\n        Standard deviation of the Gaussian proposal distribution Q(x,y).\n        \n    Returns\n    -------\n    tuple\n        Tuple (x,y) of the position after the update.\n\n    \"\"\"\n    C = [[sigma,0],[0,sigma]]\n    x0 = [x,y]\n    diff = gen.multivariate_normal([0,0],C)\n    x1 = x0+diff\n    log_ratio = np.log(P(x1[0],x1[1],s)) - np.log(P(x0[0],x0[1],s)) \n    if log_ratio >= 0:\n            return x1\n    else:\n            accept_prob = np.exp(log_ratio)\n            return x1 if gen.uniform() < accept_prob else x0\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/284", "completion": "def metropolis_update(x, y, s, gen, sigma=1):\n    \"\"\"Perform a single Metropolis update.\n    \n    Parameters\n    ----------\n    x : float\n        Value of x from the previous step.\n    y : float\n        Value of y from the previous step.\n    s : float\n        Value of the hyperparameter s.\n    gen : np.random.RandomState\n        Random state to use for reproducible random samples.\n    sigma : float\n        Standard deviation of the Gaussian proposal distribution Q(x,y).\n        \n    Returns\n    -------\n    tuple\n        Tuple (x,y) of the position after the update.\n\n    \"\"\"\n    C = [[sigma,0],[0,sigma]]\n    x0 = [x,y]\n    diff = gen.multivariate_normal([0,0],C)\n    x1 = x0+diff\n    log_ratio = np.log(P(x1[0],x1[1],s)) - np.log(P(x0[0],x0[1],s)) \n    if log_ratio >= 0:\n            return x1\n    else:\n            accept_prob = np.exp(log_ratio)\n            return x1 if gen.uniform() < accept_prob else x0\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/285", "completion": "def sample_conditional(y, s, gen):\n    \"\"\"Sample from the conditional distribution P(x | y).\n    \n    Parameters\n    ----------\n    y : float\n        Fixed value of y to use.\n    s : float\n        Value of the hyperparameter s.\n    gen : np.random.RandomState\n        Random state to use for reproducible random samples.\n        \n    Returns\n    -------\n    float\n        Random value of x sampled from P(x | y).\n    \"\"\"\n    w1 = np.exp(-0.5*(y*s)**2)\n    w2 = np.exp(-0.5*(y/s)**2)\n    accept_prob = w2/(w1+w2)\n    if gen.uniform() < accept_prob:\n        x = gen.normal(0,1/s)\n    else:\n        x = gen.normal(0,s)\n    return x \n        \n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/285", "completion": "def sample_conditional(y, s, gen):\n    \"\"\"Sample from the conditional distribution P(x | y).\n    \n    Parameters\n    ----------\n    y : float\n        Fixed value of y to use.\n    s : float\n        Value of the hyperparameter s.\n    gen : np.random.RandomState\n        Random state to use for reproducible random samples.\n        \n    Returns\n    -------\n    float\n        Random value of x sampled from P(x | y).\n    \"\"\"\n    w1 = np.exp(-0.5*(y*s)**2)\n    w2 = np.exp(-0.5*(y/s)**2)\n    accept_prob = w2/(w1+w2)\n    if gen.uniform() < accept_prob:\n        x = gen.normal(0,1/s)\n    else:\n        x = gen.normal(0,s)\n    return x \n        \n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/286", "completion": "def gibbs_update(x, y, s, gen):\n    \"\"\"Perform a single Gibbs update.\n    \n    Parameters\n    ----------\n    x : float\n        Value of x from the previous step.\n    y : float\n        Value of y from the previous step.\n    s : float\n        Value of the hyperparameter s.\n    gen : np.random.RandomState\n        Random state to use for reproducible random samples.\n        \n    Returns\n    -------\n    tuple\n        Tuple (x,y) of the position after the update.\n    \"\"\"\n    xnew = sample_conditional(y,s,gen)\n    ynew = sample_conditional(xnew,s,gen)\n    return (xnew,ynew)\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/286", "completion": "def gibbs_update(x, y, s, gen):\n    \"\"\"Perform a single Gibbs update.\n    \n    Parameters\n    ----------\n    x : float\n        Value of x from the previous step.\n    y : float\n        Value of y from the previous step.\n    s : float\n        Value of the hyperparameter s.\n    gen : np.random.RandomState\n        Random state to use for reproducible random samples.\n        \n    Returns\n    -------\n    tuple\n        Tuple (x,y) of the position after the update.\n    \"\"\"\n    xnew = sample_conditional(y,s,gen)\n    ynew = sample_conditional(xnew,s,gen)\n    return (xnew,ynew)\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/287", "completion": "def HMC_step(x, y, px, py, s, dt):\n    \"\"\"Perform a single HMC dt step.\n    \n    Parameters\n    ----------\n    x : float\n        Current x position.\n    y : float\n        Current y position.\n    px : float\n        Current x momentum.\n    py : float\n        Current y momentum.\n    s : float\n        Value of the hyperparameter s.\n    dt : float\n        Step size to take.\n        \n    Returns\n    -------\n    tuple\n        Tuple (x, y, px, py) with particle position and momentum after this step.\n    \"\"\"\n    def E1(x,y,s):\n        return 0.5 * (np.exp(-0.5 * ((x / s) ** 2 + (y * s) ** 2)))\n    def E2(x,y,s):\n        return 0.5 * (np.exp(-0.5 * ((x * s) ** 2 + (y / s) ** 2)))\n    def dUdx(x,y,s):\n        return x*(E1(x,y,s)/s**2 + E2(x,y,s)*s**2)/(E1(x,y,s)+E2(x,y,s))\n    def dUdy(d,y,s):\n        return y*(E1(x,y,s)*s**2 + E2(x,y,s)/s**2)/(E1(x,y,s)+E2(x,y,s))\n\n    xnew = x + px*dt\n    ynew = y + py*dt\n    pxnew = px - dUdx(x,y,s)*dt\n    pynew = py - dUdy(x,y,s)*dt\n    return (xnew,ynew,pxnew,pynew)\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/287", "completion": "def HMC_step(x, y, px, py, s, dt):\n    \"\"\"Perform a single HMC dt step.\n    \n    Parameters\n    ----------\n    x : float\n        Current x position.\n    y : float\n        Current y position.\n    px : float\n        Current x momentum.\n    py : float\n        Current y momentum.\n    s : float\n        Value of the hyperparameter s.\n    dt : float\n        Step size to take.\n        \n    Returns\n    -------\n    tuple\n        Tuple (x, y, px, py) with particle position and momentum after this step.\n    \"\"\"\n    def E1(x,y,s):\n        return 0.5 * (np.exp(-0.5 * ((x / s) ** 2 + (y * s) ** 2)))\n    def E2(x,y,s):\n        return 0.5 * (np.exp(-0.5 * ((x * s) ** 2 + (y / s) ** 2)))\n    def dUdx(x,y,s):\n        return x*(E1(x,y,s)/s**2 + E2(x,y,s)*s**2)/(E1(x,y,s)+E2(x,y,s))\n    def dUdy(d,y,s):\n        return y*(E1(x,y,s)*s**2 + E2(x,y,s)/s**2)/(E1(x,y,s)+E2(x,y,s))\n\n    xnew = x + px*dt\n    ynew = y + py*dt\n    pxnew = px - dUdx(x,y,s)*dt\n    pynew = py - dUdy(x,y,s)*dt\n    return (xnew,ynew,pxnew,pynew)\n    # YOUR CODE HERE\n    raise NotImplementedError()"}
{"task_id": "DSP/288", "completion": "def rmse(observed,predicted):\n    '''Compute the root mean squared error between the two lists of samples: observed and predicted.'''\n    ### BEGIN SOLUTION\n    return np.sqrt(((observed-predicted)**2).mean())\n    ### END SOLUTION\n\n# test \nrmse(observed,predicted)"}
{"task_id": "DSP/288", "completion": "def rmse(observed,predicted):\n    '''Compute the root mean squared error between the two lists of samples: observed and predicted.'''\n    ### BEGIN SOLUTION\n    return np.sqrt(((observed-predicted)**2).mean())\n    ### END SOLUTION\n\n# test \nrmse(observed,predicted)"}
{"task_id": "DSP/289", "completion": "Rmse = None # replace with your answer\nRmse\n### BEGIN SOLUTION\nRmse = np.sqrt(((observed-predicted)**2).mean())\n### END SOLUTION"}
{"task_id": "DSP/289", "completion": "Rmse = None # replace with your answer\nRmse\n### BEGIN SOLUTION\nRmse = np.sqrt(((observed-predicted)**2).mean())\n### END SOLUTION"}
{"task_id": "DSP/290", "completion": "answer= None # replace with your answer\nanswer\n### BEGIN SOLUTION\n \nanswer =round(np.sqrt(((observed-predicted)**2).mean()),2)\n### END SOLUTION"}
{"task_id": "DSP/290", "completion": "answer= None # replace with your answer\nanswer\n### BEGIN SOLUTION\n \nanswer =round(np.sqrt(((observed-predicted)**2).mean()),2)\n### END SOLUTION"}
{"task_id": "DSP/291", "completion": "def intro_dictionary(name, hometown, department, status, years):\n    \"\"\"Returns a dictionary containing key/value pairs.\n    \n    Parameters\n    ----------\n    name : string\n        Your name\n    hometown : string\n        Where are you from?\n    department : string\n        What department are you in?\n    status : string\n        Are you an undergrad or graduate student?\n    years : float\n        How many years have you been at TAMU?\n        \n    Returns\n    -------\n    dictionary containing the input information\n    \n    \"\"\"\n    # YOUR CODE HERE\n    return {'name': name, 'hometown': hometown,'department':department,'status':status,'years':years}   \nintro_dictionary('Xiao', 'Xiangyang', 'Oceanography', 'Graduate', 1)"}
{"task_id": "DSP/291", "completion": "def intro_dictionary(name, hometown, department, status, years):\n    \"\"\"Returns a dictionary containing key/value pairs.\n    \n    Parameters\n    ----------\n    name : string\n        Your name\n    hometown : string\n        Where are you from?\n    department : string\n        What department are you in?\n    status : string\n        Are you an undergrad or graduate student?\n    years : float\n        How many years have you been at TAMU?\n        \n    Returns\n    -------\n    dictionary containing the input information\n    \n    \"\"\"\n    # YOUR CODE HERE\n    return {'name': name, 'hometown': hometown,'department':department,'status':status,'years':years}   \nintro_dictionary('Xiao', 'Xiangyang', 'Oceanography', 'Graduate', 1)"}
{"task_id": "DSP/292", "completion": "def isVowel(char):\n    \"\"\"Takes a character and returns True if it is a vowel, and False otherwise.\n    \n    Parameters\n    ----------\n    char : string\n        string of length 1\n        \n    Returns\n    -------\n    boolean telling whether char is a vowel or not\n    \n    \"\"\"\n    # YOUR CODE HERE\n    return any(char.lower()  == c for c in 'aeiou')"}
{"task_id": "DSP/292", "completion": "def isVowel(char):\n    \"\"\"Takes a character and returns True if it is a vowel, and False otherwise.\n    \n    Parameters\n    ----------\n    char : string\n        string of length 1\n        \n    Returns\n    -------\n    boolean telling whether char is a vowel or not\n    \n    \"\"\"\n    # YOUR CODE HERE\n    return any(char.lower()  == c for c in 'aeiou')"}
{"task_id": "DSP/293", "completion": "def reverse(string):\n    \"\"\"Reverse string and then return in.\n    \n    Parameters\n    ----------\n    string : str\n        \n        \n    Returns\n    -------\n    string that is reversed\n    \"\"\"\n    # YOUR CODE HERE\n    return string[::-1]"}
{"task_id": "DSP/293", "completion": "def reverse(string):\n    \"\"\"Reverse string and then return in.\n    \n    Parameters\n    ----------\n    string : str\n        \n        \n    Returns\n    -------\n    string that is reversed\n    \"\"\"\n    # YOUR CODE HERE\n    return string[::-1]"}
{"task_id": "DSP/294", "completion": "def length(inputs):\n    \"\"\"Compute the length of a given list or string.\n    \n    Parameters\n    ----------\n    inputs : string or list\n        \n        \n    Returns\n    -------\n    integer that is either the number of characters in the input string or the number of \n    entries in the input list.\n    \"\"\"\n    # YOUR CODE HERE\n    \n    if inputs.count(inputs[-1]) > 1:\n        return inputs.rindex(inputs[-1])+1\n    else:\n        return inputs.index(inputs[-1])+1"}
{"task_id": "DSP/294", "completion": "def length(inputs):\n    \"\"\"Compute the length of a given list or string.\n    \n    Parameters\n    ----------\n    inputs : string or list\n        \n        \n    Returns\n    -------\n    integer that is either the number of characters in the input string or the number of \n    entries in the input list.\n    \"\"\"\n    # YOUR CODE HERE\n    \n    if inputs.count(inputs[-1]) > 1:\n        return inputs.rindex(inputs[-1])+1\n    else:\n        return inputs.index(inputs[-1])+1"}
{"task_id": "DSP/295", "completion": "def is_palindrome(phrase):\n    \"\"\"Returns True for a palindrome and False otherwise.\n    \n    Parameters\n    ----------\n    phrase : string\n        \n        \n    Returns\n    -------\n    Boolean\n    \"\"\"\n    # YOUR CODE HERE\n    phrasenew=phrase.replace(\" \",\"\").lower()\n    return phrasenew[::-1]==phrasenew"}
{"task_id": "DSP/295", "completion": "def is_palindrome(phrase):\n    \"\"\"Returns True for a palindrome and False otherwise.\n    \n    Parameters\n    ----------\n    phrase : string\n        \n        \n    Returns\n    -------\n    Boolean\n    \"\"\"\n    # YOUR CODE HERE\n    phrasenew=phrase.replace(\" \",\"\").lower()\n    return phrasenew[::-1]==phrasenew"}
{"task_id": "DSP/296", "completion": "key = {'a':'n', 'b':'o', 'c':'p', 'd':'q', 'e':'r', 'f':'s', 'g':'t', 'h':'u', \n       'i':'v', 'j':'w', 'k':'x', 'l':'y', 'm':'z', 'n':'a', 'o':'b', 'p':'c', \n       'q':'d', 'r':'e', 's':'f', 't':'g', 'u':'h', 'v':'i', 'w':'j', 'x':'k',\n       'y':'l', 'z':'m', 'A':'N', 'B':'O', 'C':'P', 'D':'Q', 'E':'R', 'F':'S', \n       'G':'T', 'H':'U', 'I':'V', 'J':'W', 'K':'X', 'L':'Y', 'M':'Z', 'N':'A', \n       'O':'B', 'P':'C', 'Q':'D', 'R':'E', 'S':'F', 'T':'G', 'U':'H', 'V':'I', \n       'W':'J', 'X':'K', 'Y':'L', 'Z':'M'}\n\ndef rot13(letter):\n    \"\"\"Swap letter indicated in key.\n    \n    Parameters\n    ----------\n    letter : string of length 1\n        letter to be swapped using the key dictionary\n        \n    Returns\n    -------\n    letter\n    \"\"\"\n    # YOUR CODE HERE\n    keydecode=''\n    for i in letter:\n        if i.islower():\n            keydecode+=key.get(i) \n        if i.isupper():\n            i=i.lower()\n            keydecode+=key.get(i).capitalize()\n        if i not in key:\n            keydecode+=i\n        \n    \n    return keydecode"}
{"task_id": "DSP/296", "completion": "key = {'a':'n', 'b':'o', 'c':'p', 'd':'q', 'e':'r', 'f':'s', 'g':'t', 'h':'u', \n       'i':'v', 'j':'w', 'k':'x', 'l':'y', 'm':'z', 'n':'a', 'o':'b', 'p':'c', \n       'q':'d', 'r':'e', 's':'f', 't':'g', 'u':'h', 'v':'i', 'w':'j', 'x':'k',\n       'y':'l', 'z':'m', 'A':'N', 'B':'O', 'C':'P', 'D':'Q', 'E':'R', 'F':'S', \n       'G':'T', 'H':'U', 'I':'V', 'J':'W', 'K':'X', 'L':'Y', 'M':'Z', 'N':'A', \n       'O':'B', 'P':'C', 'Q':'D', 'R':'E', 'S':'F', 'T':'G', 'U':'H', 'V':'I', \n       'W':'J', 'X':'K', 'Y':'L', 'Z':'M'}\n\ndef rot13(letter):\n    \"\"\"Swap letter indicated in key.\n    \n    Parameters\n    ----------\n    letter : string of length 1\n        letter to be swapped using the key dictionary\n        \n    Returns\n    -------\n    letter\n    \"\"\"\n    # YOUR CODE HERE\n    keydecode=''\n    for i in letter:\n        if i.islower():\n            keydecode+=key.get(i) \n        if i.isupper():\n            i=i.lower()\n            keydecode+=key.get(i).capitalize()\n        if i not in key:\n            keydecode+=i\n        \n    \n    return keydecode"}
{"task_id": "DSP/297", "completion": "def words(num):\n    \"\"\"Returns words with proper number of beer bottles filled in.\"\"\"\n    \n    if num != 1:\n        return str(num) + ' bottles of beer on the wall, ' + str(num) + ' bottles of beer.\\n' + \\\n            'Take one down, pass it around, ' + str(num-1) + ' bottles of beer on the wall.\\n\\n'\n\n    elif num == 1:\n        return str(num) + ' bottle of beer on the wall, ' + str(num) + ' bottle of beer.\\n' + \\\n            'Take one down, pass it around, ' + str(num-1) + ' bottles of beer on the wall.'\n        \ndef connect_words(numbottles):\n    \n    listofwords = []\n    for i in range(numbottles, 0, -1):\n        listofwords.append(words(i))\n    \n    return listofwords\n    \n# YOUR CODE HERE"}
{"task_id": "DSP/297", "completion": "def words(num):\n    \"\"\"Returns words with proper number of beer bottles filled in.\"\"\"\n    \n    if num != 1:\n        return str(num) + ' bottles of beer on the wall, ' + str(num) + ' bottles of beer.\\n' + \\\n            'Take one down, pass it around, ' + str(num-1) + ' bottles of beer on the wall.\\n\\n'\n\n    elif num == 1:\n        return str(num) + ' bottle of beer on the wall, ' + str(num) + ' bottle of beer.\\n' + \\\n            'Take one down, pass it around, ' + str(num-1) + ' bottles of beer on the wall.'\n        \ndef connect_words(numbottles):\n    \n    listofwords = []\n    for i in range(numbottles, 0, -1):\n        listofwords.append(words(i))\n    \n    return listofwords\n    \n# YOUR CODE HERE"}
{"task_id": "DSP/298", "completion": "def vector_manipulation():\n    \"\"\"Returns a vector of zeros of size 10 but with the fifth value as 1.\n    \"\"\"\n    # YOUR CODE HERE\n    z=np.zeros(10)\n    z[4]=1\n    return z"}
{"task_id": "DSP/298", "completion": "def vector_manipulation():\n    \"\"\"Returns a vector of zeros of size 10 but with the fifth value as 1.\n    \"\"\"\n    # YOUR CODE HERE\n    z=np.zeros(10)\n    z[4]=1\n    return z"}
{"task_id": "DSP/299", "completion": "def vector_range():\n    \"\"\"Returns a vector with values ranging from 10 to 49, inclusive.\n    \"\"\"\n    # YOUR CODE HERE\n    return np.arange(10,50)"}
{"task_id": "DSP/299", "completion": "def vector_range():\n    \"\"\"Returns a vector with values ranging from 10 to 49, inclusive.\n    \"\"\"\n    # YOUR CODE HERE\n    return np.arange(10,50)"}
{"task_id": "DSP/300", "completion": "def arg_nonzero(x):\n    \"\"\"return the indices of non-zero elements of an array.\n\n    Inputs:\n        x:  array\n    \n    Returns:\n        indices: array of integer indices\n    \"\"\"\n    # YOUR CODE HERE\n    return np.where(x != 0)[0]"}
{"task_id": "DSP/300", "completion": "def arg_nonzero(x):\n    \"\"\"return the indices of non-zero elements of an array.\n\n    Inputs:\n        x:  array\n    \n    Returns:\n        indices: array of integer indices\n    \"\"\"\n    # YOUR CODE HERE\n    return np.where(x != 0)[0]"}
{"task_id": "DSP/301", "completion": "def return_nonzero(x, ind):\n    \"\"\"return the indices of non-zero elements of an array.\n\n    Inputs:\n        x:  array\n        output: results from call to find_nonzero(x)\n    \n    Returns:\n        indices of non-zero element in x\n    \"\"\"\n    # YOUR CODE HERE\n#     for id in ind():\n#         x2 = np.array([x[id]])\n\n    return np.array([x[id] for id in ind])"}
{"task_id": "DSP/301", "completion": "def return_nonzero(x, ind):\n    \"\"\"return the indices of non-zero elements of an array.\n\n    Inputs:\n        x:  array\n        output: results from call to find_nonzero(x)\n    \n    Returns:\n        indices of non-zero element in x\n    \"\"\"\n    # YOUR CODE HERE\n#     for id in ind():\n#         x2 = np.array([x[id]])\n\n    return np.array([x[id] for id in ind])"}
{"task_id": "DSP/302", "completion": "def maxesmins(K):\n    \"\"\"Returns the min of the 2nd row and max of the 4th column.\n\n    Parameters\n    ----------\n    K : numpy array\n        \n    Returns\n    -------\n    min of the 2nd row and max of the 4th column, as a tuple, or a nan for either if the array is too small to calculate it\n    \"\"\"\n    # YOUR CODE HERE\n    z=[np.nan,np.nan]\n    if K[:,0].size>=2:\n        z[0]=K[1,:].min()\n    if K[0,:].size>=4: \n        z[1]=K[:,3].max()\n    return tuple(z)\n# if it's a  three dimension?"}
{"task_id": "DSP/302", "completion": "def maxesmins(K):\n    \"\"\"Returns the min of the 2nd row and max of the 4th column.\n\n    Parameters\n    ----------\n    K : numpy array\n        \n    Returns\n    -------\n    min of the 2nd row and max of the 4th column, as a tuple, or a nan for either if the array is too small to calculate it\n    \"\"\"\n    # YOUR CODE HERE\n    z=[np.nan,np.nan]\n    if K[:,0].size>=2:\n        z[0]=K[1,:].min()\n    if K[0,:].size>=4: \n        z[1]=K[:,3].max()\n    return tuple(z)\n# if it's a  three dimension?"}
{"task_id": "DSP/303", "completion": "def sorted_array():\n    \"\"\"Creates, sorts, and returns a vector of size 10 filled with random numbers\n    \"\"\"\n    # YOUR CODE HERE\n    a=np.random.rand(10)\n    return np.sort(a)"}
{"task_id": "DSP/303", "completion": "def sorted_array():\n    \"\"\"Creates, sorts, and returns a vector of size 10 filled with random numbers\n    \"\"\"\n    # YOUR CODE HERE\n    a=np.random.rand(10)\n    return np.sort(a)"}
{"task_id": "DSP/304", "completion": "collisions_subset = collisions.loc[:, ['DATETIME', 'TIME', 'START', 'END', 'DATE', 'LATITUDE', 'LONGITUDE', 'SEVERITY']]\n\ncollisions_subset.head(5)"}
{"task_id": "DSP/304", "completion": "collisions_subset = collisions.loc[:, ['DATETIME', 'TIME', 'START', 'END', 'DATE', 'LATITUDE', 'LONGITUDE', 'SEVERITY']]\n\ncollisions_subset.head(5)"}
{"task_id": "DSP/305", "completion": "merged = train_df.merge(collisions_subset, how='left', left_on='date', right_on='DATE')\n\nmerged.head()"}
{"task_id": "DSP/305", "completion": "merged = train_df.merge(collisions_subset, how='left', left_on='date', right_on='DATE')\n\nmerged.head()"}
{"task_id": "DSP/306", "completion": "start_to_accident = haversine(merged['pickup_latitude'].values,\n                              merged['pickup_longitude'].values,\n                              merged['LATITUDE'].values,\n                              merged['LONGITUDE'].values)\nmerged['start_to_accident'] = start_to_accident\n\n# initialze accident_close column to all 0 first\nmerged['accident_close'] = 0\n\n# # Boolean pd.Series to select the indices for which accident_close should equal 1:\n# # (1) record's start_to_accident <= 5 \n# # (2) pick up time is between start and end\nis_accident_close = (merged['start_to_accident'] <= 5) & (merged['tpep_pickup_datetime'] >= merged['START']) & (merged['tpep_pickup_datetime'] <= merged['END'])\n\nmerged.loc[is_accident_close, 'accident_close'] = 1"}
{"task_id": "DSP/306", "completion": "start_to_accident = haversine(merged['pickup_latitude'].values,\n                              merged['pickup_longitude'].values,\n                              merged['LATITUDE'].values,\n                              merged['LONGITUDE'].values)\nmerged['start_to_accident'] = start_to_accident\n\n# initialze accident_close column to all 0 first\nmerged['accident_close'] = 0\n\n# # Boolean pd.Series to select the indices for which accident_close should equal 1:\n# # (1) record's start_to_accident <= 5 \n# # (2) pick up time is between start and end\nis_accident_close = (merged['start_to_accident'] <= 5) & (merged['tpep_pickup_datetime'] >= merged['START']) & (merged['tpep_pickup_datetime'] <= merged['END'])\n\nmerged.loc[is_accident_close, 'accident_close'] = 1"}
{"task_id": "DSP/307", "completion": "calls_by_cvlegend_and_offense = calls.groupby(['CVLEGEND', 'OFFENSE']).size()"}
{"task_id": "DSP/307", "completion": "calls_by_cvlegend_and_offense = calls.groupby(['CVLEGEND', 'OFFENSE']).size()"}
{"task_id": "DSP/308", "completion": "answer1b = list(calls.loc[calls['CVLEGEND']=='LARCENY']['OFFENSE'].unique())"}
{"task_id": "DSP/308", "completion": "answer1b = list(calls.loc[calls['CVLEGEND']=='LARCENY']['OFFENSE'].unique())"}
{"task_id": "DSP/309", "completion": "answer2 = list(calls['CVLEGEND'].value_counts().head(5).keys())"}
{"task_id": "DSP/309", "completion": "answer2 = list(calls['CVLEGEND'].value_counts().head(5).keys())"}
{"task_id": "DSP/310", "completion": "days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nday_indices = range(7)\nindices_to_days_dict = dict(zip(day_indices, days)) # Should look like {0:\"Sunday\", 1:\"Monday\", ..., 6:\"Saturday\"}\n\ncalls['Day'] = calls['CVDOW'].map(indices_to_days_dict)"}
{"task_id": "DSP/310", "completion": "days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nday_indices = range(7)\nindices_to_days_dict = dict(zip(day_indices, days)) # Should look like {0:\"Sunday\", 1:\"Monday\", ..., 6:\"Saturday\"}\n\ncalls['Day'] = calls['CVDOW'].map(indices_to_days_dict)"}
{"task_id": "DSP/311", "completion": "ax = calls['Day'].value_counts()[days].plot.bar(x='Day', y='Number of Calls')\nax.set_xlabel('Day')\nax.set_ylabel('Number of Calls')\n\n# Leave this for grading purposes\nax_3b = plt.gca()"}
{"task_id": "DSP/311", "completion": "ax = calls['Day'].value_counts()[days].plot.bar(x='Day', y='Number of Calls')\nax.set_xlabel('Day')\nax.set_ylabel('Number of Calls')\n\n# Leave this for grading purposes\nax_3b = plt.gca()"}
{"task_id": "DSP/312", "completion": "ax = sns.countplot(x=calls.loc[calls['CVLEGEND'] == 'NOISE VIOLATION']['Day'], order=days)\nax.set_title(\"Number of Toal Noise Violation For Each Day of the Week\");\nax_4a = plt.gca()"}
{"task_id": "DSP/312", "completion": "ax = sns.countplot(x=calls.loc[calls['CVLEGEND'] == 'NOISE VIOLATION']['Day'], order=days)\nax.set_title(\"Number of Toal Noise Violation For Each Day of the Week\");\nax_4a = plt.gca()"}
{"task_id": "DSP/313", "completion": "ax = sns.countplot(x=calls.loc[calls['CVLEGEND'] == 'FRAUD']['Day'], order=days)\nax.set_title(\"Number of Toal Fraud For Each Day of the Week\");\n\n# Leave this for grading purposes\nax_5 = plt.gca()"}
{"task_id": "DSP/313", "completion": "ax = sns.countplot(x=calls.loc[calls['CVLEGEND'] == 'FRAUD']['Day'], order=days)\nax.set_title(\"Number of Toal Fraud For Each Day of the Week\");\n\n# Leave this for grading purposes\nax_5 = plt.gca()"}
{"task_id": "DSP/314", "completion": "calls['Hour'] = calls['EVENTTM'].str.slice(0,2).astype('int')"}
{"task_id": "DSP/314", "completion": "calls['Hour'] = calls['EVENTTM'].str.slice(0,2).astype('int')"}
{"task_id": "DSP/315", "completion": "ax = sns.countplot(calls.loc[calls['CVLEGEND']=='FRAUD']['Hour'])\nax.set_xlabel(\"Hour of the Day\")\nax.set_ylabel(\"Number of Calls\")\nax.set_title(\"Number of Calls Reporting Fraud For Each Day of the Week\");\n\n# Leave this for grading purposes\nax_6b = plt.gca()"}
{"task_id": "DSP/315", "completion": "ax = sns.countplot(calls.loc[calls['CVLEGEND']=='FRAUD']['Hour'])\nax.set_xlabel(\"Hour of the Day\")\nax.set_ylabel(\"Number of Calls\")\nax.set_title(\"Number of Calls Reporting Fraud For Each Day of the Week\");\n\n# Leave this for grading purposes\nax_6b = plt.gca()"}
{"task_id": "DSP/316", "completion": "answer7 = 'SEX CRIME'"}
{"task_id": "DSP/316", "completion": "answer7 = 'SEX CRIME'"}
{"task_id": "DSP/317", "completion": "def bootstrap(boot_pop, statistic, resample, replicates = 1000):\n    \"\"\"\n    Args:\n        boot_pop: an array of shape n x d.\n        statistic: a function which takes boot_pop and returns a number.\n        resample: a function which takes n and returns a random sample from the integers [0, n)\n        replicates: the number of resamples\n        \n    Returns:\n        an array of length replicates, each entry being the statistic computed on a bootstrap sample of the data.\n    \"\"\"\n    return np.array([statistic(boot_pop[resample(len(boot_pop))]) for _ in range(replicates)])"}
{"task_id": "DSP/317", "completion": "def bootstrap(boot_pop, statistic, resample, replicates = 1000):\n    \"\"\"\n    Args:\n        boot_pop: an array of shape n x d.\n        statistic: a function which takes boot_pop and returns a number.\n        resample: a function which takes n and returns a random sample from the integers [0, n)\n        replicates: the number of resamples\n        \n    Returns:\n        an array of length replicates, each entry being the statistic computed on a bootstrap sample of the data.\n    \"\"\"\n    return np.array([statistic(boot_pop[resample(len(boot_pop))]) for _ in range(replicates)])"}
{"task_id": "DSP/318", "completion": "m = 1000\nboot_pop = np.array(data[\"Grade\"])\n\nboot_sample_std = bootstrap(boot_pop, np.std, simple_resample, m)"}
{"task_id": "DSP/318", "completion": "m = 1000\nboot_pop = np.array(data[\"Grade\"])\n\nboot_sample_std = bootstrap(boot_pop, np.std, simple_resample, m)"}
{"task_id": "DSP/319", "completion": "def estimator(d):\n    \"\"\"\n    Args:\n        d: A n*2 array which contains x and y. d[:,0] would be x, d[:,1] would be y.\n        \n    Returns:\n        The optimal theta for this dataset under L2 loss.\n    \"\"\"\n    return np.dot(d[:, 0], d[:, 1]) / (np.dot(d[:, 0], d[:, 0])).sum()"}
{"task_id": "DSP/319", "completion": "def estimator(d):\n    \"\"\"\n    Args:\n        d: A n*2 array which contains x and y. d[:,0] would be x, d[:,1] would be y.\n        \n    Returns:\n        The optimal theta for this dataset under L2 loss.\n    \"\"\"\n    return np.dot(d[:, 0], d[:, 1]) / (np.dot(d[:, 0], d[:, 0])).sum()"}
{"task_id": "DSP/320", "completion": "replicates = 1000\nboot_theta = bootstrap(d, estimator, simple_resample, replicates)"}
{"task_id": "DSP/320", "completion": "replicates = 1000\nboot_theta = bootstrap(d, estimator, simple_resample, replicates)"}
{"task_id": "DSP/321", "completion": "def mean(population):\n    return sum([x for x in population])/len(population)\n\ndef variance(population):\n    m = mean(population)\n    return sum([(x - m)**2 for x in population])/len(population)"}
{"task_id": "DSP/321", "completion": "def mean(population):\n    return sum([x for x in population])/len(population)\n\ndef variance(population):\n    m = mean(population)\n    return sum([(x - m)**2 for x in population])/len(population)"}
{"task_id": "DSP/322", "completion": "plt.figure(figsize=(20,10))\n\nsigma = 10\n\n# Loop through index of each channel\nfor channel in range(3):\n    # Make a subplot\n    plt.subplot(1,3,channel+1)\n    \n    # FINISH THE CODE\n    pic_copy = pic.copy()\n    pic_copy[:, :, channel] = skimage.filters.gaussian(pic_copy[:,:,channel], sigma)\n    skimage.io.imshow(pic_copy)\n    \n    plt.grid(False)\n    plt.title(channel_names[channel])\n    plt.suptitle(\"Blurred channels of an image\")"}
{"task_id": "DSP/322", "completion": "plt.figure(figsize=(20,10))\n\nsigma = 10\n\n# Loop through index of each channel\nfor channel in range(3):\n    # Make a subplot\n    plt.subplot(1,3,channel+1)\n    \n    # FINISH THE CODE\n    pic_copy = pic.copy()\n    pic_copy[:, :, channel] = skimage.filters.gaussian(pic_copy[:,:,channel], sigma)\n    skimage.io.imshow(pic_copy)\n    \n    plt.grid(False)\n    plt.title(channel_names[channel])\n    plt.suptitle(\"Blurred channels of an image\")"}
{"task_id": "DSP/323", "completion": "def multiply_list_fixed(some_list, multiplier):\n    return np.array(some_list) * multiplier"}
{"task_id": "DSP/323", "completion": "def multiply_list_fixed(some_list, multiplier):\n    return np.array(some_list) * multiplier"}
{"task_id": "DSP/324", "completion": "def find_all_under_10_fixed(some_list):\n    return np.extract(np.array(some_list)<10, np.array(some_list))"}
{"task_id": "DSP/324", "completion": "def find_all_under_10_fixed(some_list):\n    return np.extract(np.array(some_list)<10, np.array(some_list))"}
{"task_id": "DSP/325", "completion": "def cat_fixed(cat_data):\n    lst = [[x[0],int(x[1])+3] for x in cat_data if int(x[1]) < 10]\n    return np.array(lst)"}
{"task_id": "DSP/325", "completion": "def cat_fixed(cat_data):\n    lst = [[x[0],int(x[1])+3] for x in cat_data if int(x[1]) < 10]\n    return np.array(lst)"}
{"task_id": "DSP/326", "completion": "bike = bike.replace({'weekday' : {0:'Sun', 1:'Mon', 2:'Tue', 3:'Wed', 4:'Thu', 5:'Fri', 6:'Sat'},\n                    'holiday':{0:'no', 1:'yes'},\n                    'workingday':{0:'no', 1:'yes'},\n                    'weathersit':{0:'Clear', 1:'Mist', 2:'Light', 3:'Heavy'}})"}
{"task_id": "DSP/326", "completion": "bike = bike.replace({'weekday' : {0:'Sun', 1:'Mon', 2:'Tue', 3:'Wed', 4:'Thu', 5:'Fri', 6:'Sat'},\n                    'holiday':{0:'no', 1:'yes'},\n                    'workingday':{0:'no', 1:'yes'},\n                    'weathersit':{0:'Clear', 1:'Mist', 2:'Light', 3:'Heavy'}})"}
{"task_id": "DSP/327", "completion": "num_holidays = bike.loc[bike['holiday']=='yes','holiday'].size"}
{"task_id": "DSP/327", "completion": "num_holidays = bike.loc[bike['holiday']=='yes','holiday'].size"}
{"task_id": "DSP/328", "completion": "daily_counts = bike.groupby('dteday').agg({'casual':'sum', 'registered':'sum', 'workingday':'first'})\ndaily_counts.head(5)"}
{"task_id": "DSP/328", "completion": "daily_counts = bike.groupby('dteday').agg({'casual':'sum', 'registered':'sum', 'workingday':'first'})\ndaily_counts.head(5)"}
{"task_id": "DSP/329", "completion": "bike['prop_casual'] = bike['casual'] / bike['cnt']"}
{"task_id": "DSP/329", "completion": "bike['prop_casual'] = bike['casual'] / bike['cnt']"}
{"task_id": "DSP/330", "completion": "def model(theta, total_bill):\n    \"\"\"\n    Takes the parameter theta and the total bill, and returns the computed tip.\n    \n    Parameters\n    ----------\n    theta: tip percentage \n    total_bill: total bill value in dollars\n    \"\"\"\n    return theta * total_bill"}
{"task_id": "DSP/330", "completion": "def model(theta, total_bill):\n    \"\"\"\n    Takes the parameter theta and the total bill, and returns the computed tip.\n    \n    Parameters\n    ----------\n    theta: tip percentage \n    total_bill: total bill value in dollars\n    \"\"\"\n    return theta * total_bill"}
{"task_id": "DSP/331", "completion": "def squared_loss(y_obs, y_hat):\n    \"\"\"\n    Calculate the squared loss of the observed data and predicted data.\n    \n    Parameters\n    ------------\n    y_obs: an array of observed values\n    y_hat: an array of predicted values\n    \n    Returns\n    ------------\n    An array of loss values corresponding to the squared loss for each prediction\n    \"\"\"\n    ...\n    return (y_obs - y_hat) ** 2"}
{"task_id": "DSP/331", "completion": "def squared_loss(y_obs, y_hat):\n    \"\"\"\n    Calculate the squared loss of the observed data and predicted data.\n    \n    Parameters\n    ------------\n    y_obs: an array of observed values\n    y_hat: an array of predicted values\n    \n    Returns\n    ------------\n    An array of loss values corresponding to the squared loss for each prediction\n    \"\"\"\n    ...\n    return (y_obs - y_hat) ** 2"}
{"task_id": "DSP/332", "completion": "loss = np.array([ squared_loss(y, model(theta, x)) for theta in thetas])\n# loss.shape\nplt.figure(figsize=(8,5))\nplt.plot(thetas, loss, label='Squared Loss')\nplt.ylabel('Loss')\nplt.xlabel(r'Choice for $\\theta$')\nplt.yticks(np.arange(0, 35, 5))\nplt.legend(loc=4)\nplt.show()"}
{"task_id": "DSP/332", "completion": "loss = np.array([ squared_loss(y, model(theta, x)) for theta in thetas])\n# loss.shape\nplt.figure(figsize=(8,5))\nplt.plot(thetas, loss, label='Squared Loss')\nplt.ylabel('Loss')\nplt.xlabel(r'Choice for $\\theta$')\nplt.yticks(np.arange(0, 35, 5))\nplt.legend(loc=4)\nplt.show()"}
{"task_id": "DSP/333", "completion": "def abs_loss(y_obs, y_hat):\n    \"\"\"\n    Calculate the absolute loss of the observed data and predicted data.\n    \n    Parameters\n    ------------\n    y_obs: an array of observed values\n    y_hat: an array of predicted values\n    \n    Returns\n    ------------\n    An array of loss values corresponding to the absolute loss for each prediction\n    \"\"\"\n    ...\n    return abs(y_obs - y_hat)"}
{"task_id": "DSP/333", "completion": "def abs_loss(y_obs, y_hat):\n    \"\"\"\n    Calculate the absolute loss of the observed data and predicted data.\n    \n    Parameters\n    ------------\n    y_obs: an array of observed values\n    y_hat: an array of predicted values\n    \n    Returns\n    ------------\n    An array of loss values corresponding to the absolute loss for each prediction\n    \"\"\"\n    ...\n    return abs(y_obs - y_hat)"}
{"task_id": "DSP/334", "completion": "bus['postal_code_5'] = bus['postal_code_5'].str.replace('94602', '94102')"}
{"task_id": "DSP/334", "completion": "bus['postal_code_5'] = bus['postal_code_5'].str.replace('94602', '94102')"}
{"task_id": "DSP/335", "completion": "def find_slice(matx):\n    ### BEGIN SOLUTION\n    return matx[:2, 1:3]\n    ### END SOLUTION"}
{"task_id": "DSP/335", "completion": "def find_slice(matx):\n    ### BEGIN SOLUTION\n    return matx[:2, 1:3]\n    ### END SOLUTION"}
{"task_id": "DSP/336", "completion": "def update_slice(matx):\n    ### BEGIN SOLUTION\n    matx[:2, 1:3] += 1000\n    return matx\n    ### END SOLUTION"}
{"task_id": "DSP/336", "completion": "def update_slice(matx):\n    ### BEGIN SOLUTION\n    matx[:2, 1:3] += 1000\n    return matx\n    ### END SOLUTION"}
{"task_id": "DSP/337", "completion": "def boolean_filter(matx):\n    ### BEGIN SOLUTION\n    return matx[matx<1.5]\n    ### END SOLUTION"}
{"task_id": "DSP/337", "completion": "def boolean_filter(matx):\n    ### BEGIN SOLUTION\n    return matx[matx<1.5]\n    ### END SOLUTION"}
{"task_id": "DSP/338", "completion": "def int_converter(matx):\n    ### BEGIN SOLUTION\n    return np.array(matx, dtype=np.int)\n    ### END SOLUTION"}
{"task_id": "DSP/338", "completion": "def int_converter(matx):\n    ### BEGIN SOLUTION\n    return np.array(matx, dtype=np.int)\n    ### END SOLUTION"}
{"task_id": "DSP/339", "completion": "def selective_replace(matx):\n    ### BEGIN SOLUTION\n    matx[matx % 2 == 0] = 55\n    ### END SOLUTION"}
{"task_id": "DSP/339", "completion": "def selective_replace(matx):\n    ### BEGIN SOLUTION\n    matx[matx % 2 == 0] = 55\n    ### END SOLUTION"}
{"task_id": "DSP/340", "completion": "def row_means(matx):\n    ### BEGIN SOLUTION\n    return matx.mean(axis = 1)\n    ### END SOLUTION"}
{"task_id": "DSP/340", "completion": "def row_means(matx):\n    ### BEGIN SOLUTION\n    return matx.mean(axis = 1)\n    ### END SOLUTION"}
{"task_id": "DSP/341", "completion": "def unique_finder(matx):\n    ### BEGIN SOLUTION\n    return np.unique(matx)\n    ### END SOLUTION"}
{"task_id": "DSP/341", "completion": "def unique_finder(matx):\n    ### BEGIN SOLUTION\n    return np.unique(matx)\n    ### END SOLUTION"}
{"task_id": "DSP/342", "completion": "def first_row_adder(matx):\n    ### BEGIN SOLUTION\n    return matx + matx[0,:]\n    ### END SOLUTION"}
{"task_id": "DSP/342", "completion": "def first_row_adder(matx):\n    ### BEGIN SOLUTION\n    return matx + matx[0,:]\n    ### END SOLUTION"}
{"task_id": "DSP/343", "completion": "mpg_data = pd.read_fwf(\"data/auto-mpg.data\", header = None)\nmpg_data.columns = [\n    \"mpg\",\n    \"cylinders\",\n    \"displacement\",\n    \"horsepower\",\n    \"weight\",\n    \"acceleration\",\n    \"model_year\",\n    \"origin\",\n    \"car_name\"\n]"}
{"task_id": "DSP/343", "completion": "mpg_data = pd.read_fwf(\"data/auto-mpg.data\", header = None)\nmpg_data.columns = [\n    \"mpg\",\n    \"cylinders\",\n    \"displacement\",\n    \"horsepower\",\n    \"weight\",\n    \"acceleration\",\n    \"model_year\",\n    \"origin\",\n    \"car_name\"\n]"}
{"task_id": "DSP/344", "completion": "mpg_data.loc[mpg_data.horsepower == '?', 'horsepower'] = np.nan\nmpg_data.horsepower = mpg_data.horsepower.astype(\"float64\")\nmpg_data.horsepower.unique()"}
{"task_id": "DSP/344", "completion": "mpg_data.loc[mpg_data.horsepower == '?', 'horsepower'] = np.nan\nmpg_data.horsepower = mpg_data.horsepower.astype(\"float64\")\nmpg_data.horsepower.unique()"}
{"task_id": "DSP/345", "completion": "mpg_data.dropna(subset = [\"horsepower\"], inplace = True)\nmpg_data.horsepower.unique()"}
{"task_id": "DSP/345", "completion": "mpg_data.dropna(subset = [\"horsepower\"], inplace = True)\nmpg_data.horsepower.unique()"}
{"task_id": "DSP/346", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    condition = dataframe.cylinders == dataframe.cylinders.min()\n    car_names = dataframe[condition].car_name\n    return car_names"}
{"task_id": "DSP/346", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    condition = dataframe.cylinders == dataframe.cylinders.min()\n    car_names = dataframe[condition].car_name\n    return car_names"}
{"task_id": "DSP/347", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/347", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/348", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\",\n                          header = None, sep = r\",\\s\", engine = \"python\")\nincome_data.columns = [\n    \"age\",\n    \"work_class\",\n    \"fnlwgt\",\n    \"education\",\n    \"education_num\",\n    \"marital_status\",\n    \"occupation\",\n    \"relationship\",\n    \"race\",\n    \"sex\",\n    \"capital_gain\",\n    \"capital_loss\",\n    \"hours_weekly\",\n    \"native_country\",\n    \"salary\"\n]\nincome_data.head()"}
{"task_id": "DSP/348", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\",\n                          header = None, sep = r\",\\s\", engine = \"python\")\nincome_data.columns = [\n    \"age\",\n    \"work_class\",\n    \"fnlwgt\",\n    \"education\",\n    \"education_num\",\n    \"marital_status\",\n    \"occupation\",\n    \"relationship\",\n    \"race\",\n    \"sex\",\n    \"capital_gain\",\n    \"capital_loss\",\n    \"hours_weekly\",\n    \"native_country\",\n    \"salary\"\n]\nincome_data.head()"}
{"task_id": "DSP/349", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    return dataframe[dataframe.capital_gain >= threshold_gain].capital_gain.count()"}
{"task_id": "DSP/349", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    return dataframe[dataframe.capital_gain >= threshold_gain].capital_gain.count()"}
{"task_id": "DSP/350", "completion": "def most_prominent_marital_status(dataframe):\n    status = \"\"\n    num_people = 0\n    grouped_by_marital_status = dataframe.groupby(\"marital_status\")\n    for key, value in grouped_by_marital_status:\n        if len(value) > num_people:\n            num_people = len(value)\n            status = key\n    return (status, num_people)"}
{"task_id": "DSP/350", "completion": "def most_prominent_marital_status(dataframe):\n    status = \"\"\n    num_people = 0\n    grouped_by_marital_status = dataframe.groupby(\"marital_status\")\n    for key, value in grouped_by_marital_status:\n        if len(value) > num_people:\n            num_people = len(value)\n            status = key\n    return (status, num_people)"}
{"task_id": "DSP/351", "completion": "def get_num_people_by_age_category(dataframe):\n    young = dataframe[dataframe.age <= 30].age.count()\n    middle_aged = dataframe[(dataframe.age > 30) & (dataframe.age <= 60)].age.count()\n    old = dataframe[dataframe.age > 60].age.count()\n    return young, middle_aged, old\n\nget_num_people_by_age_category(income_data)"}
{"task_id": "DSP/351", "completion": "def get_num_people_by_age_category(dataframe):\n    young = dataframe[dataframe.age <= 30].age.count()\n    middle_aged = dataframe[(dataframe.age > 30) & (dataframe.age <= 60)].age.count()\n    old = dataframe[dataframe.age > 60].age.count()\n    return young, middle_aged, old\n\nget_num_people_by_age_category(income_data)"}
{"task_id": "DSP/352", "completion": "def get_second_highest_num_people(dataframe):\n    grouped_by_country = dataframe.groupby(\"native_country\")\n    count_by_country = {key: len(value) for key, value in grouped_by_country}\n    sorted_count_by_country = sorted(count_by_country.items(), key = operator.itemgetter(1))\n    country = sorted_count_by_country[-2][0]\n    num_people = sorted_count_by_country[-2][1]\n    return num_people, country\n\nnum_people, country = get_second_highest_num_people(income_data)\nprint(country)\nprint(num_people)"}
{"task_id": "DSP/352", "completion": "def get_second_highest_num_people(dataframe):\n    grouped_by_country = dataframe.groupby(\"native_country\")\n    count_by_country = {key: len(value) for key, value in grouped_by_country}\n    sorted_count_by_country = sorted(count_by_country.items(), key = operator.itemgetter(1))\n    country = sorted_count_by_country[-2][0]\n    num_people = sorted_count_by_country[-2][1]\n    return num_people, country\n\nnum_people, country = get_second_highest_num_people(income_data)\nprint(country)\nprint(num_people)"}
{"task_id": "DSP/353", "completion": "def get_mean_working_hours_by_income(dataframe):\n    result = dataframe.groupby(\"occupation\").hours_weekly.mean()\n    sorted_result = result.sort_values(ascending = False)\n    return sorted_result"}
{"task_id": "DSP/353", "completion": "def get_mean_working_hours_by_income(dataframe):\n    result = dataframe.groupby(\"occupation\").hours_weekly.mean()\n    sorted_result = result.sort_values(ascending = False)\n    return sorted_result"}
{"task_id": "DSP/354", "completion": "failed_student_times = np.random.uniform(1, 3, 12)\npassed_student_times = np.random.uniform(7, 10, 8)\nall_times = np.concatenate([failed_student_times, passed_student_times])\n\nexam_result = []\nfor student_time in all_times:\n    if student_time <= 3:\n        exam_result.append(0)\n    else:\n        exam_result.append(1)\nexam_result = np.array(exam_result)"}
{"task_id": "DSP/354", "completion": "failed_student_times = np.random.uniform(1, 3, 12)\npassed_student_times = np.random.uniform(7, 10, 8)\nall_times = np.concatenate([failed_student_times, passed_student_times])\n\nexam_result = []\nfor student_time in all_times:\n    if student_time <= 3:\n        exam_result.append(0)\n    else:\n        exam_result.append(1)\nexam_result = np.array(exam_result)"}
{"task_id": "DSP/355", "completion": "all_times = np.random.uniform(1, 10, 20)\nexam_result = []\nfor student_time in all_times:\n    if student_time <= 3:\n        exam_result.append(0)\n    elif student_time >= 7:\n        exam_result.append(1)\n    else:\n        random_number = np.random.random()\n        if random_number >= 0.5:\n            exam_result.append(1)\n        else:\n            exam_result.append(0)\nexam_result = np.array(exam_result)"}
{"task_id": "DSP/355", "completion": "all_times = np.random.uniform(1, 10, 20)\nexam_result = []\nfor student_time in all_times:\n    if student_time <= 3:\n        exam_result.append(0)\n    elif student_time >= 7:\n        exam_result.append(1)\n    else:\n        random_number = np.random.random()\n        if random_number >= 0.5:\n            exam_result.append(1)\n        else:\n            exam_result.append(0)\nexam_result = np.array(exam_result)"}
{"task_id": "DSP/356", "completion": "def error_0(x):\n    return -np.log(1 - x)\n\ndef error_1(x):\n    return -np.log(x)"}
{"task_id": "DSP/356", "completion": "def error_0(x):\n    return -np.log(1 - x)\n\ndef error_1(x):\n    return -np.log(x)"}
{"task_id": "DSP/357", "completion": "def naturals(val):\n    sum = 0;\n    for i in range(val):\n        if 3 * i < val:\n            sum += (3*i) \n        if 5 * i < val:\n            sum += (5*i)\n    return sum"}
{"task_id": "DSP/357", "completion": "def naturals(val):\n    sum = 0;\n    for i in range(val):\n        if 3 * i < val:\n            sum += (3*i) \n        if 5 * i < val:\n            sum += (5*i)\n    return sum"}
{"task_id": "DSP/358", "completion": "def sdiff(val):\n    sum2 = 0\n    sum3 = 0\n    for i in range(val):\n        sum2 += i**2\n        sum3 += i\n\n    sum2 -= sum3\n    return sum2"}
{"task_id": "DSP/358", "completion": "def sdiff(val):\n    sum2 = 0\n    sum3 = 0\n    for i in range(val):\n        sum2 += i**2\n        sum3 += i\n\n    sum2 -= sum3\n    return sum2"}
{"task_id": "DSP/359", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/359", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/360", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/360", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/361", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/361", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/362", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/362", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/363", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/363", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/364", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/364", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/365", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/365", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/366", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/366", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/367", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/367", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/368", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/368", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/369", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\n    \"\"\"\n    a = mu - np.sqrt(3*sigma**2)\n    b = mu + np.sqrt(3*sigma**2)\n    var = np.random.uniform(a,b,size)\n    return var"}
{"task_id": "DSP/369", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\n    \"\"\"\n    a = mu - np.sqrt(3*sigma**2)\n    b = mu + np.sqrt(3*sigma**2)\n    var = np.random.uniform(a,b,size)\n    return var"}
{"task_id": "DSP/370", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    arr = np.random.normal(mu, sigma, size=size)\n    arr = np.exp(arr)\n    return arr"}
{"task_id": "DSP/370", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    arr = np.random.normal(mu, sigma, size=size)\n    arr = np.exp(arr)\n    return arr"}
{"task_id": "DSP/371", "completion": "def fair(data):\n    h = 0\n\n    if 'H' not in data:\n        return 0.0\n    \n    for ele in data:\n        if ele == 'H':\n            h += 1\n\n    return h/len(data)"}
{"task_id": "DSP/371", "completion": "def fair(data):\n    h = 0\n\n    if 'H' not in data:\n        return 0.0\n    \n    for ele in data:\n        if ele == 'H':\n            h += 1\n\n    return h/len(data)"}
{"task_id": "DSP/372", "completion": "def bootstrap_data(data):\n    boots = np.random.choice(data,len(data))\n    return boots"}
{"task_id": "DSP/372", "completion": "def bootstrap_data(data):\n    boots = np.random.choice(data,len(data))\n    return boots"}
{"task_id": "DSP/373", "completion": "def bootstrap_function(data, f, n):\n    arr = []\n    for i in range(n):\n        arr.append(f(bootstrap_data(data)))\n    return np.array(arr)"}
{"task_id": "DSP/373", "completion": "def bootstrap_function(data, f, n):\n    arr = []\n    for i in range(n):\n        arr.append(f(bootstrap_data(data)))\n    return np.array(arr)"}
{"task_id": "DSP/374", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/374", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/375", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/375", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/376", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/376", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/377", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/377", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/378", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/378", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/379", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/379", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/380", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/380", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/381", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/381", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/382", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/382", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/383", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/383", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/384", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/384", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/385", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/385", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/386", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/386", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/387", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/387", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/388", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/388", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/389", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/389", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/390", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/390", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/391", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/391", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/392", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/392", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/393", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/393", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/394", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/394", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/395", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/395", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/396", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/396", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/397", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/397", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/398", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/398", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/399", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/399", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/400", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/400", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/401", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/401", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/402", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/402", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/403", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/403", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/404", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/404", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/405", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/405", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/406", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/406", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/407", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/407", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/408", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/408", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/409", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/409", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/410", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/410", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/411", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/411", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/412", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/412", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/413", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/413", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/414", "completion": "def hat(x,a=5.0,b=1.0):\n    return -a* x*x + b*x**4"}
{"task_id": "DSP/414", "completion": "def hat(x,a=5.0,b=1.0):\n    return -a* x*x + b*x**4"}
{"task_id": "DSP/415", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\n    \"\"\"\n    a = mu - np.sqrt(3*sigma**2)\n    b = mu + np.sqrt(3*sigma**2)\n    var = np.random.uniform(a,b,size)\n    return var"}
{"task_id": "DSP/415", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\n    \"\"\"\n    a = mu - np.sqrt(3*sigma**2)\n    b = mu + np.sqrt(3*sigma**2)\n    var = np.random.uniform(a,b,size)\n    return var"}
{"task_id": "DSP/416", "completion": "def fair(data):\n    h = 0\n\n    if 'H' not in data:\n        return 0.0\n    \n    for ele in data:\n        if ele == 'H':\n            h += 1\n\n    return h/len(data)"}
{"task_id": "DSP/416", "completion": "def fair(data):\n    h = 0\n\n    if 'H' not in data:\n        return 0.0\n    \n    for ele in data:\n        if ele == 'H':\n            h += 1\n\n    return h/len(data)"}
{"task_id": "DSP/417", "completion": "def bootstrap_data(data):\n    boots = np.random.choice(data,len(data))\n    return boots"}
{"task_id": "DSP/417", "completion": "def bootstrap_data(data):\n    boots = np.random.choice(data,len(data))\n    return boots"}
{"task_id": "DSP/418", "completion": "def bootstrap_function(data, f, n):\n    arr = []\n    for i in range(n):\n        arr.append(f(bootstrap_data(data)))\n    return np.array(arr)"}
{"task_id": "DSP/418", "completion": "def bootstrap_function(data, f, n):\n    arr = []\n    for i in range(n):\n        arr.append(f(bootstrap_data(data)))\n    return np.array(arr)"}
{"task_id": "DSP/419", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    arr = np.random.normal(mu, sigma, size=size)\n    arr = np.exp(arr)\n    return arr"}
{"task_id": "DSP/419", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    arr = np.random.normal(mu, sigma, size=size)\n    arr = np.exp(arr)\n    return arr"}
{"task_id": "DSP/420", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/420", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/421", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/421", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/422", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/422", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/423", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/423", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/424", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/424", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/425", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/425", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/426", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/426", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/427", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/427", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/428", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/428", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/429", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/429", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/430", "completion": "def sdiff(val):\n    sum2 = 0\n    sum3 = 0\n    for i in range(val):\n        sum2 += i**2\n        sum3 += i\n\n    sum2 -= sum3\n    return sum2"}
{"task_id": "DSP/430", "completion": "def sdiff(val):\n    sum2 = 0\n    sum3 = 0\n    for i in range(val):\n        sum2 += i**2\n        sum3 += i\n\n    sum2 -= sum3\n    return sum2"}
{"task_id": "DSP/431", "completion": "sim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/431", "completion": "sim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/432", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/432", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/433", "completion": "results = wiener(1.0, 1000)\nt = list(results)[0]\nW = list(results)[1]\nprint(len(t), len(W))"}
{"task_id": "DSP/433", "completion": "results = wiener(1.0, 1000)\nt = list(results)[0]\nW = list(results)[1]\nprint(len(t), len(W))"}
{"task_id": "DSP/434", "completion": "def same_digits(x, y):\n    a = list(x)\n    b = list(y)\n    \n    if len(a) != len(b):\n        return False\n        \n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n        \n    return True"}
{"task_id": "DSP/434", "completion": "def same_digits(x, y):\n    a = list(x)\n    b = list(y)\n    \n    if len(a) != len(b):\n        return False\n        \n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n        \n    return True"}
{"task_id": "DSP/435", "completion": "def fair(data):\n    h = 0\n\n    if 'H' not in data:\n        return 0.0\n    \n    for ele in data:\n        if ele == 'H':\n            h += 1\n\n    return h/len(data)"}
{"task_id": "DSP/435", "completion": "def fair(data):\n    h = 0\n\n    if 'H' not in data:\n        return 0.0\n    \n    for ele in data:\n        if ele == 'H':\n            h += 1\n\n    return h/len(data)"}
{"task_id": "DSP/436", "completion": "def bootstrap_data(data):\n    boots = np.random.choice(data,len(data))\n    return boots"}
{"task_id": "DSP/436", "completion": "def bootstrap_data(data):\n    boots = np.random.choice(data,len(data))\n    return boots"}
{"task_id": "DSP/437", "completion": "def bootstrap_function(data, f, n):\n    arr = []\n    for i in range(n):\n        arr.append(f(bootstrap_data(data)))\n    return np.array(arr)"}
{"task_id": "DSP/437", "completion": "def bootstrap_function(data, f, n):\n    arr = []\n    for i in range(n):\n        arr.append(f(bootstrap_data(data)))\n    return np.array(arr)"}
{"task_id": "DSP/438", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    arr = np.random.normal(mu, sigma, size=size)\n    arr = np.exp(arr)\n    return arr"}
{"task_id": "DSP/438", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    arr = np.random.normal(mu, sigma, size=size)\n    arr = np.exp(arr)\n    return arr"}
{"task_id": "DSP/439", "completion": "def same_digits(x, y):\n    a = list(x)\n    b = list(y)\n    \n    if len(a) != len(b):\n        return False\n        \n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n        \n    return True"}
{"task_id": "DSP/439", "completion": "def same_digits(x, y):\n    a = list(x)\n    b = list(y)\n    \n    if len(a) != len(b):\n        return False\n        \n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n        \n    return True"}
{"task_id": "DSP/440", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\n    \"\"\"\n    a = mu - np.sqrt(3*sigma**2)\n    b = mu + np.sqrt(3*sigma**2)\n    var = np.random.uniform(a,b,size)\n    return var"}
{"task_id": "DSP/440", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\n    \"\"\"\n    a = mu - np.sqrt(3*sigma**2)\n    b = mu + np.sqrt(3*sigma**2)\n    var = np.random.uniform(a,b,size)\n    return var"}
{"task_id": "DSP/441", "completion": "results = wiener(1.0, 1000)\nt = list(results)[0]\nW = list(results)[1]\nprint(len(t), len(W))"}
{"task_id": "DSP/441", "completion": "results = wiener(1.0, 1000)\nt = list(results)[0]\nW = list(results)[1]\nprint(len(t), len(W))"}
{"task_id": "DSP/442", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/442", "completion": "def vector_sum(x, y):\n    for i in range(len(x)) :\n        x[i] = x[i] + y[i]\n        \n    return x"}
{"task_id": "DSP/443", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/443", "completion": "def vector_diff(x, y):\n    for i in range(len(x)) :\n        x[i] = math.fabs(x[i] - y[i])\n    return x"}
{"task_id": "DSP/444", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/444", "completion": "def vector_scalar_mul(a, x):\n    for i in range(len(x)) :\n        x[i] *= a\n        \n    return x"}
{"task_id": "DSP/445", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/445", "completion": "def vector_dot(x, y):\n    dot = 0\n    for i in range(len(x)) :\n        dot += x[i] * y[i]\n\n    return dot"}
{"task_id": "DSP/446", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/446", "completion": "def L1(x):\n    norm = 0\n    for i in range(len(x)) :\n        norm += math.fabs(x[i])\n        \n    return norm"}
{"task_id": "DSP/447", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/447", "completion": "def L2(x):\n    l2 = 0\n    for i in range(len(x)) :\n        l2 += x[i]**2    \n        \n    return math.sqrt(l2)"}
{"task_id": "DSP/448", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/448", "completion": "def mse(x, y):\n    for i in range(len(x)):\n        x[i] -= y[i]\n        x[i] = x[i]**2\n    \n    return math.fsum(x)/ len(x)"}
{"task_id": "DSP/449", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/449", "completion": "def mean(x):\n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/450", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/450", "completion": "def var(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n        \n    return math.fsum(x) / len(x)"}
{"task_id": "DSP/451", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/451", "completion": "def std(x):\n    mean = math.fsum(x) / len(x) \n    for i in range(len(x)):\n        x[i] -= mean\n        x[i] = x[i]**2\n\n    return math.sqrt(math.fsum(x) / len(x))"}
{"task_id": "DSP/452", "completion": "sim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/452", "completion": "sim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/453", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/453", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/454", "completion": "def hat(x,a=5.0,b=1.0):\n    return -a* x*x + b*x**4"}
{"task_id": "DSP/454", "completion": "def hat(x,a=5.0,b=1.0):\n    return -a* x*x + b*x**4"}
{"task_id": "DSP/455", "completion": "results = wiener(1.0, 1000)\nt = list(results)[0]\nW = list(results)[1]\nprint(len(t), len(W))"}
{"task_id": "DSP/455", "completion": "results = wiener(1.0, 1000)\nt = list(results)[0]\nW = list(results)[1]\nprint(len(t), len(W))"}
{"task_id": "DSP/456", "completion": "def same_digits(x, y):\n    a = list(x)\n    b = list(y)\n    \n    if len(a) != len(b):\n        return False\n        \n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n        \n    return True"}
{"task_id": "DSP/456", "completion": "def same_digits(x, y):\n    a = list(x)\n    b = list(y)\n    \n    if len(a) != len(b):\n        return False\n        \n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n        \n    return True"}
{"task_id": "DSP/457", "completion": "A0 = ratings.assign(rating_100 = lambda x: (x.rating - 1)*25)\n### END SOLUTION"}
{"task_id": "DSP/457", "completion": "A0 = ratings.assign(rating_100 = lambda x: (x.rating - 1)*25)\n### END SOLUTION"}
{"task_id": "DSP/458", "completion": "A4 = movies.loc[1, 'title']\n### END SOLUTION"}
{"task_id": "DSP/458", "completion": "A4 = movies.loc[1, 'title']\n### END SOLUTION"}
{"task_id": "DSP/459", "completion": "import numpy as np\n\ndef create_array():\n    ### BEGIN SOLUTION\n    result = np.arange(16)[1:].reshape((3,5)).T\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/459", "completion": "import numpy as np\n\ndef create_array():\n    ### BEGIN SOLUTION\n    result = np.arange(16)[1:].reshape((3,5)).T\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/460", "completion": "import numpy as np\n\ndef new_array_second_and_fourth(original):\n    ### BEGIN SOLUTION\n    if original.shape[0] < 4:\n        result = None\n    else:\n        result = original[[1,3],:]\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/460", "completion": "import numpy as np\n\ndef new_array_second_and_fourth(original):\n    ### BEGIN SOLUTION\n    if original.shape[0] < 4:\n        result = None\n    else:\n        result = original[[1,3],:]\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/461", "completion": "import numpy as np\n\ndef new_array_section(original):\n    ### BEGIN SOLUTION\n    if len(original.shape) == 1:\n        result = None\n    else:\n        if original.shape[0] < 4 or original.shape[1] < 3:\n            result = None\n        else:\n            result = original[1:4,0:3]\n\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/461", "completion": "import numpy as np\n\ndef new_array_section(original):\n    ### BEGIN SOLUTION\n    if len(original.shape) == 1:\n        result = None\n    else:\n        if original.shape[0] < 4 or original.shape[1] < 3:\n            result = None\n        else:\n            result = original[1:4,0:3]\n\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/462", "completion": "import numpy as np\n\ndef new_array_values(original):\n    ### BEGIN SOLUTION\n    if len(original.shape) == 1:\n        result = np.array([])\n    else:\n        result = original[original <= 11]\n        result = result[result >= 3]\n    \n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/462", "completion": "import numpy as np\n\ndef new_array_values(original):\n    ### BEGIN SOLUTION\n    if len(original.shape) == 1:\n        result = np.array([])\n    else:\n        result = original[original <= 11]\n        result = result[result >= 3]\n    \n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/463", "completion": "import numpy as np\n\ndef array_divide():\n    ### BEGIN SOLUTION\n    a = np.arange(25).reshape(5,5)\n    a = a.astype(float)\n    for i in range(5)[1:]:\n        a[i,:] = a[i,:] / (5.0 * i) \n    result = a\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/463", "completion": "import numpy as np\n\ndef array_divide():\n    ### BEGIN SOLUTION\n    a = np.arange(25).reshape(5,5)\n    a = a.astype(float)\n    for i in range(5)[1:]:\n        a[i,:] = a[i,:] / (5.0 * i) \n    result = a\n    ### END SOLUTION\n    return result"}
{"task_id": "DSP/464", "completion": "import numpy as np\n\ndef generate_array():\n    ### BEGIN SOLUTION\n    result = np.random.rand(10, 3)\n    ### END SOLUTION\n    return result\n\ndef random_selection(from_array):\n    ### BEGIN SOLUTION\n    dist = abs(from_array - 0.5)\n    res = np.zeros(10).astype(float)\n    for i in np.arange(res.shape[0]):\n        index = dist[i].argmin()\n        res[i] = from_array[i][index]\n    ### END SOLUTION\n    return res"}
{"task_id": "DSP/464", "completion": "import numpy as np\n\ndef generate_array():\n    ### BEGIN SOLUTION\n    result = np.random.rand(10, 3)\n    ### END SOLUTION\n    return result\n\ndef random_selection(from_array):\n    ### BEGIN SOLUTION\n    dist = abs(from_array - 0.5)\n    res = np.zeros(10).astype(float)\n    for i in np.arange(res.shape[0]):\n        index = dist[i].argmin()\n        res[i] = from_array[i][index]\n    ### END SOLUTION\n    return res"}
{"task_id": "DSP/465", "completion": "mpg_data = pd.read_fwf(\"http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data\",header = None)\nmpg_data.columns = [\"mpg\",\"cylinders\",\"displacement\",\"horsepower\",\"weight\",\"acceleration\",\"model_year\",\"origin\",\"car_name\"]"}
{"task_id": "DSP/465", "completion": "mpg_data = pd.read_fwf(\"http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data\",header = None)\nmpg_data.columns = [\"mpg\",\"cylinders\",\"displacement\",\"horsepower\",\"weight\",\"acceleration\",\"model_year\",\"origin\",\"car_name\"]"}
{"task_id": "DSP/466", "completion": "mpg_data.horsepower = pd.to_numeric(mpg_data.horsepower, errors='coerce')\nmpg_data"}
{"task_id": "DSP/466", "completion": "mpg_data.horsepower = pd.to_numeric(mpg_data.horsepower, errors='coerce')\nmpg_data"}
{"task_id": "DSP/467", "completion": "mpg_data = mpg_data.dropna()"}
{"task_id": "DSP/467", "completion": "mpg_data = mpg_data.dropna()"}
{"task_id": "DSP/468", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    car_names = dataframe.loc[dataframe.cylinders == dataframe.cylinders.min()].car_name\n    return car_names"}
{"task_id": "DSP/468", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    car_names = dataframe.loc[dataframe.cylinders == dataframe.cylinders.min()].car_name\n    return car_names"}
{"task_id": "DSP/469", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    \n    return correlation"}
{"task_id": "DSP/469", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    \n    return correlation"}
{"task_id": "DSP/470", "completion": "failed_student_times = np.random.uniform(1,3,12)\npassed_student_times = np.random.uniform(7,10,8)\nall_times = np.concatenate([failed_student_times,passed_student_times])\nexam_result = np.array([0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1])"}
{"task_id": "DSP/470", "completion": "failed_student_times = np.random.uniform(1,3,12)\npassed_student_times = np.random.uniform(7,10,8)\nall_times = np.concatenate([failed_student_times,passed_student_times])\nexam_result = np.array([0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1])"}
{"task_id": "DSP/471", "completion": "all_times = np.random.uniform(1,10,20)\nexam_result = np.array([])\nfor time in all_times:\n    if time <= 3:\n        exam_result = np.append(exam_result,0)\n    elif time >= 7:\n        exam_result = np.append(exam_result,1)\n    else:\n        num = np.random.random()\n        if num >= 0.5:\n            exam_result = np.append(exam_result,1)\n        else:\n            exam_result = np.append(exam_result,0)"}
{"task_id": "DSP/471", "completion": "all_times = np.random.uniform(1,10,20)\nexam_result = np.array([])\nfor time in all_times:\n    if time <= 3:\n        exam_result = np.append(exam_result,0)\n    elif time >= 7:\n        exam_result = np.append(exam_result,1)\n    else:\n        num = np.random.random()\n        if num >= 0.5:\n            exam_result = np.append(exam_result,1)\n        else:\n            exam_result = np.append(exam_result,0)"}
{"task_id": "DSP/472", "completion": "def error_0(x):\n    return -np.log(1-x)\n\ndef error_1(x):\n    return -np.log(x)"}
{"task_id": "DSP/472", "completion": "def error_0(x):\n    return -np.log(1-x)\n\ndef error_1(x):\n    return -np.log(x)"}
{"task_id": "DSP/473", "completion": "page1 = skimage.io.imread(\"images/page1.jpg\")\npage2 = skimage.io.imread(\"images/page2.jpg\")\nplt.imshow(page1)\nplt.title(\"Page 1\")\nplt.show()\n\nplt.imshow(page2)\nplt.title(\"Page 2\")\nplt.show()"}
{"task_id": "DSP/473", "completion": "page1 = skimage.io.imread(\"images/page1.jpg\")\npage2 = skimage.io.imread(\"images/page2.jpg\")\nplt.imshow(page1)\nplt.title(\"Page 1\")\nplt.show()\n\nplt.imshow(page2)\nplt.title(\"Page 2\")\nplt.show()"}
{"task_id": "DSP/474", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\ndef concatenate_images(images):\n    \"\"\"\n    Concatenates all images vertically (one below the other)\n    \"\"\"\n    image = np.vstack(resize_images(images))\n    return image"}
{"task_id": "DSP/474", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\ndef concatenate_images(images):\n    \"\"\"\n    Concatenates all images vertically (one below the other)\n    \"\"\"\n    image = np.vstack(resize_images(images))\n    return image"}
{"task_id": "DSP/475", "completion": "with open(\"output/menu.txt\",\"r\") as file:\n    menu_content = file.read()\nprint(menu_content)"}
{"task_id": "DSP/475", "completion": "with open(\"output/menu.txt\",\"r\") as file:\n    menu_content = file.read()\nprint(menu_content)"}
{"task_id": "DSP/476", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    meals_string = os.linesep.join([s for s in meals_string.splitlines() if s])\n    text_file = open(\"output/dishes.txt\",\"r+\")\n    text_file.write(meals_string)\n    text_file.close()\n    text_file = open(\"output/dishes.txt\",\"r\")\n    meals_table = pd.read_csv(text_file,sep = \";\",header = None)\n    text_file.close()\n    meals_table.columns = [\"category\",\"dish\",\"price\"]\n    return meals_table\ntable = generate_meals_table(meals_string)\ntable"}
{"task_id": "DSP/476", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    meals_string = os.linesep.join([s for s in meals_string.splitlines() if s])\n    text_file = open(\"output/dishes.txt\",\"r+\")\n    text_file.write(meals_string)\n    text_file.close()\n    text_file = open(\"output/dishes.txt\",\"r\")\n    meals_table = pd.read_csv(text_file,sep = \";\",header = None)\n    text_file.close()\n    meals_table.columns = [\"category\",\"dish\",\"price\"]\n    return meals_table\ntable = generate_meals_table(meals_string)\ntable"}
{"task_id": "DSP/477", "completion": "num_items_total = None\nnum_categories_total = None\nnum_items_by_category = None\nmean_price_by_category = None\n\nnum_items_total =meals_table.category.count()\nnum_categories_total = len(meals_table[\"category\"].unique())\nnum_items_by_category = meals_table['category'].value_counts()\nmean_price_by_category = meals_table.groupby('category')['price'].mean()"}
{"task_id": "DSP/477", "completion": "num_items_total = None\nnum_categories_total = None\nnum_items_by_category = None\nmean_price_by_category = None\n\nnum_items_total =meals_table.category.count()\nnum_categories_total = len(meals_table[\"category\"].unique())\nnum_items_by_category = meals_table['category'].value_counts()\nmean_price_by_category = meals_table.groupby('category')['price'].mean()"}
{"task_id": "DSP/478", "completion": "def find_slice(matx):\n    ### BEGIN SOLUTION\n    return matx[:2, 1:3]\n    ### END SOLUTION"}
{"task_id": "DSP/478", "completion": "def find_slice(matx):\n    ### BEGIN SOLUTION\n    return matx[:2, 1:3]\n    ### END SOLUTION"}
{"task_id": "DSP/479", "completion": "def update_slice(matx):\n    ### BEGIN SOLUTION\n    matx[:2, 1:3] += 1000\n    return matx\n    ### END SOLUTION"}
{"task_id": "DSP/479", "completion": "def update_slice(matx):\n    ### BEGIN SOLUTION\n    matx[:2, 1:3] += 1000\n    return matx\n    ### END SOLUTION"}
{"task_id": "DSP/480", "completion": "def boolean_filter(matx):\n    ### BEGIN SOLUTION\n    return matx[matx<1.5]\n    ### END SOLUTION"}
{"task_id": "DSP/480", "completion": "def boolean_filter(matx):\n    ### BEGIN SOLUTION\n    return matx[matx<1.5]\n    ### END SOLUTION"}
{"task_id": "DSP/481", "completion": "def int_converter(matx):\n    ### BEGIN SOLUTION\n    return np.array(matx, dtype=np.int)\n    ### END SOLUTION"}
{"task_id": "DSP/481", "completion": "def int_converter(matx):\n    ### BEGIN SOLUTION\n    return np.array(matx, dtype=np.int)\n    ### END SOLUTION"}
{"task_id": "DSP/482", "completion": "def selective_replace(matx):\n    ### BEGIN SOLUTION\n    matx[matx % 2 == 0] = 55\n    ### END SOLUTION"}
{"task_id": "DSP/482", "completion": "def selective_replace(matx):\n    ### BEGIN SOLUTION\n    matx[matx % 2 == 0] = 55\n    ### END SOLUTION"}
{"task_id": "DSP/483", "completion": "def row_means(matx):\n    ### BEGIN SOLUTION\n    return matx.mean(axis = 1)\n    ### END SOLUTION"}
{"task_id": "DSP/483", "completion": "def row_means(matx):\n    ### BEGIN SOLUTION\n    return matx.mean(axis = 1)\n    ### END SOLUTION"}
{"task_id": "DSP/484", "completion": "def unique_finder(matx):\n    ### BEGIN SOLUTION\n    return np.unique(matx)\n    ### END SOLUTION"}
{"task_id": "DSP/484", "completion": "def unique_finder(matx):\n    ### BEGIN SOLUTION\n    return np.unique(matx)\n    ### END SOLUTION"}
{"task_id": "DSP/485", "completion": "def first_row_adder(matx):\n    ### BEGIN SOLUTION\n    return matx + matx[0,:]\n    ### END SOLUTION"}
{"task_id": "DSP/485", "completion": "def first_row_adder(matx):\n    ### BEGIN SOLUTION\n    return matx + matx[0,:]\n    ### END SOLUTION"}
{"task_id": "DSP/486", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/486", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)"}
{"task_id": "DSP/487", "completion": "dictionary = {}\nfor key, value in zip(var_a, var_b):\n    dictionary[key] = value\n    \ndictionary.items()"}
{"task_id": "DSP/487", "completion": "dictionary = {}\nfor key, value in zip(var_a, var_b):\n    dictionary[key] = value\n    \ndictionary.items()"}
{"task_id": "DSP/488", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, num in enumerate(lst):\n    if num % 2 == 0:\n        inds.append(index)"}
{"task_id": "DSP/488", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor index, num in enumerate(lst):\n    if num % 2 == 0:\n        inds.append(index)"}
{"task_id": "DSP/489", "completion": "def add2(num1, num2):\n    return num1 + num2"}
{"task_id": "DSP/489", "completion": "def add2(num1, num2):\n    return num1 + num2"}
{"task_id": "DSP/490", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nkey = 'a'\nfor index in range(len(dictionary)):\n    if dictionary[key] % 2 != 0:\n        dictionary[key] = add2(dictionary[key], 1)\n    key = chr(ord(key) + 1)\n    index = index + 1\n    \nother_dictionary = dictionary.items()"}
{"task_id": "DSP/490", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nkey = 'a'\nfor index in range(len(dictionary)):\n    if dictionary[key] % 2 != 0:\n        dictionary[key] = add2(dictionary[key], 1)\n    key = chr(ord(key) + 1)\n    index = index + 1\n    \nother_dictionary = dictionary.items()"}
{"task_id": "DSP/491", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/491", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/492", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/492", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/493", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/493", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/494", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/494", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/495", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/495", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/496", "completion": "def add2(num1, num2):\n    return num1 + num2"}
{"task_id": "DSP/496", "completion": "def add2(num1, num2):\n    return num1 + num2"}
{"task_id": "DSP/497", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/497", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/498", "completion": "MR_filepath='data/rt-polarity.tsv'\nMR_df = pd.read_csv(MR_filepath, sep='\\t',header=None)\nMR_df.columns = ['index', 'label', 'review']"}
{"task_id": "DSP/498", "completion": "MR_filepath='data/rt-polarity.tsv'\nMR_df = pd.read_csv(MR_filepath, sep='\\t',header=None)\nMR_df.columns = ['index', 'label', 'review']"}
{"task_id": "DSP/499", "completion": "def convert_label(label):\n    if label == 'pos':\n        return 1.0 \n    elif label == 'neg':\n        return 0.0\n    else: \n        return label"}
{"task_id": "DSP/499", "completion": "def convert_label(label):\n    if label == 'pos':\n        return 1.0 \n    elif label == 'neg':\n        return 0.0\n    else: \n        return label"}
{"task_id": "DSP/500", "completion": "MR_df['y']= MR_df['label'].apply(convert_label)"}
{"task_id": "DSP/500", "completion": "MR_df['y']= MR_df['label'].apply(convert_label)"}
{"task_id": "DSP/501", "completion": "vectorizer = CountVectorizer(analyzer ='word', max_features = 2000, tokenizer = word_tokenize, stop_words = stopwords.words('english'))"}
{"task_id": "DSP/501", "completion": "vectorizer = CountVectorizer(analyzer ='word', max_features = 2000, tokenizer = word_tokenize, stop_words = stopwords.words('english'))"}
{"task_id": "DSP/502", "completion": "MR_X = vectorizer.fit_transform(MR_df['review']).toarray()"}
{"task_id": "DSP/502", "completion": "MR_X = vectorizer.fit_transform(MR_df['review']).toarray()"}
{"task_id": "DSP/503", "completion": "MR_y = MR_df['y']"}
{"task_id": "DSP/503", "completion": "MR_y = MR_df['y']"}
{"task_id": "DSP/504", "completion": "num_training = int(len(MR_df.index) * .8) #16000\nnum_testing = int(len(MR_df.index) * .2) #1000"}
{"task_id": "DSP/504", "completion": "num_training = int(len(MR_df.index) * .8) #16000\nnum_testing = int(len(MR_df.index) * .2) #1000"}
{"task_id": "DSP/505", "completion": "MR_train_X = MR_X[:num_training] \nMR_train_y = MR_y[:num_training]\nMR_test_X = MR_X[num_training:]\nMR_test_y = MR_y[num_training:]"}
{"task_id": "DSP/505", "completion": "MR_train_X = MR_X[:num_training] \nMR_train_y = MR_y[:num_training]\nMR_test_X = MR_X[num_training:]\nMR_test_y = MR_y[num_training:]"}
{"task_id": "DSP/506", "completion": "def train_SVM(X, y, kernel='linear'):\n    clf = SVC(kernel=kernel)\n    clf.fit(X,y)\n    return clf"}
{"task_id": "DSP/506", "completion": "def train_SVM(X, y, kernel='linear'):\n    clf = SVC(kernel=kernel)\n    clf.fit(X,y)\n    return clf"}
{"task_id": "DSP/507", "completion": "MR_clf = train_SVM(MR_train_X, MR_train_y, kernel='linear')"}
{"task_id": "DSP/507", "completion": "MR_clf = train_SVM(MR_train_X, MR_train_y, kernel='linear')"}
{"task_id": "DSP/508", "completion": "tfidf = TfidfVectorizer(sublinear_tf = True, analyzer = 'word', max_features = 2000, tokenizer = word_tokenize)"}
{"task_id": "DSP/508", "completion": "tfidf = TfidfVectorizer(sublinear_tf = True, analyzer = 'word', max_features = 2000, tokenizer = word_tokenize)"}
{"task_id": "DSP/509", "completion": "MR_tfidf_X = tfidf.fit_transform(MR_df['review']).toarray()"}
{"task_id": "DSP/509", "completion": "MR_tfidf_X = tfidf.fit_transform(MR_df['review']).toarray()"}
{"task_id": "DSP/510", "completion": "MR_train_tfidf_X = MR_tfidf_X[:num_training]\nMR_train_tfidf_y = MR_y[:num_training] \nMR_test_tfidf_X = MR_tfidf_X[num_training:]\nMR_test_tfidf_y = MR_y[num_training:]"}
{"task_id": "DSP/510", "completion": "MR_train_tfidf_X = MR_tfidf_X[:num_training]\nMR_train_tfidf_y = MR_y[:num_training] \nMR_test_tfidf_X = MR_tfidf_X[num_training:]\nMR_test_tfidf_y = MR_y[num_training:]"}
{"task_id": "DSP/511", "completion": "MR_tfidf_clf = train_SVM(MR_train_tfidf_X, MR_train_y, kernel='linear')"}
{"task_id": "DSP/511", "completion": "MR_tfidf_clf = train_SVM(MR_train_tfidf_X, MR_train_y, kernel='linear')"}
{"task_id": "DSP/512", "completion": "CR_train_file='data/custrev_train.tsv'\nCR_test_file = 'data/custrev_test.tsv'\n\nCR_train_df = pd.read_csv(CR_train_file, sep='\\t',header=None)\nCR_train_df.columns = ['index', 'label', 'review']\n\nCR_test_df = pd.read_csv(CR_test_file, sep= '\\t', header=None)\nCR_test_df.columns = ['index', 'review']"}
{"task_id": "DSP/512", "completion": "CR_train_file='data/custrev_train.tsv'\nCR_test_file = 'data/custrev_test.tsv'\n\nCR_train_df = pd.read_csv(CR_train_file, sep='\\t',header=None)\nCR_train_df.columns = ['index', 'label', 'review']\n\nCR_test_df = pd.read_csv(CR_test_file, sep= '\\t', header=None)\nCR_test_df.columns = ['index', 'review']"}
{"task_id": "DSP/513", "completion": "dframes = [CR_train_df, CR_test_df]\nCR_df = pd.concat(dframes)"}
{"task_id": "DSP/513", "completion": "dframes = [CR_train_df, CR_test_df]\nCR_df = pd.concat(dframes)"}
{"task_id": "DSP/514", "completion": "CR_df['y']= CR_df['label'].apply(convert_label)"}
{"task_id": "DSP/514", "completion": "CR_df['y']= CR_df['label'].apply(convert_label)"}
{"task_id": "DSP/515", "completion": "CR_tfidf_X = tfidf.fit_transform(CR_df['review']).toarray()"}
{"task_id": "DSP/515", "completion": "CR_tfidf_X = tfidf.fit_transform(CR_df['review']).toarray()"}
{"task_id": "DSP/516", "completion": "CR_clf = train_SVM(CR_train_X, CR_train_y, kernel='linear')"}
{"task_id": "DSP/516", "completion": "CR_clf = train_SVM(CR_train_X, CR_train_y, kernel='linear')"}
{"task_id": "DSP/517", "completion": "CR_pred_test_y = CR_clf.predict(CR_test_X)"}
{"task_id": "DSP/517", "completion": "CR_pred_test_y = CR_clf.predict(CR_test_X)"}
{"task_id": "DSP/518", "completion": "label_lst = []\nfor index in CR_pred_test_y:\n    if index == 1.0:\n        label_lst.append('pos')\n    elif index == 0.0:\n        label_lst.append('neg')\n    else:\n        label_lst.append(index)\n        \nCR_test_df['label'] = label_lst"}
{"task_id": "DSP/518", "completion": "label_lst = []\nfor index in CR_pred_test_y:\n    if index == 1.0:\n        label_lst.append('pos')\n    elif index == 0.0:\n        label_lst.append('neg')\n    else:\n        label_lst.append(index)\n        \nCR_test_df['label'] = label_lst"}
{"task_id": "DSP/519", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/519", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/520", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/520", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/521", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/521", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/522", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/522", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/523", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/523", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/524", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/524", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/525", "completion": "assert hello('ENGLISh') == 'Hello, World!'           #uppercase"}
{"task_id": "DSP/525", "completion": "assert hello('ENGLISh') == 'Hello, World!'           #uppercase"}
{"task_id": "DSP/526", "completion": "bank_attributes_scaled = preprocessing.scale(bank_attributes)\nbank_attributes = pd.DataFrame(bank_attributes_scaled, columns = bank_attributes.columns)\nbank_attributes.head()"}
{"task_id": "DSP/526", "completion": "bank_attributes_scaled = preprocessing.scale(bank_attributes)\nbank_attributes = pd.DataFrame(bank_attributes_scaled, columns = bank_attributes.columns)\nbank_attributes.head()"}
{"task_id": "DSP/527", "completion": "bank_attributes_train, bank_attributes_test, bank_labels_train, bank_labels_test = train_test_split(\n    bank_attributes, bank_labels, train_size = 0.7, stratify = bank_labels)"}
{"task_id": "DSP/527", "completion": "bank_attributes_train, bank_attributes_test, bank_labels_train, bank_labels_test = train_test_split(\n    bank_attributes, bank_labels, train_size = 0.7, stratify = bank_labels)"}
{"task_id": "DSP/528", "completion": "k_fold = StratifiedKFold(n_splits = 5)"}
{"task_id": "DSP/528", "completion": "k_fold = StratifiedKFold(n_splits = 5)"}
{"task_id": "DSP/529", "completion": "best_classifier = \"tree\" # Replace empty string with \"tree\", \"forest\", \"linear SVM\" or \"gaussian SVM\""}
{"task_id": "DSP/529", "completion": "best_classifier = \"tree\" # Replace empty string with \"tree\", \"forest\", \"linear SVM\" or \"gaussian SVM\""}
{"task_id": "DSP/530", "completion": "bank_data = pd.read_csv(\"data/bank.csv\", sep = \";\")\nbank_data.head()"}
{"task_id": "DSP/530", "completion": "bank_data = pd.read_csv(\"data/bank.csv\", sep = \";\")\nbank_data.head()"}
{"task_id": "DSP/531", "completion": "bank_features = bank_data.drop(\"y\", axis = 1)\nbank_labels = bank_data.y.map({\n    'no': False,\n    'yes': True\n})\nbank_labels = bank_labels.astype(np.int64)"}
{"task_id": "DSP/531", "completion": "bank_features = bank_data.drop(\"y\", axis = 1)\nbank_labels = bank_data.y.map({\n    'no': False,\n    'yes': True\n})\nbank_labels = bank_labels.astype(np.int64)"}
{"task_id": "DSP/532", "completion": "bank_features = pd.get_dummies(bank_features)"}
{"task_id": "DSP/532", "completion": "bank_features = pd.get_dummies(bank_features)"}
{"task_id": "DSP/533", "completion": "train_test_split_result = train_test_split(bank_features, bank_labels, train_size = 0.7, stratify = bank_labels)\nbank_features_train = train_test_split_result[0]\nbank_features_test = train_test_split_result[1]\nbank_labels_train = train_test_split_result[2]\nbank_labels_test = train_test_split_result[3]"}
{"task_id": "DSP/533", "completion": "train_test_split_result = train_test_split(bank_features, bank_labels, train_size = 0.7, stratify = bank_labels)\nbank_features_train = train_test_split_result[0]\nbank_features_test = train_test_split_result[1]\nbank_labels_train = train_test_split_result[2]\nbank_labels_test = train_test_split_result[3]"}
{"task_id": "DSP/534", "completion": "model = LogisticRegression(C = 1e6)\nmodel.fit(bank_features_train, bank_labels_train)\nbaseline_score = model.score(bank_features_test, bank_labels_test)\nbaseline_score"}
{"task_id": "DSP/534", "completion": "model = LogisticRegression(C = 1e6)\nmodel.fit(bank_features_train, bank_labels_train)\nbaseline_score = model.score(bank_features_test, bank_labels_test)\nbaseline_score"}
{"task_id": "DSP/535", "completion": "bank_features_predicted = model.predict(bank_features_test)\nbaseline_score = f1_score(bank_labels_test, bank_features_predicted)\nprint(baseline_score)"}
{"task_id": "DSP/535", "completion": "bank_features_predicted = model.predict(bank_features_test)\nbaseline_score = f1_score(bank_labels_test, bank_features_predicted)\nprint(baseline_score)"}
{"task_id": "DSP/536", "completion": "tunned_params = [{\n    \"C\": [0.0001, 0.01, 0.1, 1, 10, 100, 10000],\n    \"max_iter\": [50, 100, 300, 1000],\n    \"fit_intercept\": [True, False]\n}]\ngrid_search = GridSearchCV(LogisticRegression(), tunned_params)\ngrid_search.fit(bank_features_train, bank_labels_train)"}
{"task_id": "DSP/536", "completion": "tunned_params = [{\n    \"C\": [0.0001, 0.01, 0.1, 1, 10, 100, 10000],\n    \"max_iter\": [50, 100, 300, 1000],\n    \"fit_intercept\": [True, False]\n}]\ngrid_search = GridSearchCV(LogisticRegression(), tunned_params)\ngrid_search.fit(bank_features_train, bank_labels_train)"}
{"task_id": "DSP/537", "completion": "MR_filepath='data/rt-polarity.tsv'\n\n# 1a) Import data\n#  Import the textfile 'rt-polarity.txt' into a DataFrame called MR_df,\nMR_df = pd.read_csv(MR_filepath, sep = '\\t', header = None)\n\n#   Set the column names as 'index', 'label', 'review'\n\nMR_df.columns = ['index','label','review']\n\n# Note that 'rt-polarity.txt' is a tab separated raw text file, in which data is separated by tabs ('\\t')\n#   You can load this file with 'read_csv':\n#     Specifying the 'sep' (separator) argument as tabs ('\\t')\n#     You will have the set 'header' as None"}
{"task_id": "DSP/537", "completion": "MR_filepath='data/rt-polarity.tsv'\n\n# 1a) Import data\n#  Import the textfile 'rt-polarity.txt' into a DataFrame called MR_df,\nMR_df = pd.read_csv(MR_filepath, sep = '\\t', header = None)\n\n#   Set the column names as 'index', 'label', 'review'\n\nMR_df.columns = ['index','label','review']\n\n# Note that 'rt-polarity.txt' is a tab separated raw text file, in which data is separated by tabs ('\\t')\n#   You can load this file with 'read_csv':\n#     Specifying the 'sep' (separator) argument as tabs ('\\t')\n#     You will have the set 'header' as None"}
{"task_id": "DSP/538", "completion": "def convert_label(label):\n# 1b) Create a function that converts string labels to numerical labels\n#   Function name: convert_label\n#   The function should do the following:\n#     if the input label is \"pos\" return 1.0\n    if( label == \"pos\"):\n        return 1.0\n\n#     if the input label is \"neg\" return 0.0\n    if( label == \"neg\"):\n        return 0.0\n    \n#     otherwise, return the input label as is\n    else:\n        return label"}
{"task_id": "DSP/538", "completion": "def convert_label(label):\n# 1b) Create a function that converts string labels to numerical labels\n#   Function name: convert_label\n#   The function should do the following:\n#     if the input label is \"pos\" return 1.0\n    if( label == \"pos\"):\n        return 1.0\n\n#     if the input label is \"neg\" return 0.0\n    if( label == \"neg\"):\n        return 0.0\n    \n#     otherwise, return the input label as is\n    else:\n        return label"}
{"task_id": "DSP/539", "completion": "MR_df[\"y\"] = MR_df[\"label\"].apply(convert_label)\n\n#  Save them as a new column named \"y\" in MR_df"}
{"task_id": "DSP/539", "completion": "MR_df[\"y\"] = MR_df[\"label\"].apply(convert_label)\n\n#  Save them as a new column named \"y\" in MR_df"}
{"task_id": "DSP/540", "completion": "vectorizer = CountVectorizer( analyzer = 'word' , max_features = 2000, tokenizer = word_tokenize , stop_words = stopwords.words('english') )\n\n# We need to pass 4 arguments to initialize a CountVectorizer:\n#   1. analyzer: 'word'\n#        Specify to analyze data from word-level\n#   2. max_features: 2000\n#        Set a max number of unique words\n#   3. tokenizer: word_tokenize\n#        Set to tokenize the text data by using the word_tokenizer from NLTK \n#   4. stop_words: stopwords.words('english')\n#        Set to remove all stopwords in English. \n#          We do this since they generally don't provide useful discriminative information."}
{"task_id": "DSP/540", "completion": "vectorizer = CountVectorizer( analyzer = 'word' , max_features = 2000, tokenizer = word_tokenize , stop_words = stopwords.words('english') )\n\n# We need to pass 4 arguments to initialize a CountVectorizer:\n#   1. analyzer: 'word'\n#        Specify to analyze data from word-level\n#   2. max_features: 2000\n#        Set a max number of unique words\n#   3. tokenizer: word_tokenize\n#        Set to tokenize the text data by using the word_tokenizer from NLTK \n#   4. stop_words: stopwords.words('english')\n#        Set to remove all stopwords in English. \n#          We do this since they generally don't provide useful discriminative information."}
{"task_id": "DSP/541", "completion": "MR_X = vectorizer.fit_transform(MR_df[\"review\"]).toarray()\n\n#   MR_X = vectorizer.fit_transform(...).toarray()\n#   Note that we apply the 'toarray' method at the type cast the output to a numpy array. \n#     This is something we will do multiple times, to turn custom sklearn objects back into arrays."}
{"task_id": "DSP/541", "completion": "MR_X = vectorizer.fit_transform(MR_df[\"review\"]).toarray()\n\n#   MR_X = vectorizer.fit_transform(...).toarray()\n#   Note that we apply the 'toarray' method at the type cast the output to a numpy array. \n#     This is something we will do multiple times, to turn custom sklearn objects back into arrays."}
{"task_id": "DSP/542", "completion": "MR_y = MR_df['y'].ravel()\n\n#   Make sure the shape of \"MR_y\" is (5000,) - you may have to use 'reshape' to do so."}
{"task_id": "DSP/542", "completion": "MR_y = MR_df['y'].ravel()\n\n#   Make sure the shape of \"MR_y\" is (5000,) - you may have to use 'reshape' to do so."}
{"task_id": "DSP/543", "completion": "training_d = (0.8) * len(MR_df.index) \nnum_training = int(training_d)\n\n# Calculate the number of test data samples (20% of total) and store it in \"num_testing\"\ntest_d = (0.2) * len(MR_df.index)\nnum_testing = int(test_d)\n\n# Make sure both of these variables are of type 'int'"}
{"task_id": "DSP/543", "completion": "training_d = (0.8) * len(MR_df.index) \nnum_training = int(training_d)\n\n# Calculate the number of test data samples (20% of total) and store it in \"num_testing\"\ntest_d = (0.2) * len(MR_df.index)\nnum_testing = int(test_d)\n\n# Make sure both of these variables are of type 'int'"}
{"task_id": "DSP/544", "completion": "MR_train_X = MR_X[0:num_training]\n\nMR_train_y = MR_y[0:num_training]\n\n#    You should use the 'num_training' variable to extract the data from MR_X and MR_y.\ntemp_variable = num_training + num_testing\n\n\n#      Extract the first 'num_training' samples as training data, and extract the rest as test data.\n#  Name them as:\nMR_test_X = MR_X[num_training: temp_variable]\n\nMR_test_y = MR_y[num_training: temp_variable]\n\n#    \"MR_train_X\" and \"MR_train_y\" for the training set\n#    \"MR_test_X\" and \"MR_test_y\" for the test set"}
{"task_id": "DSP/544", "completion": "MR_train_X = MR_X[0:num_training]\n\nMR_train_y = MR_y[0:num_training]\n\n#    You should use the 'num_training' variable to extract the data from MR_X and MR_y.\ntemp_variable = num_training + num_testing\n\n\n#      Extract the first 'num_training' samples as training data, and extract the rest as test data.\n#  Name them as:\nMR_test_X = MR_X[num_training: temp_variable]\n\nMR_test_y = MR_y[num_training: temp_variable]\n\n#    \"MR_train_X\" and \"MR_train_y\" for the training set\n#    \"MR_test_X\" and \"MR_test_y\" for the test set"}
{"task_id": "DSP/545", "completion": "def train_SVM(X, y, kernel='linear'):\n    \n# Hint: There are 2 steps involved in this function:\n#     1) Initializing an SVM classifier: clf = SVC(...)\n    clf = SVC( kernel = kernel)\n#     2) Training the classifier: clf.fit(X, y)\n    return clf.fit( X, y)"}
{"task_id": "DSP/545", "completion": "def train_SVM(X, y, kernel='linear'):\n    \n# Hint: There are 2 steps involved in this function:\n#     1) Initializing an SVM classifier: clf = SVC(...)\n    clf = SVC( kernel = kernel)\n#     2) Training the classifier: clf.fit(X, y)\n    return clf.fit( X, y)"}
{"task_id": "DSP/546", "completion": "MR_clf = train_SVM(MR_train_X,MR_train_y)\n\n#  Note that running this function may take many seconds / up to a few minutes to run."}
{"task_id": "DSP/546", "completion": "MR_clf = train_SVM(MR_train_X,MR_train_y)\n\n#  Note that running this function may take many seconds / up to a few minutes to run."}
{"task_id": "DSP/547", "completion": "tfidf = TfidfVectorizer(sublinear_tf = True, analyzer = 'word', max_features = 2000 , tokenizer = word_tokenize)\n\n#\n# We need to pass 4 arguments into the \"TfidfVectorizer\" to initialize a \"tfidf\":\n#   1. sublinear_tf: True\n#        Set to apply TF scaling.\n#   2. analyzer: 'word'\n#        Set to analyze the data at the word-level\n#   3. max_features: 2000\n#        Set the max number of unique words\n#   4. tokenizer: word_tokenize\n#        Set to tokenize the text data by using the word_tokenizer from NLTK"}
{"task_id": "DSP/547", "completion": "tfidf = TfidfVectorizer(sublinear_tf = True, analyzer = 'word', max_features = 2000 , tokenizer = word_tokenize)\n\n#\n# We need to pass 4 arguments into the \"TfidfVectorizer\" to initialize a \"tfidf\":\n#   1. sublinear_tf: True\n#        Set to apply TF scaling.\n#   2. analyzer: 'word'\n#        Set to analyze the data at the word-level\n#   3. max_features: 2000\n#        Set the max number of unique words\n#   4. tokenizer: word_tokenize\n#        Set to tokenize the text data by using the word_tokenizer from NLTK"}
{"task_id": "DSP/548", "completion": "MR_tfidf_X = tfidf.fit_transform(MR_df[\"review\"]).toarray()\n\n# Hint: You might need to cast the datatype of \"MR_tfidf_X\" to numpy.ndarray by using .toarray()"}
{"task_id": "DSP/548", "completion": "MR_tfidf_X = tfidf.fit_transform(MR_df[\"review\"]).toarray()\n\n# Hint: You might need to cast the datatype of \"MR_tfidf_X\" to numpy.ndarray by using .toarray()"}
{"task_id": "DSP/549", "completion": "MR_train_tfidf_X = MR_tfidf_X[0:num_training]\nMR_train_tfidf_y = MR_y[0:num_training]\n\n#    \"MR_test_tfidf_X\" and \"MR_test_tfidf_y\" for the test set\ntemp_value = num_training + num_testing\n\n#  We will use the same 80/20 split as in part 1. \n#    You can use the same 'num_training' variable from part 1 to split up the data.\nMR_test_tfidf_X = MR_tfidf_X[num_training:temp_value]\n\nMR_test_tfidf_y = MR_y[num_training:temp_value]"}
{"task_id": "DSP/549", "completion": "MR_train_tfidf_X = MR_tfidf_X[0:num_training]\nMR_train_tfidf_y = MR_y[0:num_training]\n\n#    \"MR_test_tfidf_X\" and \"MR_test_tfidf_y\" for the test set\ntemp_value = num_training + num_testing\n\n#  We will use the same 80/20 split as in part 1. \n#    You can use the same 'num_training' variable from part 1 to split up the data.\nMR_test_tfidf_X = MR_tfidf_X[num_training:temp_value]\n\nMR_test_tfidf_y = MR_y[num_training:temp_value]"}
{"task_id": "DSP/550", "completion": "MR_tfidf_clf = train_SVM(MR_train_tfidf_X,MR_train_tfidf_y)\n\n#   You need to call the function \"train_SVM\" you created in part 1.\n#   Name the returned object as \"MR_tfidf_clf\".\n#   Note that this may take many seconds, up to a few minutes, to run."}
{"task_id": "DSP/550", "completion": "MR_tfidf_clf = train_SVM(MR_train_tfidf_X,MR_train_tfidf_y)\n\n#   You need to call the function \"train_SVM\" you created in part 1.\n#   Name the returned object as \"MR_tfidf_clf\".\n#   Note that this may take many seconds, up to a few minutes, to run."}
{"task_id": "DSP/551", "completion": "CR_train_file='data/custrev_train.tsv'\nCR_test_file = 'data/custrev_test.tsv'\n\n# Import raw textfile 'data/custrev.train' into a DataFrame called CR_train_df,\nCR_train_df = pd.read_csv( CR_train_file , sep = '\\t' , header = None )\n\n#   Set the column names as 'index', 'label', 'review'\nCR_train_df.columns = ['index','label','review']\n\n# Import raw textfile 'data/custrev.test' into a DataFrame called CR_test_df,\nCR_test_df = pd.read_csv(CR_test_file,sep = '\\t',header = None)\n\n#   Set the column names as 'index', 'review'\nCR_test_df.columns = ['index','review']\n\n# Note that both will need to be imported with 'sep' and 'header' arguments (like in 1a)"}
{"task_id": "DSP/551", "completion": "CR_train_file='data/custrev_train.tsv'\nCR_test_file = 'data/custrev_test.tsv'\n\n# Import raw textfile 'data/custrev.train' into a DataFrame called CR_train_df,\nCR_train_df = pd.read_csv( CR_train_file , sep = '\\t' , header = None )\n\n#   Set the column names as 'index', 'label', 'review'\nCR_train_df.columns = ['index','label','review']\n\n# Import raw textfile 'data/custrev.test' into a DataFrame called CR_test_df,\nCR_test_df = pd.read_csv(CR_test_file,sep = '\\t',header = None)\n\n#   Set the column names as 'index', 'review'\nCR_test_df.columns = ['index','review']\n\n# Note that both will need to be imported with 'sep' and 'header' arguments (like in 1a)"}
{"task_id": "DSP/552", "completion": "CR_df = pd.concat([CR_train_df,CR_test_df])\n\n# YOUR CODE HERE"}
{"task_id": "DSP/552", "completion": "CR_df = pd.concat([CR_train_df,CR_test_df])\n\n# YOUR CODE HERE"}
{"task_id": "DSP/553", "completion": "CR_df['y'] = CR_df['label'].apply(convert_label)\n\n#   Save these numerical labels as a new column named \"y\" in CR_df."}
{"task_id": "DSP/553", "completion": "CR_df['y'] = CR_df['label'].apply(convert_label)\n\n#   Save these numerical labels as a new column named \"y\" in CR_df."}
{"task_id": "DSP/554", "completion": "CR_tfidf_X = tfidf.fit_transform(CR_df[\"review\"]).toarray()\n\n#  Save the transformed data into a variable called \"CR_tfidf_X\""}
{"task_id": "DSP/554", "completion": "CR_tfidf_X = tfidf.fit_transform(CR_df[\"review\"]).toarray()\n\n#  Save the transformed data into a variable called \"CR_tfidf_X\""}
{"task_id": "DSP/555", "completion": "CR_clf = train_SVM(CR_train_X,CR_train_y)\n\n\n\n#   Note that this function will take many seconds / up to a few minutes to run."}
{"task_id": "DSP/555", "completion": "CR_clf = train_SVM(CR_train_X,CR_train_y)\n\n\n\n#   Note that this function will take many seconds / up to a few minutes to run."}
{"task_id": "DSP/556", "completion": "CR_pred_test_y = CR_clf.predict(CR_test_X)\n\n\n# YOUR CODE HERE"}
{"task_id": "DSP/556", "completion": "CR_pred_test_y = CR_clf.predict(CR_test_X)\n\n\n# YOUR CODE HERE"}
{"task_id": "DSP/557", "completion": "toConvert = []\n\nfor y in CR_pred_test_y:\n\n\n    if( y != 1.0):\n     \n        toConvert.append('neg')\n \n    else:\n     \n        toConvert.append('pos')\n        \n\nCR_test_df[\"label\"] = toConvert\n\n# Create a column called \"label\" in \"CR_test_df\" to store the converted labels"}
{"task_id": "DSP/557", "completion": "toConvert = []\n\nfor y in CR_pred_test_y:\n\n\n    if( y != 1.0):\n     \n        toConvert.append('neg')\n \n    else:\n     \n        toConvert.append('pos')\n        \n\nCR_test_df[\"label\"] = toConvert\n\n# Create a column called \"label\" in \"CR_test_df\" to store the converted labels"}
{"task_id": "DSP/558", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/558", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/559", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/559", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/560", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\n# Define a tuple, called 'var_b', that contains the numbers 1-10 (inclusively).\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/560", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\n# Define a tuple, called 'var_b', that contains the numbers 1-10 (inclusively).\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/561", "completion": "dictionary = {}\nfor key, value in zip(var_a, var_b):\n    dictionary[key] = value\nprint(dictionary)"}
{"task_id": "DSP/561", "completion": "dictionary = {}\nfor key, value in zip(var_a, var_b):\n    dictionary[key] = value\nprint(dictionary)"}
{"task_id": "DSP/562", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n        \nfor i, v in enumerate(lst):\n        inds = [i for i, v in enumerate(lst) if v % 2 == 0]\nprint(inds)"}
{"task_id": "DSP/562", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n        \nfor i, v in enumerate(lst):\n        inds = [i for i, v in enumerate(lst) if v % 2 == 0]\nprint(inds)"}
{"task_id": "DSP/563", "completion": "def add2(x,y):\n    return(x + y)"}
{"task_id": "DSP/563", "completion": "def add2(x,y):\n    return(x + y)"}
{"task_id": "DSP/564", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nfor i, v in dictionary.items():\n    if v % 2 != 0:\n        new = add2(v,1)\n        other_dictionary[i] = new               #then add to other_dictionary\n    else:\n        other_dictionary[i] = v                 #then add to other_dictionary\n        \nprint(other_dictionary)"}
{"task_id": "DSP/564", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nfor i, v in dictionary.items():\n    if v % 2 != 0:\n        new = add2(v,1)\n        other_dictionary[i] = new               #then add to other_dictionary\n    else:\n        other_dictionary[i] = v                 #then add to other_dictionary\n        \nprint(other_dictionary)"}
{"task_id": "DSP/565", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/565", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/566", "completion": "sim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/566", "completion": "sim1 = np.random.poisson(t1_avg, n)\nsim2 = np.random.poisson(t2_avg, n)"}
{"task_id": "DSP/567", "completion": "def hat(x,a,b):\n    return (-a*x**2)+(b*x**4)"}
{"task_id": "DSP/567", "completion": "def hat(x,a,b):\n    return (-a*x**2)+(b*x**4)"}
{"task_id": "DSP/568", "completion": "def hat(x,a,b):\n    return (-a*x**2)+(b*x**4)"}
{"task_id": "DSP/568", "completion": "def hat(x,a,b):\n    return (-a*x**2)+(b*x**4)"}
{"task_id": "DSP/569", "completion": "data = np.genfromtxt('open_exoplanet_catalogue.txt', delimiter=',')\ntype(data)"}
{"task_id": "DSP/569", "completion": "data = np.genfromtxt('open_exoplanet_catalogue.txt', delimiter=',')\ntype(data)"}
{"task_id": "DSP/570", "completion": "data = np.loadtxt('yearssn.dat')\nyear = np.array(data[:,0])\nssc = np.array(data[:,1])"}
{"task_id": "DSP/570", "completion": "data = np.loadtxt('yearssn.dat')\nyear = np.array(data[:,0])\nssc = np.array(data[:,1])"}
{"task_id": "DSP/571", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    log_normals = np.array([])\n    Z = np.random.normal(0,1,size)\n    return np.exp(mu+sigma*Z)"}
{"task_id": "DSP/571", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    log_normals = np.array([])\n    Z = np.random.normal(0,1,size)\n    return np.exp(mu+sigma*Z)"}
{"task_id": "DSP/572", "completion": "def fair(data):\n    \"\"\"Compute the fraction of the tosses that have a value of `H`.\"\"\"\n    count = 0\n    for c in data:\n        if c == \"H\":\n            count += 1\n    return count/len(data)"}
{"task_id": "DSP/572", "completion": "def fair(data):\n    \"\"\"Compute the fraction of the tosses that have a value of `H`.\"\"\"\n    count = 0\n    for c in data:\n        if c == \"H\":\n            count += 1\n    return count/len(data)"}
{"task_id": "DSP/573", "completion": "def bootstrap_data(data):\n    \"\"\"Perform a single boostrap resampling of the input data array.\"\"\"\n    return np.array( [np.random.choice(data) for r in range(len(data))] )"}
{"task_id": "DSP/573", "completion": "def bootstrap_data(data):\n    \"\"\"Perform a single boostrap resampling of the input data array.\"\"\"\n    return np.array( [np.random.choice(data) for r in range(len(data))] )"}
{"task_id": "DSP/574", "completion": "def fair(data):\n    \"\"\"Compute the fraction of the tosses that have a value of `H`.\"\"\"\n    count = 0\n    for c in data:\n        if c == \"H\":\n            count += 1\n    return count/len(data)"}
{"task_id": "DSP/574", "completion": "def fair(data):\n    \"\"\"Compute the fraction of the tosses that have a value of `H`.\"\"\"\n    count = 0\n    for c in data:\n        if c == \"H\":\n            count += 1\n    return count/len(data)"}
{"task_id": "DSP/575", "completion": "def bootstrap_data(data):\n    \"\"\"Perform a single boostrap resampling of the input data array.\"\"\"\n    return np.array( [np.random.choice(data) for r in range(len(data))] )"}
{"task_id": "DSP/575", "completion": "def bootstrap_data(data):\n    \"\"\"Perform a single boostrap resampling of the input data array.\"\"\"\n    return np.array( [np.random.choice(data) for r in range(len(data))] )"}
{"task_id": "DSP/576", "completion": "data = np.loadtxt('yearssn.dat')\nyear = np.array(data[:,0])\nssc = np.array(data[:,1])"}
{"task_id": "DSP/576", "completion": "data = np.loadtxt('yearssn.dat')\nyear = np.array(data[:,0])\nssc = np.array(data[:,1])"}
{"task_id": "DSP/577", "completion": "data = np.genfromtxt('open_exoplanet_catalogue.txt', delimiter=',')\ntype(data)"}
{"task_id": "DSP/577", "completion": "data = np.genfromtxt('open_exoplanet_catalogue.txt', delimiter=',')\ntype(data)"}
{"task_id": "DSP/578", "completion": "def char_probs(s):\n    \"\"\"Find the probabilities of the unique characters in the string s.\n    \n    Parameters\n    ----------\n    s : str\n        A string of characters.\n    \n    Returns\n    -------\n    probs : dict\n        A dictionary whose keys are the unique characters in s and whose values\n        are the probabilities of those characters.\n    \"\"\"\n    checked = []\n    dic = {}\n    for i in s:\n        if i not in checked:\n            checked.append(i)\n            dic[i] = s.count(i)\n    print(dic)\n    for i in dic:\n        dic[i] = dic[i]/len(s)\n    dic_normal = dic\n    return(dic_normal)"}
{"task_id": "DSP/578", "completion": "def char_probs(s):\n    \"\"\"Find the probabilities of the unique characters in the string s.\n    \n    Parameters\n    ----------\n    s : str\n        A string of characters.\n    \n    Returns\n    -------\n    probs : dict\n        A dictionary whose keys are the unique characters in s and whose values\n        are the probabilities of those characters.\n    \"\"\"\n    checked = []\n    dic = {}\n    for i in s:\n        if i not in checked:\n            checked.append(i)\n            dic[i] = s.count(i)\n    print(dic)\n    for i in dic:\n        dic[i] = dic[i]/len(s)\n    dic_normal = dic\n    return(dic_normal)"}
{"task_id": "DSP/579", "completion": "def entropy(d):\n    \"\"\"Compute the entropy of a dict d whose values are probabilities.\"\"\"\n    # YOUR CODE HERE\n    values = list(d.values())\n    values = np.array(values)\n    return -(np.sum(values * np.log2(values)))"}
{"task_id": "DSP/579", "completion": "def entropy(d):\n    \"\"\"Compute the entropy of a dict d whose values are probabilities.\"\"\"\n    # YOUR CODE HERE\n    values = list(d.values())\n    values = np.array(values)\n    return -(np.sum(values * np.log2(values)))"}
{"task_id": "DSP/580", "completion": "def hat(x,a,b):\n    return (-a*x**2)+(b*x**4)"}
{"task_id": "DSP/580", "completion": "def hat(x,a,b):\n    return (-a*x**2)+(b*x**4)"}
{"task_id": "DSP/581", "completion": "L1 = None\n### BEGIN SOLUTION\nL1 = np.sum(np.abs(x))\n### END SOLUTION"}
{"task_id": "DSP/581", "completion": "L1 = None\n### BEGIN SOLUTION\nL1 = np.sum(np.abs(x))\n### END SOLUTION"}
{"task_id": "DSP/582", "completion": "eta = 1\nw = np.ones(N+1)*0\nhist  = [ ]\nOK = False\nfor k in range(35):\n    OK = True\n    for xi,yi in zip(x,y): \n\n    \n\n        if yi*w.dot(xi) <= 0:\n\n            w += 0\n### BEGIN SOLUTION        \n            w += eta*yi*xi\n### END SOLUTION        \n    \n            clear_output(wait=True)\n            plot(x,y,w,grid=100)\n            OK = False\n            #print(OK,np.sum([ y1*w.dot(xi) != 1 for xi,yi in zip(x,y)]))\n     \n        hist.append([k,*list(w)])\n    if OK:\n        print(\"OK(\",k,\") \",xi)\n        break\n        \nprint(OK,w)\n# from pprint import pprint \n# pprint(hist)"}
{"task_id": "DSP/582", "completion": "eta = 1\nw = np.ones(N+1)*0\nhist  = [ ]\nOK = False\nfor k in range(35):\n    OK = True\n    for xi,yi in zip(x,y): \n\n    \n\n        if yi*w.dot(xi) <= 0:\n\n            w += 0\n### BEGIN SOLUTION        \n            w += eta*yi*xi\n### END SOLUTION        \n    \n            clear_output(wait=True)\n            plot(x,y,w,grid=100)\n            OK = False\n            #print(OK,np.sum([ y1*w.dot(xi) != 1 for xi,yi in zip(x,y)]))\n     \n        hist.append([k,*list(w)])\n    if OK:\n        print(\"OK(\",k,\") \",xi)\n        break\n        \nprint(OK,w)\n# from pprint import pprint \n# pprint(hist)"}
{"task_id": "DSP/583", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot(x,y,w)\n\nfor k in range(5):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        if yi*np.sum(a*y*x.dot(xi)) <= 0:\n            a[i] += 0\n### BEGIN SOLUTION \n            \n            a[i] += 1\n### END SOLUTION        \n\n            w = np.dot(a*y,x)\n            clear_output(wait=True)\n            \n            plot(x,y,w)\n            \n            print(k,i,w,np.sum(w**2)) \n            time.sleep(0.2)\n            \n        if np.all(np.sign(x.dot(w)) == y):\n            break\n    if np.all(np.sign(x.dot(w)) == y):\n        break"}
{"task_id": "DSP/583", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot(x,y,w)\n\nfor k in range(5):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        if yi*np.sum(a*y*x.dot(xi)) <= 0:\n            a[i] += 0\n### BEGIN SOLUTION \n            \n            a[i] += 1\n### END SOLUTION        \n\n            w = np.dot(a*y,x)\n            clear_output(wait=True)\n            \n            plot(x,y,w)\n            \n            print(k,i,w,np.sum(w**2)) \n            time.sleep(0.2)\n            \n        if np.all(np.sign(x.dot(w)) == y):\n            break\n    if np.all(np.sign(x.dot(w)) == y):\n        break"}
{"task_id": "DSP/584", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot_dual(x,y,a)\n\nfor k in range(215):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        ### BEGIN SOLUTION \n\n        if yi*np.sum(a*y*(x.dot(xi))**2 ) <= 0:\n            a[i] += 1\n            clear_output(wait=True)\n            plot_dual(x,y,a,grid=85)\n            time.sleep(0.01)\n        ### END SOLUTION \n        pass"}
{"task_id": "DSP/584", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot_dual(x,y,a)\n\nfor k in range(215):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        ### BEGIN SOLUTION \n\n        if yi*np.sum(a*y*(x.dot(xi))**2 ) <= 0:\n            a[i] += 1\n            clear_output(wait=True)\n            plot_dual(x,y,a,grid=85)\n            time.sleep(0.01)\n        ### END SOLUTION \n        pass"}
{"task_id": "DSP/585", "completion": "dw1 = None\n\n### BEGIN SOLUTION\ndw1 = X[:,None]*( error*(y1*(1-y1)) )[None,:]\ndw1 = np.outer(X, error*(y1*(1-y1)) )\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/585", "completion": "dw1 = None\n\n### BEGIN SOLUTION\ndw1 = X[:,None]*( error*(y1*(1-y1)) )[None,:]\ndw1 = np.outer(X, error*(y1*(1-y1)) )\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/586", "completion": "db = None\n\n### BEGIN SOLUTION\ndb1 = error*(y1*(1-y1)) \n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/586", "completion": "db = None\n\n### BEGIN SOLUTION\ndb1 = error*(y1*(1-y1)) \n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/587", "completion": "dw1 = np.mean(X[:,:,None]*( error*(y1*(1-y1)) )[:,None,:],axis=0)\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/587", "completion": "dw1 = np.mean(X[:,:,None]*( error*(y1*(1-y1)) )[:,None,:],axis=0)\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/588", "completion": "db1 = None\n### BEGIN SOLUTION\ndb1 = np.mean(( error*(y1*(1-y1)) )[:,:],axis=0)\n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/588", "completion": "db1 = None\n### BEGIN SOLUTION\ndb1 = np.mean(( error*(y1*(1-y1)) )[:,:],axis=0)\n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/589", "completion": "X = None\n### BEGIN SOLUTION\nX = data['data'][data['labels']==1]\n### END SOLUTION"}
{"task_id": "DSP/589", "completion": "X = None\n### BEGIN SOLUTION\nX = data['data'][data['labels']==1]\n### END SOLUTION"}
{"task_id": "DSP/590", "completion": "m1,m2 = None,None\ns1,s2 = None,None\n\n### BEGIN SOLUTION\nm1,m2 = np.mean(X,axis=0)\ns1,s2 = np.std(X,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/590", "completion": "m1,m2 = None,None\ns1,s2 = None,None\n\n### BEGIN SOLUTION\nm1,m2 = np.mean(X,axis=0)\ns1,s2 = np.std(X,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/591", "completion": "class_means = np.array([[-3,  2],[-.19,  3]])\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/591", "completion": "class_means = np.array([[-3,  2],[-.19,  3]])\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/592", "completion": "t = 0\nw = np.array([0,1])\nd_lin = np.zeros_like(xx)\n### BEGIN SOLUTION\n\nw = class_means[1]-class_means[0]\nt = w.dot(0.5*(class_means[0]+class_means[1]))\n\nd_lin = (np.tensordot(w,np.stack([xx,yy]),axes=[0,0])-t)>0\n\n### END SOLUTION"}
{"task_id": "DSP/592", "completion": "t = 0\nw = np.array([0,1])\nd_lin = np.zeros_like(xx)\n### BEGIN SOLUTION\n\nw = class_means[1]-class_means[0]\nt = w.dot(0.5*(class_means[0]+class_means[1]))\n\nd_lin = (np.tensordot(w,np.stack([xx,yy]),axes=[0,0])-t)>0\n\n### END SOLUTION"}
{"task_id": "DSP/593", "completion": "Recall = None\n### BEGIN SOLUTION\nRecall = TP/(TP+FN)\n### END SOLUTION\nRecall, recall_score(actual,predicted)"}
{"task_id": "DSP/593", "completion": "Recall = None\n### BEGIN SOLUTION\nRecall = TP/(TP+FN)\n### END SOLUTION\nRecall, recall_score(actual,predicted)"}
{"task_id": "DSP/594", "completion": "Precision = None\n### BEGIN SOLUTION\nPrecision = TP/(TP+FP)\n### END SOLUTION"}
{"task_id": "DSP/594", "completion": "Precision = None\n### BEGIN SOLUTION\nPrecision = TP/(TP+FP)\n### END SOLUTION"}
{"task_id": "DSP/595", "completion": "Accuracy = None\n### BEGIN SOLUTION\nAccuracy = (TP+TN)/N, \n### END SOLUTION\n\n\naccuracy_score(actual,predicted)"}
{"task_id": "DSP/595", "completion": "Accuracy = None\n### BEGIN SOLUTION\nAccuracy = (TP+TN)/N, \n### END SOLUTION\n\n\naccuracy_score(actual,predicted)"}
{"task_id": "DSP/596", "completion": "km = None\n### BEGIN SOLUTION\nkm = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n### END SOLUTION"}
{"task_id": "DSP/596", "completion": "km = None\n### BEGIN SOLUTION\nkm = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n### END SOLUTION"}
{"task_id": "DSP/597", "completion": "c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n### END SOLUTION"}
{"task_id": "DSP/597", "completion": "c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n### END SOLUTION"}
{"task_id": "DSP/598", "completion": "SSE = None\n### BEGIN SOLUTION\nSSE   = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n### END SOLUTION"}
{"task_id": "DSP/598", "completion": "SSE = None\n### BEGIN SOLUTION\nSSE   = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n### END SOLUTION"}
{"task_id": "DSP/599", "completion": "for i in range(10):\n    km = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n\n    c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n    \n    SSE = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n    \n    print( SSE )\n    \n### END SOLUTION"}
{"task_id": "DSP/599", "completion": "for i in range(10):\n    km = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n\n    c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n    \n    SSE = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n    \n    print( SSE )\n    \n### END SOLUTION"}
{"task_id": "DSP/600", "completion": "s = None\n### BEGIN SOLUTION\ns = lambda x:1/(1+np.exp(-x))\n### END SOLUTION"}
{"task_id": "DSP/600", "completion": "s = None\n### BEGIN SOLUTION\ns = lambda x:1/(1+np.exp(-x))\n### END SOLUTION"}
{"task_id": "DSP/601", "completion": "W1,b1 = None,None\nW2,b2 = None,None\nW3,b3 = None,None\n\n### BEGIN SOLUTION\nW1,b1 = 0.1*1*np.ones((3,4)),0.2*1*np.ones(4)\nW2,b2 = 0.1*2*np.ones((4,2)),0.2*2*np.ones(2)\nW3,b3 = 0.1*3*np.ones((2,3)),0.2*3*np.ones(3)\n### END SOLUTION"}
{"task_id": "DSP/601", "completion": "W1,b1 = None,None\nW2,b2 = None,None\nW3,b3 = None,None\n\n### BEGIN SOLUTION\nW1,b1 = 0.1*1*np.ones((3,4)),0.2*1*np.ones(4)\nW2,b2 = 0.1*2*np.ones((4,2)),0.2*2*np.ones(2)\nW3,b3 = 0.1*3*np.ones((2,3)),0.2*3*np.ones(3)\n### END SOLUTION"}
{"task_id": "DSP/602", "completion": "y1 = None # Wyjscie z pierwszej warstwy\ny2 = None\ny3 = None\n\n\n### BEGIN SOLUTION\n\nz1 = X.dot(W1) + b1\ny1 = s(z1)\n\nz2 = y1.dot(W2) + b2\ny2 = s(z2)\n\nz3 = y2.dot(W3) + b3\ny3 = s(z3)\n\n### END SOLUTION"}
{"task_id": "DSP/602", "completion": "y1 = None # Wyjscie z pierwszej warstwy\ny2 = None\ny3 = None\n\n\n### BEGIN SOLUTION\n\nz1 = X.dot(W1) + b1\ny1 = s(z1)\n\nz2 = y1.dot(W2) + b2\ny2 = s(z2)\n\nz3 = y2.dot(W3) + b3\ny3 = s(z3)\n\n### END SOLUTION"}
{"task_id": "DSP/603", "completion": "w = None\n### BEGIN SOLUTION\nw = svm.coef_[0]\nt = svm.intercept_[0]\n### END SOLUTION"}
{"task_id": "DSP/603", "completion": "w = None\n### BEGIN SOLUTION\nw = svm.coef_[0]\nt = svm.intercept_[0]\n### END SOLUTION"}
{"task_id": "DSP/604", "completion": "classes = [2,3,4,5,6] # niepoprawne \n\n### BEGIN SOLUTION\nclasses = np.unique(y)\n### END SOLUTION"}
{"task_id": "DSP/604", "completion": "classes = [2,3,4,5,6] # niepoprawne \n\n### BEGIN SOLUTION\nclasses = np.unique(y)\n### END SOLUTION"}
{"task_id": "DSP/605", "completion": "Sw = None\n### BEGIN SOLUTION\nSw = sum([ np.cov(X[y==c_].T) for c_ in classes] )\n### END SOLUTION"}
{"task_id": "DSP/605", "completion": "Sw = None\n### BEGIN SOLUTION\nSw = sum([ np.cov(X[y==c_].T) for c_ in classes] )\n### END SOLUTION"}
{"task_id": "DSP/606", "completion": "mu = np.mean(X, axis=0)\nSc = None \n### BEGIN SOLUTION\nSc = sum( \n    np.sum(y==c_) * np.outer(np.mean(X[y==c_],axis=0)-mu,\n                             np.mean(X[y==c_],axis=0)-mu) \n    for c_ in classes)\n ### END SOLUTION"}
{"task_id": "DSP/606", "completion": "mu = np.mean(X, axis=0)\nSc = None \n### BEGIN SOLUTION\nSc = sum( \n    np.sum(y==c_) * np.outer(np.mean(X[y==c_],axis=0)-mu,\n                             np.mean(X[y==c_],axis=0)-mu) \n    for c_ in classes)\n ### END SOLUTION"}
{"task_id": "DSP/607", "completion": "lam, v = None, None\n### BEGIN SOLUTION\n\nlam, v = np.linalg.eig(np.linalg.inv(Sw).dot(Sc))\n                           \nlam = np.real_if_close(lam)\n\n### END SOLUTION                                     \n\nlam"}
{"task_id": "DSP/607", "completion": "lam, v = None, None\n### BEGIN SOLUTION\n\nlam, v = np.linalg.eig(np.linalg.inv(Sw).dot(Sc))\n                           \nlam = np.real_if_close(lam)\n\n### END SOLUTION                                     \n\nlam"}
{"task_id": "DSP/608", "completion": "idx = [1,2] # niepoprawne \n### BEGIN SOLUTION\n\nidx = np.argsort(lam)[-2:][::-1]\n\n### END SOLUTION"}
{"task_id": "DSP/608", "completion": "idx = [1,2] # niepoprawne \n### BEGIN SOLUTION\n\nidx = np.argsort(lam)[-2:][::-1]\n\n### END SOLUTION"}
{"task_id": "DSP/609", "completion": "W = None \n\n### BEGIN SOLUTION\nW = np.real_if_close(v[:,idx]).astype(np.float)\nW = W.T\n### END SOLUTION"}
{"task_id": "DSP/609", "completion": "W = None \n\n### BEGIN SOLUTION\nW = np.real_if_close(v[:,idx]).astype(np.float)\nW = W.T\n### END SOLUTION"}
{"task_id": "DSP/610", "completion": "n = 10\nalpha = 0.1\nw, b = 1, 0.1\nhist = []\nfor i in range(100):    \n\n    ith = [ 3,4  ] ## randomize!\n    x = None\n    y = None\n### BEGIN SOLUTION\n    ith = np.random.choice(m,n,replace=False)\n    x = x_orig[ith]\n    y = y_orig[ith]\n### END SOLUTION\n    \n    dw = 1/n*(w*x+b-y).dot(x)\n    db = 1/n*np.sum(w*x+b-y)\n\n    w = w - alpha*dw\n    b = b - alpha*db\n    \n    if i%10==0:\n        print(L(w,b),w,b,end='\\r')\n        l.set_data(xlin,w*xlin+b)\n        fig.canvas.draw()\n    hist.append(L(w,b))\n    #sleep(0.1)"}
{"task_id": "DSP/610", "completion": "n = 10\nalpha = 0.1\nw, b = 1, 0.1\nhist = []\nfor i in range(100):    \n\n    ith = [ 3,4  ] ## randomize!\n    x = None\n    y = None\n### BEGIN SOLUTION\n    ith = np.random.choice(m,n,replace=False)\n    x = x_orig[ith]\n    y = y_orig[ith]\n### END SOLUTION\n    \n    dw = 1/n*(w*x+b-y).dot(x)\n    db = 1/n*np.sum(w*x+b-y)\n\n    w = w - alpha*dw\n    b = b - alpha*db\n    \n    if i%10==0:\n        print(L(w,b),w,b,end='\\r')\n        l.set_data(xlin,w*xlin+b)\n        fig.canvas.draw()\n    hist.append(L(w,b))\n    #sleep(0.1)"}
{"task_id": "DSP/611", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/m*np.sum( (np.dot(X,w)+b-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/611", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/m*np.sum( (np.dot(X,w)+b-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/612", "completion": "w, b = np.ones(N), 0.1\n\n### BEGIN SOLUTION\ndw = 1/m*((np.dot(X,w)+b-y).dot(X)) #+ 0.0*w\ndb = 1/m*np.sum(np.dot(X,w)+b-y)\n### END SOLUTION\ndw,db"}
{"task_id": "DSP/612", "completion": "w, b = np.ones(N), 0.1\n\n### BEGIN SOLUTION\ndw = 1/m*((np.dot(X,w)+b-y).dot(X)) #+ 0.0*w\ndb = 1/m*np.sum(np.dot(X,w)+b-y)\n### END SOLUTION\ndw,db"}
{"task_id": "DSP/613", "completion": "Gini = None \n\n### BEGIN SOLUTION\n\nGini =  lambda Ni:1-sum(ni**2/sum(Ni)**2 for ni in Ni)\n\n### END SOLUTION"}
{"task_id": "DSP/613", "completion": "Gini = None \n\n### BEGIN SOLUTION\n\nGini =  lambda Ni:1-sum(ni**2/sum(Ni)**2 for ni in Ni)\n\n### END SOLUTION"}
{"task_id": "DSP/614", "completion": "Ni = [12,22]\nGini(Ni)"}
{"task_id": "DSP/614", "completion": "Ni = [12,22]\nGini(Ni)"}
{"task_id": "DSP/615", "completion": "Ni1, Ni2 = [11,2], [1,20]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/615", "completion": "Ni1, Ni2 = [11,2], [1,20]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/616", "completion": "Ni1,Ni2 = [6,11], [6,11]\n\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/616", "completion": "Ni1,Ni2 = [6,11], [6,11]\n\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/617", "completion": "Ni1,Ni2 = [10,10], [7,7]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/617", "completion": "Ni1,Ni2 = [10,10], [7,7]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/618", "completion": "C = np.cov(X.T)\n### END SOLUTION\nC"}
{"task_id": "DSP/618", "completion": "C = np.cov(X.T)\n### END SOLUTION\nC"}
{"task_id": "DSP/619", "completion": "def kowariancja(X):\n### BEGIN SOLUTION\n    m = np.mean(X,axis=0)\n    C = 1/(X.shape[0]-1)*np.dot( (X-m).T,X-m)\n    return C\n### END SOLUTION"}
{"task_id": "DSP/619", "completion": "def kowariancja(X):\n### BEGIN SOLUTION\n    m = np.mean(X,axis=0)\n    C = 1/(X.shape[0]-1)*np.dot( (X-m).T,X-m)\n    return C\n### END SOLUTION"}
{"task_id": "DSP/620", "completion": "C = None\n### BEGIN SOLUTION\nC = np.cov(Xorig.T)\n### END SOLUTION"}
{"task_id": "DSP/620", "completion": "C = None\n### BEGIN SOLUTION\nC = np.cov(Xorig.T)\n### END SOLUTION"}
{"task_id": "DSP/621", "completion": "class Network:\n    def __init__(self, inputs):\n        self.layers = []\n        self.numberOfInputs = inputs\n        self.numberOfLayers = 0\n        \n    def addLayer(self, neurons):\n        ### BEGIN SOLUTION\n        if self.numberOfLayers == 0:\n            self.layers.append(Layer(neurons, self.numberOfInputs))\n        else:\n            self.layers.append(Layer(neurons, self.layers[self.numberOfLayers - 1].numberOfNeurons))\n        self.numberOfLayers += 1\n        ### END SOLUTION\n        \n    def forward(self, inputVector):\n        ### BEGIN SOLUTION\n        tmp = inputVector\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[i].forward(tmp)\n        return tmp\n        ### END SOLUTION\n    \n    def backward(self, gradient):\n        ### BEGIN SOLUTION\n        tmp = gradient\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[self.numberOfLayers - 1 - i].backward(tmp)\n        return tmp\n        ### END SOLUTION\n            \n    def learn(self,learningRate):\n        ### BEGIN SOLUTION\n        for i in range(self.numberOfLayers):\n            self.layers[i].learn(learningRate)\n        ### END SOLUTION"}
{"task_id": "DSP/621", "completion": "class Network:\n    def __init__(self, inputs):\n        self.layers = []\n        self.numberOfInputs = inputs\n        self.numberOfLayers = 0\n        \n    def addLayer(self, neurons):\n        ### BEGIN SOLUTION\n        if self.numberOfLayers == 0:\n            self.layers.append(Layer(neurons, self.numberOfInputs))\n        else:\n            self.layers.append(Layer(neurons, self.layers[self.numberOfLayers - 1].numberOfNeurons))\n        self.numberOfLayers += 1\n        ### END SOLUTION\n        \n    def forward(self, inputVector):\n        ### BEGIN SOLUTION\n        tmp = inputVector\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[i].forward(tmp)\n        return tmp\n        ### END SOLUTION\n    \n    def backward(self, gradient):\n        ### BEGIN SOLUTION\n        tmp = gradient\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[self.numberOfLayers - 1 - i].backward(tmp)\n        return tmp\n        ### END SOLUTION\n            \n    def learn(self,learningRate):\n        ### BEGIN SOLUTION\n        for i in range(self.numberOfLayers):\n            self.layers[i].learn(learningRate)\n        ### END SOLUTION"}
{"task_id": "DSP/622", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/x.shape[0]*np.sum( (sigmoid(w*x+b)-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/622", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/x.shape[0]*np.sum( (sigmoid(w*x+b)-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/623", "completion": "dw, db = None, None\n\n### BEGIN SOLUTION\ndw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\ndb = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n### END SOLUTION"}
{"task_id": "DSP/623", "completion": "dw, db = None, None\n\n### BEGIN SOLUTION\ndw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\ndb = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n### END SOLUTION"}
{"task_id": "DSP/624", "completion": "dw_num, db_num = None, None\n\n### BEGIN SOLUTION\ndw_num = (L(w+0.001,b)-L(w,b))/0.001\ndb_num = (L(w,b+0.001)-L(w,b))/0.001\n### END SOLUTION"}
{"task_id": "DSP/624", "completion": "dw_num, db_num = None, None\n\n### BEGIN SOLUTION\ndw_num = (L(w+0.001,b)-L(w,b))/0.001\ndb_num = (L(w,b+0.001)-L(w,b))/0.001\n### END SOLUTION"}
{"task_id": "DSP/625", "completion": "alpha = 1.0\nw, b = 1., 3.\nfor i in range(100):\n    pass  \n### BEGIN SOLUTION\n    \n    dw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\n    db = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n    \n    w = w - alpha*dw\n    b = b - alpha*db\n### END SOLUTION\n    \nprint(L(w,b),w,b,dw,db)"}
{"task_id": "DSP/625", "completion": "alpha = 1.0\nw, b = 1., 3.\nfor i in range(100):\n    pass  \n### BEGIN SOLUTION\n    \n    dw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\n    db = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n    \n    w = w - alpha*dw\n    b = b - alpha*db\n### END SOLUTION\n    \nprint(L(w,b),w,b,dw,db)"}
{"task_id": "DSP/626", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n#metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n### END SOLUTION"}
{"task_id": "DSP/626", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n#metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n### END SOLUTION"}
{"task_id": "DSP/627", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/627", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/628", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/628", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/629", "completion": "class_means = None\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/629", "completion": "class_means = None\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/630", "completion": "def distances(x):\n    ### BEGIN SOLUTION\n    return np.stack([ np.sqrt(np.sum( (x - class_means[i])**2, axis=1)) for i in range(len(class_means)) ]).T\n    \n    ###END SOLUTION"}
{"task_id": "DSP/630", "completion": "def distances(x):\n    ### BEGIN SOLUTION\n    return np.stack([ np.sqrt(np.sum( (x - class_means[i])**2, axis=1)) for i in range(len(class_means)) ]).T\n    \n    ###END SOLUTION"}
{"task_id": "DSP/631", "completion": "def classify(x):\n    ### BEGIN SOLUTION\n    return np.argmin(distances(x), axis=1)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/631", "completion": "def classify(x):\n    ### BEGIN SOLUTION\n    return np.argmin(distances(x), axis=1)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/632", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test)==test_labels)/len(test_labels)\n    \n###END SOLUTION"}
{"task_id": "DSP/632", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test)==test_labels)/len(test_labels)\n    \n###END SOLUTION"}
{"task_id": "DSP/633", "completion": "class MinimumDistanceClassifier():\n    #wyznacza elementy reprezentatywne\n    def fit(self, train, train_labels):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    def fit(self, train, train_labels):\n        self.class_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) \\\n                                                              for i in np.unique(train_labels) ])\n    \n    def predict(self, test):\n        dists = np.stack([ np.sqrt(np.sum( (test - self.class_means[i])**2, axis=1)) \\\n                                                                  for i in range(len(self.class_means)) ]).T\n        return np.argmin(dists, axis=1)\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/633", "completion": "class MinimumDistanceClassifier():\n    #wyznacza elementy reprezentatywne\n    def fit(self, train, train_labels):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    def fit(self, train, train_labels):\n        self.class_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) \\\n                                                              for i in np.unique(train_labels) ])\n    \n    def predict(self, test):\n        dists = np.stack([ np.sqrt(np.sum( (test - self.class_means[i])**2, axis=1)) \\\n                                                                  for i in range(len(self.class_means)) ]).T\n        return np.argmin(dists, axis=1)\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/634", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n# metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n###END SOLUTION"}
{"task_id": "DSP/634", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n# metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n###END SOLUTION"}
{"task_id": "DSP/635", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/635", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/636", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/636", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/637", "completion": "def k_nearest_classes(x, k=1):\n    ### BEGIN SOLUTION\n    dists = distances(x)\n    if k==1:\n        return np.array[train_labels[np.argmin(dists)]]\n    return train_labels[np.argsort(dists)[:k]]\n    \n    ###END SOLUTION"}
{"task_id": "DSP/637", "completion": "def k_nearest_classes(x, k=1):\n    ### BEGIN SOLUTION\n    dists = distances(x)\n    if k==1:\n        return np.array[train_labels[np.argmin(dists)]]\n    return train_labels[np.argsort(dists)[:k]]\n    \n    ###END SOLUTION"}
{"task_id": "DSP/638", "completion": "def classify(x, k=1):\n    ### BEGIN SOLUTION\n    if len(x.shape)>1:\n        return np.array([np.bincount(k_nearest_classes(t, k)).argmax() for t in x])\n    return np.bincount(k_nearest_classes(x, k)).argmax()\n    \n    ###END SOLUTION"}
{"task_id": "DSP/638", "completion": "def classify(x, k=1):\n    ### BEGIN SOLUTION\n    if len(x.shape)>1:\n        return np.array([np.bincount(k_nearest_classes(t, k)).argmax() for t in x])\n    return np.bincount(k_nearest_classes(x, k)).argmax()\n    \n    ###END SOLUTION"}
{"task_id": "DSP/639", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test, k)==test_labels)/len(test_labels)    \n###END SOLUTION"}
{"task_id": "DSP/639", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test, k)==test_labels)/len(test_labels)    \n###END SOLUTION"}
{"task_id": "DSP/640", "completion": "class kNNClassifier():\n    def __init__(self, n_neighbors):\n        pass\n    #zapamietaj dane treningowe\n    def fit(self, train, train_labels):\n        pass\n    #metoda wyznaczjaca odleg\u0142o\u015bci\n    def distances(self, x):\n        pass\n    #znajd\u017a klasy k s\u0105siad\u00f3w\n    def kneighbors(self, x, k):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    \n    def __init__(self, n_neighbors):\n        self.k = n_neighbors\n        \n    def fit(self, train, train_labels):\n        self.train = train\n        self.train_labels = train_labels\n    \n    def distances(self, x):\n        return np.sqrt(np.sum( (x - self.train)**2, axis=1))\n        \n    def kneighbors(self, x, k):  \n        dists = self.distances(x)\n        if k==1:\n            return [self.train_labels[np.argmin(dists)]]\n        return self.train_labels[np.argsort(dists)[:k]]\n        \n    def predict(self, test):\n        if len(test.shape)>1:\n            return np.array([np.bincount(self.kneighbors(t, self.k)).argmax() for t in test])\n        return np.bincount(self.kneighbors(test, self.k)).argmax()\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/640", "completion": "class kNNClassifier():\n    def __init__(self, n_neighbors):\n        pass\n    #zapamietaj dane treningowe\n    def fit(self, train, train_labels):\n        pass\n    #metoda wyznaczjaca odleg\u0142o\u015bci\n    def distances(self, x):\n        pass\n    #znajd\u017a klasy k s\u0105siad\u00f3w\n    def kneighbors(self, x, k):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    \n    def __init__(self, n_neighbors):\n        self.k = n_neighbors\n        \n    def fit(self, train, train_labels):\n        self.train = train\n        self.train_labels = train_labels\n    \n    def distances(self, x):\n        return np.sqrt(np.sum( (x - self.train)**2, axis=1))\n        \n    def kneighbors(self, x, k):  \n        dists = self.distances(x)\n        if k==1:\n            return [self.train_labels[np.argmin(dists)]]\n        return self.train_labels[np.argsort(dists)[:k]]\n        \n    def predict(self, test):\n        if len(test.shape)>1:\n            return np.array([np.bincount(self.kneighbors(t, self.k)).argmax() for t in test])\n        return np.bincount(self.kneighbors(test, self.k)).argmax()\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/641", "completion": "def s1(a,b):\n    ### BEGIN SOLUTION\n    if(len(a) != len(b)):\n        raise ValueError(\"Given vectors should have the same length!.\")\n    return sum([i*j for i,j in zip(a,b)])\n    ### END SOLUTION\n\ndef s2(a,b):\n    ### BEGIN SOLUTION\n    return np.dot(a,b)\n    ### END SOLUTION"}
{"task_id": "DSP/641", "completion": "def s1(a,b):\n    ### BEGIN SOLUTION\n    if(len(a) != len(b)):\n        raise ValueError(\"Given vectors should have the same length!.\")\n    return sum([i*j for i,j in zip(a,b)])\n    ### END SOLUTION\n\ndef s2(a,b):\n    ### BEGIN SOLUTION\n    return np.dot(a,b)\n    ### END SOLUTION"}
{"task_id": "DSP/642", "completion": "def y1(A,x):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != x.shape[0]):\n        raise ValueError(\"Second dimension of matrix should be the same as dimension of vector!.\")\n    return([sum([i*j for i,j in zip(z,x)]) for z in A])\n    ### END SOLUTION \n\ndef y2(A,x):\n    ### BEGIN SOLUTION\n    return(np.array([np.dot(row,x) for row in A]))\n    ### END SOLUTION\n    \ndef y3(A,x):\n    ### BEGIN SOLUTION\n    return(np.dot(A,x))\n    #return(np.tensordot(A,x,[1,1,1],1)\n    ### END SOLUTION"}
{"task_id": "DSP/642", "completion": "def y1(A,x):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != x.shape[0]):\n        raise ValueError(\"Second dimension of matrix should be the same as dimension of vector!.\")\n    return([sum([i*j for i,j in zip(z,x)]) for z in A])\n    ### END SOLUTION \n\ndef y2(A,x):\n    ### BEGIN SOLUTION\n    return(np.array([np.dot(row,x) for row in A]))\n    ### END SOLUTION\n    \ndef y3(A,x):\n    ### BEGIN SOLUTION\n    return(np.dot(A,x))\n    #return(np.tensordot(A,x,[1,1,1],1)\n    ### END SOLUTION"}
{"task_id": "DSP/643", "completion": "def C1(A,B):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != np.shape(B)[0]):\n        raise ValueError(\"Second dimension of 1st matrix should be the same as first dimension of 2nd matrix!.\")\n    return(np.asarray([[sum([i*j for i,j in zip(z,B[:,f])]) for z in A] for f in range(np.shape(B)[1])]).T)\n    ### END SOLUTION\n    \ndef C2(A,B):\n    ### BEGIN SOLUTION\n    return(np.asarray([[s1(z,B[:,f]) for z in A] for f in range(np.shape(B)[1])]).T) \n    ### END SOLUTION\n    \ndef C3(A,B):\n    ### BEGIN SOLUTION\n    return(np.dot(A,B))\n    ### END SOLUTION"}
{"task_id": "DSP/643", "completion": "def C1(A,B):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != np.shape(B)[0]):\n        raise ValueError(\"Second dimension of 1st matrix should be the same as first dimension of 2nd matrix!.\")\n    return(np.asarray([[sum([i*j for i,j in zip(z,B[:,f])]) for z in A] for f in range(np.shape(B)[1])]).T)\n    ### END SOLUTION\n    \ndef C2(A,B):\n    ### BEGIN SOLUTION\n    return(np.asarray([[s1(z,B[:,f]) for z in A] for f in range(np.shape(B)[1])]).T) \n    ### END SOLUTION\n    \ndef C3(A,B):\n    ### BEGIN SOLUTION\n    return(np.dot(A,B))\n    ### END SOLUTION"}
{"task_id": "DSP/644", "completion": "def Tr(A):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[0] != np.shape(A)[1]):\n        raise ValueError('The matrix should be square matrix!.')\n    return(sum([A[p,p] for p in range(np.shape(A)[1])]))\n    ### END SOLUTION"}
{"task_id": "DSP/644", "completion": "def Tr(A):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[0] != np.shape(A)[1]):\n        raise ValueError('The matrix should be square matrix!.')\n    return(sum([A[p,p] for p in range(np.shape(A)[1])]))\n    ### END SOLUTION"}
{"task_id": "DSP/645", "completion": "def Le(A):\n    ### BEGIN SOLUTION\n    if A.shape == (1,1):\n        return A[0,0]\n    else:\n        j = 0\n        d = 0\n        for i in range(A.shape[0]):\n            M = np.concatenate( [np.concatenate( [A[:i,:j], A[:i,j+1:]], axis=1 ),\\\n                                 np.concatenate( [A[i+1:,:j], A[i+1:,j+1:]], axis=1 )],axis=0)\n            d += (-1)**(i+j)*A[i,j]*Le(M)\n        return d\n    ### END SOLUTION"}
{"task_id": "DSP/645", "completion": "def Le(A):\n    ### BEGIN SOLUTION\n    if A.shape == (1,1):\n        return A[0,0]\n    else:\n        j = 0\n        d = 0\n        for i in range(A.shape[0]):\n            M = np.concatenate( [np.concatenate( [A[:i,:j], A[:i,j+1:]], axis=1 ),\\\n                                 np.concatenate( [A[i+1:,:j], A[i+1:,j+1:]], axis=1 )],axis=0)\n            d += (-1)**(i+j)*A[i,j]*Le(M)\n        return d\n    ### END SOLUTION"}
{"task_id": "DSP/646", "completion": "import numpy as np\n### END SOLUTION"}
{"task_id": "DSP/646", "completion": "import numpy as np\n### END SOLUTION"}
{"task_id": "DSP/647", "completion": "v = np.zeros(10)\n### END SOLUTION"}
{"task_id": "DSP/647", "completion": "v = np.zeros(10)\n### END SOLUTION"}
{"task_id": "DSP/648", "completion": "def memof(a):\n### BEGIN SOLUTION\n    return  a.nbytes\n### END SOLUTION"}
{"task_id": "DSP/648", "completion": "def memof(a):\n### BEGIN SOLUTION\n    return  a.nbytes\n### END SOLUTION"}
{"task_id": "DSP/649", "completion": "def make_v(n):\n### BEGIN SOLUTION\n    v = np.zeros(n)\n    v[4] = 1\n    return v\n### END SOLUTION"}
{"task_id": "DSP/649", "completion": "def make_v(n):\n### BEGIN SOLUTION\n    v = np.zeros(n)\n    v[4] = 1\n    return v\n### END SOLUTION"}
{"task_id": "DSP/650", "completion": "def make10_49():\n### BEGIN SOLUTION\n    v = np.arange(10,50)\n    return v\n### END SOLUTION"}
{"task_id": "DSP/650", "completion": "def make10_49():\n### BEGIN SOLUTION\n    v = np.arange(10,50)\n    return v\n### END SOLUTION"}
{"task_id": "DSP/651", "completion": "def reverse(v):\n### BEGIN SOLUTION\n    return v[::-1]\n### END SOLUTION"}
{"task_id": "DSP/651", "completion": "def reverse(v):\n### BEGIN SOLUTION\n    return v[::-1]\n### END SOLUTION"}
{"task_id": "DSP/652", "completion": "def identity_matrix(n=3):\n### BEGIN SOLUTION\n    return np.eye(n)\n### END SOLUTION"}
{"task_id": "DSP/652", "completion": "def identity_matrix(n=3):\n### BEGIN SOLUTION\n    return np.eye(n)\n### END SOLUTION"}
{"task_id": "DSP/653", "completion": "def n2_col(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n)\n### END SOLUTION\ndef n2_row(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n).T\n### END SOLUTION"}
{"task_id": "DSP/653", "completion": "def n2_col(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n)\n### END SOLUTION\ndef n2_row(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n).T\n### END SOLUTION"}
{"task_id": "DSP/654", "completion": "def rand1(n=3, m=4):\n### BEGIN SOLUTION\n    return np.random.random((n,m))\n### END SOLUTION\ndef rand2(n=3, m=4, a=6, b=7):\n### BEGIN SOLUTION\n    return np.random.randint(a,b,size=(n,m))\n### END SOLUTION"}
{"task_id": "DSP/654", "completion": "def rand1(n=3, m=4):\n### BEGIN SOLUTION\n    return np.random.random((n,m))\n### END SOLUTION\ndef rand2(n=3, m=4, a=6, b=7):\n### BEGIN SOLUTION\n    return np.random.randint(a,b,size=(n,m))\n### END SOLUTION"}
{"task_id": "DSP/655", "completion": "def is_zero(x):\n### BEGIN SOLUTION\n    return np.where(x==0)[0]\n### END SOLUTION"}
{"task_id": "DSP/655", "completion": "def is_zero(x):\n### BEGIN SOLUTION\n    return np.where(x==0)[0]\n### END SOLUTION"}
{"task_id": "DSP/656", "completion": "def mystats(x):\n### BEGIN SOLUTION\n    return  np.nanmin(x),np.nanmax(x),np.nanmean(x)\n### END SOLUTION"}
{"task_id": "DSP/656", "completion": "def mystats(x):\n### BEGIN SOLUTION\n    return  np.nanmin(x),np.nanmax(x),np.nanmean(x)\n### END SOLUTION"}
{"task_id": "DSP/657", "completion": "def zeros_padded(n=4):\n### BEGIN SOLUTION\n    return  np.pad(np.zeros((n-2,n-2)),1,'constant',constant_values=1)\n### END SOLUTION"}
{"task_id": "DSP/657", "completion": "def zeros_padded(n=4):\n### BEGIN SOLUTION\n    return  np.pad(np.zeros((n-2,n-2)),1,'constant',constant_values=1)\n### END SOLUTION"}
{"task_id": "DSP/658", "completion": "def pad3(x):\n### BEGIN SOLUTION\n    return  np.pad(x,1,'constant',constant_values=3)\n### END SOLUTION"}
{"task_id": "DSP/658", "completion": "def pad3(x):\n### BEGIN SOLUTION\n    return  np.pad(x,1,'constant',constant_values=3)\n### END SOLUTION"}
{"task_id": "DSP/659", "completion": "def maxto0(x):\n### BEGIN SOLUTION\n    x = x.copy()\n    max_x = np.max(x)\n    x[x == max_x] = 0 \n    return  x\n### END SOLUTION"}
{"task_id": "DSP/659", "completion": "def maxto0(x):\n### BEGIN SOLUTION\n    x = x.copy()\n    max_x = np.max(x)\n    x[x == max_x] = 0 \n    return  x\n### END SOLUTION"}
{"task_id": "DSP/660", "completion": "def data_stats(x):\n### BEGIN SOLUTION\n    x_avg = np.sum(x,axis=0)/x.shape[0]\n    Delta = x - x_avg[np.newaxis,:]\n    sigma = np.sum((x - x_avg[np.newaxis,:])**2,axis=0)/x.shape[0]\n    return  x_avg,Delta,sigma\n### END SOLUTION"}
{"task_id": "DSP/660", "completion": "def data_stats(x):\n### BEGIN SOLUTION\n    x_avg = np.sum(x,axis=0)/x.shape[0]\n    Delta = x - x_avg[np.newaxis,:]\n    sigma = np.sum((x - x_avg[np.newaxis,:])**2,axis=0)/x.shape[0]\n    return  x_avg,Delta,sigma\n### END SOLUTION"}
{"task_id": "DSP/661", "completion": "Nlabels = None\n### BEGIN SOLUTION\nNlabels = np.unique(train_targets)\nNlabels\n### END SOLUTION"}
{"task_id": "DSP/661", "completion": "Nlabels = None\n### BEGIN SOLUTION\nNlabels = np.unique(train_targets)\nNlabels\n### END SOLUTION"}
{"task_id": "DSP/662", "completion": "correct = None\n### BEGIN SOLUTION\ncorrect = np.sum(Z==test_targets)/np.size(Z)\n### END SOLUTION"}
{"task_id": "DSP/662", "completion": "correct = None\n### BEGIN SOLUTION\ncorrect = np.sum(Z==test_targets)/np.size(Z)\n### END SOLUTION"}
{"task_id": "DSP/663", "completion": "p = None\n### BEGIN SOLUTION\np = [np.sum(train_targets==ith)/train_targets.shape[0] for ith in range(3) ]\n### END SOLUTION"}
{"task_id": "DSP/663", "completion": "p = None\n### BEGIN SOLUTION\np = [np.sum(train_targets==ith)/train_targets.shape[0] for ith in range(3) ]\n### END SOLUTION"}
{"task_id": "DSP/664", "completion": "mu = None\n### BEGIN SOLUTION\nmu = np.stack([np.mean(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/664", "completion": "mu = None\n### BEGIN SOLUTION\nmu = np.stack([np.mean(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/665", "completion": "sigma2 = None\n### BEGIN SOLUTION\nsigma2 = np.stack([np.var(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/665", "completion": "sigma2 = None\n### BEGIN SOLUTION\nsigma2 = np.stack([np.var(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/666", "completion": "prediction = None\n### BEGIN SOLUTION\nprediction = np.argmax(P,axis=1)\n### END SOLUTION"}
{"task_id": "DSP/666", "completion": "prediction = None\n### BEGIN SOLUTION\nprediction = np.argmax(P,axis=1)\n### END SOLUTION"}
{"task_id": "DSP/667", "completion": "from math import sqrt\n### END SOLUTION\n\ndef sqrt_initial(n2):\n    \"\"\"determine an approximate value for the square root of n2\n    \n       This function uses math.sqrt on the first 12 or 13 digits\n       of n2 for an even or odd number of digits of n2, respectively,\n       to obtain an integer approximation for the square root of n2.\n       The result can serve as an input for determining the square root\n       of an integer by means of Newton's method.\n    \n    \"\"\"\n    ### BEGIN SOLUTION\n    n2_str = str(n2)\n    nrdigits = len(n2_str)\n    keepdigits = 12 + (nrdigits % 2)\n    if keepdigits > nrdigits:\n        return int(sqrt(n2))\n    leadingdigits = n2_str[:keepdigits]\n    lead_sqrt_estimate = sqrt(float(leadingdigits))\n    return int(lead_sqrt_estimate)*10**((nrdigits-keepdigits)//2)\n    ### END SOLUTION"}
{"task_id": "DSP/667", "completion": "from math import sqrt\n### END SOLUTION\n\ndef sqrt_initial(n2):\n    \"\"\"determine an approximate value for the square root of n2\n    \n       This function uses math.sqrt on the first 12 or 13 digits\n       of n2 for an even or odd number of digits of n2, respectively,\n       to obtain an integer approximation for the square root of n2.\n       The result can serve as an input for determining the square root\n       of an integer by means of Newton's method.\n    \n    \"\"\"\n    ### BEGIN SOLUTION\n    n2_str = str(n2)\n    nrdigits = len(n2_str)\n    keepdigits = 12 + (nrdigits % 2)\n    if keepdigits > nrdigits:\n        return int(sqrt(n2))\n    leadingdigits = n2_str[:keepdigits]\n    lead_sqrt_estimate = sqrt(float(leadingdigits))\n    return int(lead_sqrt_estimate)*10**((nrdigits-keepdigits)//2)\n    ### END SOLUTION"}
{"task_id": "DSP/668", "completion": "def int_agm_iteration(a, b):\n    \"\"\"perform one arithmetic-geometric iteration for\n       a pair of integers\n    \n       This function takes two integers a and b as\n       a_n and b_n and returns a_{n+1}, b_{n+1},\n       and the difference of their squares.\n    \"\"\"\n    # BEGIN SOLUTION\n    a, b = (a+b)//2, int_sqrt(a*b, sqrt_initial(a*b))\n    c2 = a*a-b*b\n    return a, b, c2\n    # END SOLUTION"}
{"task_id": "DSP/668", "completion": "def int_agm_iteration(a, b):\n    \"\"\"perform one arithmetic-geometric iteration for\n       a pair of integers\n    \n       This function takes two integers a and b as\n       a_n and b_n and returns a_{n+1}, b_{n+1},\n       and the difference of their squares.\n    \"\"\"\n    # BEGIN SOLUTION\n    a, b = (a+b)//2, int_sqrt(a*b, sqrt_initial(a*b))\n    c2 = a*a-b*b\n    return a, b, c2\n    # END SOLUTION"}
{"task_id": "DSP/669", "completion": "def pi_agm_int(scale):\n    \"\"\"determine pi by means of the arithmetic-geometric mean\n       using integer arithmetic after expanding the fraction by\n       scale**2\n       \n       scale: numerator and denominator are expanded by the\n              square of this parameter, typically a power of ten\n    \"\"\"\n    ### BEGIN SOLUTION\n    a = scale\n    halfscaled = scale**2//2\n    b = int_sqrt(halfscaled, sqrt_initial(halfscaled))\n    denominator = scale**2\n    factor_two = 2\n    while a != b:\n        a, b, c2 = int_agm_iteration(a, b)\n        factor_two = 2*factor_two\n        denominator = denominator-factor_two*c2\n    numerator = 4*a**2\n    return numerator*scale//denominator\n    ### END SOLUTION"}
{"task_id": "DSP/669", "completion": "def pi_agm_int(scale):\n    \"\"\"determine pi by means of the arithmetic-geometric mean\n       using integer arithmetic after expanding the fraction by\n       scale**2\n       \n       scale: numerator and denominator are expanded by the\n              square of this parameter, typically a power of ten\n    \"\"\"\n    ### BEGIN SOLUTION\n    a = scale\n    halfscaled = scale**2//2\n    b = int_sqrt(halfscaled, sqrt_initial(halfscaled))\n    denominator = scale**2\n    factor_two = 2\n    while a != b:\n        a, b, c2 = int_agm_iteration(a, b)\n        factor_two = 2*factor_two\n        denominator = denominator-factor_two*c2\n    numerator = 4*a**2\n    return numerator*scale//denominator\n    ### END SOLUTION"}
{"task_id": "DSP/670", "completion": "def model(theta, total_bill):\n    \"\"\"\n    Takes the parameter theta and the total bill returns the computed tip.\n    \"\"\"\n    ...\n    return theta * total_bill"}
{"task_id": "DSP/670", "completion": "def model(theta, total_bill):\n    \"\"\"\n    Takes the parameter theta and the total bill returns the computed tip.\n    \"\"\"\n    ...\n    return theta * total_bill"}
{"task_id": "DSP/671", "completion": "loss = np.array([squared_loss(y, model(theta, x)).mean() for theta in thetas])\n\nplt.plot(thetas, loss);"}
{"task_id": "DSP/671", "completion": "loss = np.array([squared_loss(y, model(theta, x)).mean() for theta in thetas])\n\nplt.plot(thetas, loss);"}
{"task_id": "DSP/672", "completion": "import math\ndef abs_loss(y_obs, y_hat):\n    \"\"\"\n    y_obs: an array of observed valued\n    y_hat: an array of predicted values\n    return an array corresponding to the loss for each prediction\n    \"\"\"\n    ...\n    return abs(y_obs - y_hat)"}
{"task_id": "DSP/672", "completion": "import math\ndef abs_loss(y_obs, y_hat):\n    \"\"\"\n    y_obs: an array of observed valued\n    y_hat: an array of predicted values\n    return an array corresponding to the loss for each prediction\n    \"\"\"\n    ...\n    return abs(y_obs - y_hat)"}
{"task_id": "DSP/673", "completion": "def linear_model(x, theta):\n    \"\"\"\n    Returns the estimate of y given x and theta\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta -- the scalar theta\n    \"\"\"\n    y_hat = x * theta\n    return y_hat"}
{"task_id": "DSP/673", "completion": "def linear_model(x, theta):\n    \"\"\"\n    Returns the estimate of y given x and theta\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta -- the scalar theta\n    \"\"\"\n    y_hat = x * theta\n    return y_hat"}
{"task_id": "DSP/674", "completion": "def visualize(x, y, thetas):\n    \"\"\"\n    Plots the average l2 loss for given x, y as a function of theta.\n    Use the functions you wrote for linear_model and l2_loss.\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    thetas -- the vector containing different estimates of theta\n    \"\"\"\n    avg_loss = np.array([l2_loss(y, linear_model(x, theta)) for theta in thetas])\n    \n    plt.figure(figsize=(8,6))\n    \n    plt.plot(thetas, avg_loss, label = \"Average Squared Loss\")\n    plt.xlabel(\"Theta\")\n    plt.ylabel(\"Average Loss\")\n    \nthetas = np.linspace(-1, 5, 70)\nvisualize(x, y, thetas)\n\ntheta_star_guess = 1.5"}
{"task_id": "DSP/674", "completion": "def visualize(x, y, thetas):\n    \"\"\"\n    Plots the average l2 loss for given x, y as a function of theta.\n    Use the functions you wrote for linear_model and l2_loss.\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    thetas -- the vector containing different estimates of theta\n    \"\"\"\n    avg_loss = np.array([l2_loss(y, linear_model(x, theta)) for theta in thetas])\n    \n    plt.figure(figsize=(8,6))\n    \n    plt.plot(thetas, avg_loss, label = \"Average Squared Loss\")\n    plt.xlabel(\"Theta\")\n    plt.ylabel(\"Average Loss\")\n    \nthetas = np.linspace(-1, 5, 70)\nvisualize(x, y, thetas)\n\ntheta_star_guess = 1.5"}
{"task_id": "DSP/675", "completion": "def sin_model(x, theta_1, theta_2):\n    \"\"\"\n    Predict the estimate of y given x, theta_1, theta_2\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta_1 -- the scalar value theta_1\n    theta_2 -- the scalar value theta_2\n    \"\"\"\n    y_hat = theta_1 * x + np.sin(theta_2 * x)\n    return y_hat"}
{"task_id": "DSP/675", "completion": "def sin_model(x, theta_1, theta_2):\n    \"\"\"\n    Predict the estimate of y given x, theta_1, theta_2\n\n    Keyword arguments:\n    x -- the vector of values x\n    theta_1 -- the scalar value theta_1\n    theta_2 -- the scalar value theta_2\n    \"\"\"\n    y_hat = theta_1 * x + np.sin(theta_2 * x)\n    return y_hat"}
{"task_id": "DSP/676", "completion": "def grad_desc_decay(x, y, theta, num_iter=20, alpha=0.1):\n    \"\"\"\n    Run gradient descent update for a finite number of iterations and decaying learning rate\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    theta -- the vector of values theta\n    num_iter -- the max number of iterations\n    alpha -- the learning rate\n    \n    Return:\n    theta -- the optimal value of theta after num_iter of gradient descent\n    theta_history -- the series of theta values over each iteration of gradient descent\n    loss_history -- the series of loss values over each iteration of gradient descent\n    \"\"\"\n    theta_history = []\n    loss_history = []\n    \n    for i in range(num_iter):\n        theta_history.append(theta)\n        loss_history.append(l2_loss(y, sin_model(x, theta[0], theta[1])))\n        theta = theta - (alpha/(i+1))*(dt(x,y,theta))\n    return theta, theta_history, loss_history"}
{"task_id": "DSP/676", "completion": "def grad_desc_decay(x, y, theta, num_iter=20, alpha=0.1):\n    \"\"\"\n    Run gradient descent update for a finite number of iterations and decaying learning rate\n\n    Keyword arguments:\n    x -- the vector of values x\n    y -- the vector of values y\n    theta -- the vector of values theta\n    num_iter -- the max number of iterations\n    alpha -- the learning rate\n    \n    Return:\n    theta -- the optimal value of theta after num_iter of gradient descent\n    theta_history -- the series of theta values over each iteration of gradient descent\n    loss_history -- the series of loss values over each iteration of gradient descent\n    \"\"\"\n    theta_history = []\n    loss_history = []\n    \n    for i in range(num_iter):\n        theta_history.append(theta)\n        loss_history.append(l2_loss(y, sin_model(x, theta[0], theta[1])))\n        theta = theta - (alpha/(i+1))*(dt(x,y,theta))\n    return theta, theta_history, loss_history"}
{"task_id": "DSP/677", "completion": "X = babies[['gestation', 'smoke', 'height', 'weight']].copy()\nX.replace({\"smoke\": {\"smoker\": 1, \"non-smoker\": 0}},\n         inplace = True)"}
{"task_id": "DSP/677", "completion": "X = babies[['gestation', 'smoke', 'height', 'weight']].copy()\nX.replace({\"smoke\": {\"smoker\": 1, \"non-smoker\": 0}},\n         inplace = True)"}
{"task_id": "DSP/678", "completion": "y = babies[['bwt']]"}
{"task_id": "DSP/678", "completion": "y = babies[['bwt']]"}
{"task_id": "DSP/679", "completion": "from sklearn.linear_model import LinearRegression as lm\n\nmodel = lm()\nmodel.fit(X, y)\n\nprint(\"\"\"\nintercept: %.2f\ngestation: %.2f\nsmoke:     %.2f\nheight:    %.2f\nweight:    %.2f\n\"\"\" % (tuple([model.intercept_]) + tuple(model.coef_[0])))"}
{"task_id": "DSP/679", "completion": "from sklearn.linear_model import LinearRegression as lm\n\nmodel = lm()\nmodel.fit(X, y)\n\nprint(\"\"\"\nintercept: %.2f\ngestation: %.2f\nsmoke:     %.2f\nheight:    %.2f\nweight:    %.2f\n\"\"\" % (tuple([model.intercept_]) + tuple(model.coef_[0])))"}
{"task_id": "DSP/680", "completion": "def smoke_coeff(babies_array):\n    X = babies_array[:, 1:]\n    y = babies_array[:, 0]\n    \n    y = pd.Series(y).to_frame()\n\n    model = lm()\n    model.fit(X,y)\n    beta_smoke = model.coef_[0][1]\n\n    return beta_smoke\n\nbabies_array = babies\\\n.loc[:, [\"bwt\", \"gestation\", \"smoke\", \"height\", \"weight\"]]\\\n.replace({\"smoke\" : {\"non-smoker\":0, \"smoker\":1}}).values\n\nbeta_hat_sampling = bootstrap(babies_array, smoke_coeff)"}
{"task_id": "DSP/680", "completion": "def smoke_coeff(babies_array):\n    X = babies_array[:, 1:]\n    y = babies_array[:, 0]\n    \n    y = pd.Series(y).to_frame()\n\n    model = lm()\n    model.fit(X,y)\n    beta_smoke = model.coef_[0][1]\n\n    return beta_smoke\n\nbabies_array = babies\\\n.loc[:, [\"bwt\", \"gestation\", \"smoke\", \"height\", \"weight\"]]\\\n.replace({\"smoke\" : {\"non-smoker\":0, \"smoker\":1}}).values\n\nbeta_hat_sampling = bootstrap(babies_array, smoke_coeff)"}
{"task_id": "DSP/681", "completion": "left_confidence_interval_endpoint = np.percentile(beta_hat_sampling, 2.5)\nright_confidence_interval_endpoint = np.percentile(beta_hat_sampling, 97.5)\n\nleft_confidence_interval_endpoint, right_confidence_interval_endpoint"}
{"task_id": "DSP/681", "completion": "left_confidence_interval_endpoint = np.percentile(beta_hat_sampling, 2.5)\nright_confidence_interval_endpoint = np.percentile(beta_hat_sampling, 97.5)\n\nleft_confidence_interval_endpoint, right_confidence_interval_endpoint"}
{"task_id": "DSP/682", "completion": "def double100(nums):\n    i = 0\n    while i < len(nums):\n        if nums[i] == 100 and nums[i + 1] == 100:\n            print(\"True\")\n            return True\n        i += 1\n    print(\"False\")\n    return False"}
{"task_id": "DSP/682", "completion": "def double100(nums):\n    i = 0\n    while i < len(nums):\n        if nums[i] == 100 and nums[i + 1] == 100:\n            print(\"True\")\n            return True\n        i += 1\n    print(\"False\")\n    return False"}
{"task_id": "DSP/683", "completion": "v = np.array([2,1,4])\n\n# Fill in B\n# B = ...\n\nB = np.array([\n    [2, 2, 2],\n    [5, 8, 0],\n    [0, 2, 3],\n    [0, 0, 10],\n])\n\n# The notation B @ v means: compute the matrix multiplication Bv\nB @ v"}
{"task_id": "DSP/683", "completion": "v = np.array([2,1,4])\n\n# Fill in B\n# B = ...\n\nB = np.array([\n    [2, 2, 2],\n    [5, 8, 0],\n    [0, 2, 3],\n    [0, 0, 10],\n])\n\n# The notation B @ v means: compute the matrix multiplication Bv\nB @ v"}
{"task_id": "DSP/684", "completion": "x = np.array([80,80,100])\nnew_v = np.linalg.inv(A@B) @ x"}
{"task_id": "DSP/684", "completion": "x = np.array([80,80,100])\nnew_v = np.linalg.inv(A@B) @ x"}
{"task_id": "DSP/685", "completion": "bike['holiday'].replace([0, 1], ['no', 'yes'], inplace = True)\nbike['weekday'].replace([0, 1, 2, 3, 4, 5, 6], \n                        ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], inplace = True)\nbike['workingday'].replace([0, 1], ['no', 'yes'], inplace = True)\nbike['weathersit'].replace([0, 1, 2, 3], ['Clear', 'Mist', 'Light', 'Heavy'], inplace = True)\n\nbike.head()"}
{"task_id": "DSP/685", "completion": "bike['holiday'].replace([0, 1], ['no', 'yes'], inplace = True)\nbike['weekday'].replace([0, 1, 2, 3, 4, 5, 6], \n                        ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], inplace = True)\nbike['workingday'].replace([0, 1], ['no', 'yes'], inplace = True)\nbike['weathersit'].replace([0, 1, 2, 3], ['Clear', 'Mist', 'Light', 'Heavy'], inplace = True)\n\nbike.head()"}
{"task_id": "DSP/686", "completion": "num_holidays = bike[bike['holiday'] == 'yes'].shape[0]"}
{"task_id": "DSP/686", "completion": "num_holidays = bike[bike['holiday'] == 'yes'].shape[0]"}
{"task_id": "DSP/687", "completion": "bike['prop_casual'] = bike['casual'] / bike['cnt']"}
{"task_id": "DSP/687", "completion": "bike['prop_casual'] = bike['casual'] / bike['cnt']"}
{"task_id": "DSP/688", "completion": "m = 1000\nboot_pop = np.array(data[\"Grade\"])\n\nboot_sample_std = bootstrap(boot_pop, np.std, simple_resample, replicates = m)\nnp.mean(boot_sample_std) #std_mean = 8.7024\nnp.var(boot_sample_std) #std_var = 0.276\nnp.mean(boot_sample_means) #boot_mean = 80.487"}
{"task_id": "DSP/688", "completion": "m = 1000\nboot_pop = np.array(data[\"Grade\"])\n\nboot_sample_std = bootstrap(boot_pop, np.std, simple_resample, replicates = m)\nnp.mean(boot_sample_std) #std_mean = 8.7024\nnp.var(boot_sample_std) #std_var = 0.276\nnp.mean(boot_sample_means) #boot_mean = 80.487"}
{"task_id": "DSP/689", "completion": "def estimator(d):\n    \"\"\"\n    Args:\n        d: A n*2 array which contains x and y. d[:,0] would be x, d[:,1] would be y.\n        \n    Returns:\n        The optimal theta for this dataset under L2 loss.\n    \"\"\"\n    x = d[:,0]\n    y = d[:,1]\n    return np.sum(x*y) / np.sum(x**2)\nestimator(d)"}
{"task_id": "DSP/689", "completion": "def estimator(d):\n    \"\"\"\n    Args:\n        d: A n*2 array which contains x and y. d[:,0] would be x, d[:,1] would be y.\n        \n    Returns:\n        The optimal theta for this dataset under L2 loss.\n    \"\"\"\n    x = d[:,0]\n    y = d[:,1]\n    return np.sum(x*y) / np.sum(x**2)\nestimator(d)"}
{"task_id": "DSP/690", "completion": "replicates = 1000\nboot_theta = bootstrap(d, estimator, simple_resample, replicates)"}
{"task_id": "DSP/690", "completion": "replicates = 1000\nboot_theta = bootstrap(d, estimator, simple_resample, replicates)"}
{"task_id": "DSP/691", "completion": "t, W = wiener(1,1000)"}
{"task_id": "DSP/691", "completion": "t, W = wiener(1,1000)"}
{"task_id": "DSP/692", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    z = np.random.normal(0,1,size)\n    x = np.exp(mu + sigma* z)\n    return x"}
{"task_id": "DSP/692", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    z = np.random.normal(0,1,size)\n    x = np.exp(mu + sigma* z)\n    return x"}
{"task_id": "DSP/693", "completion": "def fit(X, Y):\n    \"\"\"Fit X and Y data to the model Y ~ m*X + b and return (m,b)\"\"\"\n    def line(x, a, b):\n        return a * x + b\n    mb,var_cov = (curve_fit(f=line,xdata=X,ydata=Y))\n    return (mb[0],mb[1])"}
{"task_id": "DSP/693", "completion": "def fit(X, Y):\n    \"\"\"Fit X and Y data to the model Y ~ m*X + b and return (m,b)\"\"\"\n    def line(x, a, b):\n        return a * x + b\n    mb,var_cov = (curve_fit(f=line,xdata=X,ydata=Y))\n    return (mb[0],mb[1])"}
{"task_id": "DSP/694", "completion": "def bootstrap(X, Y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    X: ndarray\n        Input X array.\n    Y: ndarray\n    \n    Returns\n    -------\n    XX: ndarray\n        The boostrapped X array with the same shape as X and correlated random samples\n        drawn with replacement.\n    YY: ndarray\n        The bootstrapped Y array with the same shape as Y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    XX = np.random.choice(X,len(X),replace=True)\n    YY = []\n    for i in XX:\n        j = (np.where(X==i)[0][0])\n        YY.append(Y[j])\n    return XX,YY"}
{"task_id": "DSP/694", "completion": "def bootstrap(X, Y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    X: ndarray\n        Input X array.\n    Y: ndarray\n    \n    Returns\n    -------\n    XX: ndarray\n        The boostrapped X array with the same shape as X and correlated random samples\n        drawn with replacement.\n    YY: ndarray\n        The bootstrapped Y array with the same shape as Y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    XX = np.random.choice(X,len(X),replace=True)\n    YY = []\n    for i in XX:\n        j = (np.where(X==i)[0][0])\n        YY.append(Y[j])\n    return XX,YY"}
{"task_id": "DSP/695", "completion": "def find_peaks(a):\n    \"\"\"Find the indices of the local maxima in a sequence.\"\"\"\n    n = len(a)\n    array = []\n    for i in range(n):\n        if i == 0:\n            if a[i] > a[i+1]:\n                array.append(i)\n        elif i == n-1:\n            if a[i] > a[i-1]:\n                array.append(i)\n        else:\n            if a[i] > a[i+1] and a[i] > a[i-1]:\n                array.append(i)\n    m = len(array)\n    np_array = np.empty(m)\n    for j in range(m):\n        np_array[j] = array[j]\n    return np_array"}
{"task_id": "DSP/695", "completion": "def find_peaks(a):\n    \"\"\"Find the indices of the local maxima in a sequence.\"\"\"\n    n = len(a)\n    array = []\n    for i in range(n):\n        if i == 0:\n            if a[i] > a[i+1]:\n                array.append(i)\n        elif i == n-1:\n            if a[i] > a[i-1]:\n                array.append(i)\n        else:\n            if a[i] > a[i+1] and a[i] > a[i-1]:\n                array.append(i)\n    m = len(array)\n    np_array = np.empty(m)\n    for j in range(m):\n        np_array[j] = array[j]\n    return np_array"}
{"task_id": "DSP/696", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = (3*sigma**2)**.5\n    a = mu - d\n    b = mu + d\n    uni = np.random.uniform(a,b,size)\n    return(uni)"}
{"task_id": "DSP/696", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = (3*sigma**2)**.5\n    a = mu - d\n    b = mu + d\n    uni = np.random.uniform(a,b,size)\n    return(uni)"}
{"task_id": "DSP/697", "completion": "def add2(a, b):\n    return a + b"}
{"task_id": "DSP/697", "completion": "def add2(a, b):\n    return a + b"}
{"task_id": "DSP/698", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/698", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/699", "completion": "def rotacion(\u03b8):\n    ### BEGIN SOLUTION HERE\n    from numpy import matrix, sin, cos\n    A = matrix([[cos(\u03b8), -sin(\u03b8)],\n                [sin(\u03b8), cos(\u03b8)]])\n    return A\n    ### END SOLUTION HERE"}
{"task_id": "DSP/699", "completion": "def rotacion(\u03b8):\n    ### BEGIN SOLUTION HERE\n    from numpy import matrix, sin, cos\n    A = matrix([[cos(\u03b8), -sin(\u03b8)],\n                [sin(\u03b8), cos(\u03b8)]])\n    return A\n    ### END SOLUTION HERE"}
{"task_id": "DSP/700", "completion": "from numpy import pi\n\u03c4 = 2*pi\n### BEGIN SOLUTION HERE\nA1 = rotacion(\u03c4*30/360)\nA2 = rotacion(\u03c4*50/360)\nA3 = rotacion(\u03c4*100/360)\n### END SOLUTION HERE"}
{"task_id": "DSP/700", "completion": "from numpy import pi\n\u03c4 = 2*pi\n### BEGIN SOLUTION HERE\nA1 = rotacion(\u03c4*30/360)\nA2 = rotacion(\u03c4*50/360)\nA3 = rotacion(\u03c4*100/360)\n### END SOLUTION HERE"}
{"task_id": "DSP/701", "completion": "vec = matrix([[2], [2]])\nres1 = A2@A3@A1@vec\n### END SOLUTION HERE"}
{"task_id": "DSP/701", "completion": "vec = matrix([[2], [2]])\nres1 = A2@A3@A1@vec\n### END SOLUTION HERE"}
{"task_id": "DSP/702", "completion": "vec = matrix([[2], [2]])\nres1 = A1@A3@A2@vec\n### END SOLUTION HERE"}
{"task_id": "DSP/702", "completion": "vec = matrix([[2], [2]])\nres1 = A1@A3@A2@vec\n### END SOLUTION HERE"}
{"task_id": "DSP/703", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);"}
{"task_id": "DSP/703", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);"}
{"task_id": "DSP/704", "completion": "x = 0;\ndictionary = {};\nwhile x<10:\n    dictionary[var_a[x]] = var_b[x];\n    x+=1;\nprint(dictionary);"}
{"task_id": "DSP/704", "completion": "x = 0;\ndictionary = {};\nwhile x<10:\n    dictionary[var_a[x]] = var_b[x];\n    x+=1;\nprint(dictionary);"}
{"task_id": "DSP/705", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n# YOUR CODE HERE\ni = 0;\nwhile i < len(lst):\n    x = lst[i]%2;\n    if x == 0:\n        inds.append(i);\n    i+=1;"}
{"task_id": "DSP/705", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n# YOUR CODE HERE\ni = 0;\nwhile i < len(lst):\n    x = lst[i]%2;\n    if x == 0:\n        inds.append(i);\n    i+=1;"}
{"task_id": "DSP/706", "completion": "def add2(varA, varB):\n    varC = varA + varB;\n    return varC;"}
{"task_id": "DSP/706", "completion": "def add2(varA, varB):\n    varC = varA + varB;\n    return varC;"}
{"task_id": "DSP/707", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n# YOUR CODE HERE\nfor key, value in dictionary.items():\n    if value%2 != 0:\n        value = add2(value, 1);\n    other_dictionary[key] = value;"}
{"task_id": "DSP/707", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n# YOUR CODE HERE\nfor key, value in dictionary.items():\n    if value%2 != 0:\n        value = add2(value, 1);\n    other_dictionary[key] = value;"}
{"task_id": "DSP/708", "completion": "import numpy as np;\nimport scipy as sp;\nimport pandas as pd;\nimport matplotlib.pyplot as plt;\nimport sklearn as skl;"}
{"task_id": "DSP/708", "completion": "import numpy as np;\nimport scipy as sp;\nimport pandas as pd;\nimport matplotlib.pyplot as plt;\nimport sklearn as skl;"}
{"task_id": "DSP/709", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/709", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/710", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/710", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/711", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/711", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/712", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/712", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/713", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/713", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/714", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/714", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/715", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/715", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/716", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/716", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/717", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)\n\nprint(var_a)\nprint(var_b)"}
{"task_id": "DSP/717", "completion": "var_a = ['a','b','c','d','e','f','g','h','i','j']\nvar_b = (1,2,3,4,5,6,7,8,9,10)\n\nprint(var_a)\nprint(var_b)"}
{"task_id": "DSP/718", "completion": "dictionary = dict(zip(var_a, var_b))\nprint(dictionary)"}
{"task_id": "DSP/718", "completion": "dictionary = dict(zip(var_a, var_b))\nprint(dictionary)"}
{"task_id": "DSP/719", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nelement = lst\nfor counter, value in enumerate(element):\n    if value % 2 == 0:\n        inds.insert(counter,value)\n        print(value)"}
{"task_id": "DSP/719", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nelement = lst\nfor counter, value in enumerate(element):\n    if value % 2 == 0:\n        inds.insert(counter,value)\n        print(value)"}
{"task_id": "DSP/720", "completion": "def add2(a,b):\n    return a + b"}
{"task_id": "DSP/720", "completion": "def add2(a,b):\n    return a + b"}
{"task_id": "DSP/721", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nfor key, value in dictionary.items():\n    if value % 2 != 0:\n        solve = add2(value,1)\n        other_dictionary = value + solve\n        print(solve)"}
{"task_id": "DSP/721", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nfor key, value in dictionary.items():\n    if value % 2 != 0:\n        solve = add2(value,1)\n        other_dictionary = value + solve\n        print(solve)"}
{"task_id": "DSP/722", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/722", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/723", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/723", "completion": "var_a = 'a b c d e f g h i j'.split(' ')\nvar_b = tuple(range(1, 11))\n### END SOLUTION"}
{"task_id": "DSP/724", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/724", "completion": "dictionary = dict()\nfor a, b in zip(var_a, var_b):\n    dictionary[a] = b\n# The following is also perfectly valid:\n# dictionary = dict(zip(var_a, var_b))\n### END SOLUTION"}
{"task_id": "DSP/725", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/725", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n### BEGIN SOLUTION\nfor ind, it in enumerate(lst):\n    if it % 2 == 0:\n        inds.append(ind)\n### END SOLUTION"}
{"task_id": "DSP/726", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/726", "completion": "def add2(a, b):\n    return a + b\n### END SOLUTION"}
{"task_id": "DSP/727", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/727", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n### BEGIN SOLUTION\nfor ke, va in dictionary.items():\n    if va % 2 != 0:\n        other_dictionary[ke] = add2(va, 1)\n    else:\n        other_dictionary[ke] = va\n### END SOLUTION"}
{"task_id": "DSP/728", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/728", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl\n### END SOLUTION"}
{"task_id": "DSP/729", "completion": "import numpy\n\ndef colebrook(epsilon, D, Re):\n    \n    return\n\n### BEGIN SOLUTION\ndef colebrook(epsilon, D, Re):\n    f = 0.02\n    for _ in range(1000):\n        old_f = f\n        f = (1/(-2*numpy.log10((epsilon/D)/3.7 + 2.51/(Re*numpy.sqrt(f)))))**2\n        if abs(old_f - f) < 1e-10:\n            break\n    \n    return f\n\n### END SOLUTION"}
{"task_id": "DSP/729", "completion": "import numpy\n\ndef colebrook(epsilon, D, Re):\n    \n    return\n\n### BEGIN SOLUTION\ndef colebrook(epsilon, D, Re):\n    f = 0.02\n    for _ in range(1000):\n        old_f = f\n        f = (1/(-2*numpy.log10((epsilon/D)/3.7 + 2.51/(Re*numpy.sqrt(f)))))**2\n        if abs(old_f - f) < 1e-10:\n            break\n    \n    return f\n\n### END SOLUTION"}
{"task_id": "DSP/730", "completion": "def pressuresystem(P_u, m):\n    \n    return \n\n### BEGIN SOLUTION\ndef pressuresystem(P_u, m):\n    rho = m/V\n    Re = 1700 * rho\n    f = colebrook(epsilon, D, Re)\n    P = m*R*T/(M*V)\n    F_i = W*(P_u - P)\n    F_o = f*L*(P - P_a)\n    dmdt = F_i - F_o\n\n    return dmdt\n### END SOLUTION"}
{"task_id": "DSP/730", "completion": "def pressuresystem(P_u, m):\n    \n    return \n\n### BEGIN SOLUTION\ndef pressuresystem(P_u, m):\n    rho = m/V\n    Re = 1700 * rho\n    f = colebrook(epsilon, D, Re)\n    P = m*R*T/(M*V)\n    F_i = W*(P_u - P)\n    F_o = f*L*(P - P_a)\n    dmdt = F_i - F_o\n\n    return dmdt\n### END SOLUTION"}
{"task_id": "DSP/731", "completion": "import scipy.optimize\n\nP_u = 200\n\n### BEGIN SOLUTION\n# Solve for steady state\ndef steady(m):\n    return pressuresystem(P_u, m)\n\nm0 = scipy.optimize.fsolve(steady, 30)\nm0 = m0[0]\n### END SOLUTION"}
{"task_id": "DSP/731", "completion": "import scipy.optimize\n\nP_u = 200\n\n### BEGIN SOLUTION\n# Solve for steady state\ndef steady(m):\n    return pressuresystem(P_u, m)\n\nm0 = scipy.optimize.fsolve(steady, 30)\nm0 = m0[0]\n### END SOLUTION"}
{"task_id": "DSP/732", "completion": "def cvder(y, tau, zeta, Kf, Ps):\n    return \n\n### BEGIN SOLUTION   \ndef cvder(y, tau, zeta, Kf, Ps):\n    return [y[1], \n            tau**-2*(Kf*(Ps - 20) - 2*tau*zeta*y[1] - y[0])]\n### END SOLUTION"}
{"task_id": "DSP/732", "completion": "def cvder(y, tau, zeta, Kf, Ps):\n    return \n\n### BEGIN SOLUTION   \ndef cvder(y, tau, zeta, Kf, Ps):\n    return [y[1], \n            tau**-2*(Kf*(Ps - 20) - 2*tau*zeta*y[1] - y[0])]\n### END SOLUTION"}
{"task_id": "DSP/733", "completion": "Kf = 1 # use this variable name\n\n### BEGIN SOLUTION\nKf = (1 - 0)/(100 - 20)\n\n### END SOLUTION"}
{"task_id": "DSP/733", "completion": "Kf = 1 # use this variable name\n\n### BEGIN SOLUTION\nKf = (1 - 0)/(100 - 20)\n\n### END SOLUTION"}
{"task_id": "DSP/734", "completion": "Ps = 1 # use this variable for your answer (same name)\n### BEGIN SOLUTION\nx = 0.7\nPs = x/Kf + 20\n\n### END SOLUTION"}
{"task_id": "DSP/734", "completion": "Ps = 1 # use this variable for your answer (same name)\n### BEGIN SOLUTION\nx = 0.7\nPs = x/Kf + 20\n\n### END SOLUTION"}
{"task_id": "DSP/735", "completion": "mpg_data = pd.read_csv('auto-mpg.data',sep='\\s+', header=None, names=['mpg','cylinders','displacement','horsepower','weight','acceleration','model_year','origin','car_name'])"}
{"task_id": "DSP/735", "completion": "mpg_data = pd.read_csv('auto-mpg.data',sep='\\s+', header=None, names=['mpg','cylinders','displacement','horsepower','weight','acceleration','model_year','origin','car_name'])"}
{"task_id": "DSP/736", "completion": "mpg_data['horsepower']=mpg_data['horsepower'].replace('?',np.nan)\nmpg_data['horsepower']=mpg_data['horsepower'].astype('float64')\n#mpg_data.dtypes"}
{"task_id": "DSP/736", "completion": "mpg_data['horsepower']=mpg_data['horsepower'].replace('?',np.nan)\nmpg_data['horsepower']=mpg_data['horsepower'].astype('float64')\n#mpg_data.dtypes"}
{"task_id": "DSP/737", "completion": "mpg_data=mpg_data.dropna(subset=['horsepower'])"}
{"task_id": "DSP/737", "completion": "mpg_data=mpg_data.dropna(subset=['horsepower'])"}
{"task_id": "DSP/738", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    car_names = None\n    aRank=dataframe['cylinders'].rank(method='min')\n    df_rank=pd.concat([dataframe,aRank], axis=1)\n    df_rank=df_rank[df_rank.iloc[:,-1] < 2]\n    car_names=df_rank['car_name']\n    return car_names"}
{"task_id": "DSP/738", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    car_names = None\n    aRank=dataframe['cylinders'].rank(method='min')\n    df_rank=pd.concat([dataframe,aRank], axis=1)\n    df_rank=df_rank[df_rank.iloc[:,-1] < 2]\n    car_names=df_rank['car_name']\n    return car_names"}
{"task_id": "DSP/739", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    correlation=dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/739", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    correlation=dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/740", "completion": "page1 = imread(\"images//page1.jpg\")\npage2 = imread(\"images//page2.jpg\")\n#plt.figure(figsize = (10, 8))\n#page1.size(100, 100)\nplt.imshow(page1)\nplt.imshow(page2)\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/740", "completion": "page1 = imread(\"images//page1.jpg\")\npage2 = imread(\"images//page2.jpg\")\n#plt.figure(figsize = (10, 8))\n#page1.size(100, 100)\nplt.imshow(page1)\nplt.imshow(page2)\n# YOUR CODE HERE\n#raise NotImplementedError()"}
{"task_id": "DSP/741", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\ndef concatenate_images(images):\n    \"\"\"\n    Concatenates all images vertically (one below the other)\n    \"\"\"\n    images = resize_images(images)\n    concat_images = np.concatenate(images, axis=0)\n    return concat_images\n    #raise NotImplementedError()"}
{"task_id": "DSP/741", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\ndef concatenate_images(images):\n    \"\"\"\n    Concatenates all images vertically (one below the other)\n    \"\"\"\n    images = resize_images(images)\n    concat_images = np.concatenate(images, axis=0)\n    return concat_images\n    #raise NotImplementedError()"}
{"task_id": "DSP/742", "completion": "menu_content = \"\"\nwith open('output/menu.txt', 'r') as myfile:\n    menu_content=myfile.read()\n# print(type(menu_content))\nprint(menu_content)"}
{"task_id": "DSP/742", "completion": "menu_content = \"\"\nwith open('output/menu.txt', 'r') as myfile:\n    menu_content=myfile.read()\n# print(type(menu_content))\nprint(menu_content)"}
{"task_id": "DSP/743", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    df_meals=pd.read_csv(StringIO(meals_string), sep='|', header=None, names=[\"category\",\"meal_name\",\"price\"])\n    df_meals[\"category\"]=df_meals[\"category\"].str.lower()\n    return df_meals"}
{"task_id": "DSP/743", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    df_meals=pd.read_csv(StringIO(meals_string), sep='|', header=None, names=[\"category\",\"meal_name\",\"price\"])\n    df_meals[\"category\"]=df_meals[\"category\"].str.lower()\n    return df_meals"}
{"task_id": "DSP/744", "completion": "num_items_total = meals_table.shape[0]\nnum_categories_total = meals_table.category.nunique()\nnum_items_by_category = meals_table.groupby('category').meal_name.count()\nmean_price_by_category = meals_table.groupby('category').price.mean()"}
{"task_id": "DSP/744", "completion": "num_items_total = meals_table.shape[0]\nnum_categories_total = meals_table.category.nunique()\nnum_items_by_category = meals_table.groupby('category').meal_name.count()\nmean_price_by_category = meals_table.groupby('category').price.mean()"}
{"task_id": "DSP/745", "completion": "failed_student_times = np.random.uniform(1, 3, 12)\npassed_student_times = np.random.uniform(7, 10, 8)\nall_times = np.concatenate([failed_student_times, passed_student_times])\n#all_times\nexam_zeros = np.zeros(12)\nexam_ones = np.ones(8)\nexam_result = np.concatenate([exam_zeros, exam_ones ])\nexam_result\n# # raise NotImplementedError()"}
{"task_id": "DSP/745", "completion": "failed_student_times = np.random.uniform(1, 3, 12)\npassed_student_times = np.random.uniform(7, 10, 8)\nall_times = np.concatenate([failed_student_times, passed_student_times])\n#all_times\nexam_zeros = np.zeros(12)\nexam_ones = np.ones(8)\nexam_result = np.concatenate([exam_zeros, exam_ones ])\nexam_result\n# # raise NotImplementedError()"}
{"task_id": "DSP/746", "completion": "all_times = np.random.uniform(1, 10, 20)\nexam_result = np.array([])\n\nfor item in all_times:\n    if item <= 3:\n        hours = 0\n#         exam_result=np.append(exam_result, [hours])\n    elif item >=7:\n        hours = 1\n#         exam_result = np.append(exam_result, [hours])\n    elif item>3 and item<7:\n        hours = np.random.random()\n        if hours >= 0.5:\n            hours=1\n#             exam_result = np.append(exam_result, [hours])\n        else:\n            hours=0\n#             exam_result = np.append(exam_result, [hours])\n    exam_result = np.append(exam_result, [hours])\n            \nexam_result\n        \n# hours = np.random.random()\n# hours\n# YOUR CODE HERE\n# raise NotImplementedError()"}
{"task_id": "DSP/746", "completion": "all_times = np.random.uniform(1, 10, 20)\nexam_result = np.array([])\n\nfor item in all_times:\n    if item <= 3:\n        hours = 0\n#         exam_result=np.append(exam_result, [hours])\n    elif item >=7:\n        hours = 1\n#         exam_result = np.append(exam_result, [hours])\n    elif item>3 and item<7:\n        hours = np.random.random()\n        if hours >= 0.5:\n            hours=1\n#             exam_result = np.append(exam_result, [hours])\n        else:\n            hours=0\n#             exam_result = np.append(exam_result, [hours])\n    exam_result = np.append(exam_result, [hours])\n            \nexam_result\n        \n# hours = np.random.random()\n# hours\n# YOUR CODE HERE\n# raise NotImplementedError()"}
{"task_id": "DSP/747", "completion": "def error_0(x):\n    error0=-np.log(1 - x)\n    \n#     if x==1:\n#         error0 = math.inf\n#     else:\n#         error0=-np.log(1 - x)\n#         np.all(x)\n#         error0 = -(math.log(1-x, np.e))\n        \n    return error0\n\ndef error_1(x):\n    error1=-np.log(x)\n#     if x==0:\n#         error1 = math.inf\n#     else:\n#         error1=-np.log(x)\n#         error1=-(math.log(x, np.e))\n    return error1\n\n# error_0 = -(math.log(1-(-10), np.e))\n# error_1 = -(math.log(-10, np.e))\n# error_1\n\n# test = math.inf\n# test >0\n\n# if x==1:\n#     error_0 = math.inf\n# else:\n#     error_0 = -(math.log(1-x, np.e))\n\n\n# test = -0.0 == 0.0\n# test\n# error_0=-(np.log([0, np.e]))\n# type(error_0[0])\n# sigmoid_values = np.linspace(0, 1, 1000)\n# sigmoid_values\n# error_1=-(np.log(0))\n# error_1"}
{"task_id": "DSP/747", "completion": "def error_0(x):\n    error0=-np.log(1 - x)\n    \n#     if x==1:\n#         error0 = math.inf\n#     else:\n#         error0=-np.log(1 - x)\n#         np.all(x)\n#         error0 = -(math.log(1-x, np.e))\n        \n    return error0\n\ndef error_1(x):\n    error1=-np.log(x)\n#     if x==0:\n#         error1 = math.inf\n#     else:\n#         error1=-np.log(x)\n#         error1=-(math.log(x, np.e))\n    return error1\n\n# error_0 = -(math.log(1-(-10), np.e))\n# error_1 = -(math.log(-10, np.e))\n# error_1\n\n# test = math.inf\n# test >0\n\n# if x==1:\n#     error_0 = math.inf\n# else:\n#     error_0 = -(math.log(1-x, np.e))\n\n\n# test = -0.0 == 0.0\n# test\n# error_0=-(np.log([0, np.e]))\n# type(error_0[0])\n# sigmoid_values = np.linspace(0, 1, 1000)\n# sigmoid_values\n# error_1=-(np.log(0))\n# error_1"}
{"task_id": "DSP/748", "completion": "income_data = pd.read_csv('adult.data.csv',header=None, names=['age','workclass','final_weight','education','education_number','marital_status','occupation','relationship','race','sex','capital_gain','capital_loss','hours_per_week','native_country','income_class'])"}
{"task_id": "DSP/748", "completion": "income_data = pd.read_csv('adult.data.csv',header=None, names=['age','workclass','final_weight','education','education_number','marital_status','occupation','relationship','race','sex','capital_gain','capital_loss','hours_per_week','native_country','income_class'])"}
{"task_id": "DSP/749", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    dataframe_people_with_higher_gain=dataframe[dataframe['capital_gain']>=threshold_gain]\n    count=dataframe_people_with_higher_gain.shape[0]\n    return count"}
{"task_id": "DSP/749", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    dataframe_people_with_higher_gain=dataframe[dataframe['capital_gain']>=threshold_gain]\n    count=dataframe_people_with_higher_gain.shape[0]\n    return count"}
{"task_id": "DSP/750", "completion": "def most_prominent_marital_status(dataframe):\n    status = \"\"\n    num_people = 0\n    dataframe['marital_status']=dataframe['marital_status'].str.strip()\n    income_data_marital_status=dataframe.groupby('marital_status').size().reset_index(name='counts')\n    income_data_marital_status=income_data_marital_status.sort_values('counts',ascending=False).reset_index()\n    status=income_data_marital_status.iloc[0,1]\n    num_people=income_data_marital_status.iloc[0,2]\n    return (status, num_people)"}
{"task_id": "DSP/750", "completion": "def most_prominent_marital_status(dataframe):\n    status = \"\"\n    num_people = 0\n    dataframe['marital_status']=dataframe['marital_status'].str.strip()\n    income_data_marital_status=dataframe.groupby('marital_status').size().reset_index(name='counts')\n    income_data_marital_status=income_data_marital_status.sort_values('counts',ascending=False).reset_index()\n    status=income_data_marital_status.iloc[0,1]\n    num_people=income_data_marital_status.iloc[0,2]\n    return (status, num_people)"}
{"task_id": "DSP/751", "completion": "def get_num_people_by_age_category(dataframe):\n    young, middle_aged, old = (0, 0, 0)\n    young = dataframe[dataframe['age']<=30].shape[0]\n    middle_aged = dataframe[(dataframe['age']>30) & (dataframe['age']<=60)].shape[0]\n    old = dataframe[dataframe['age']>60].shape[0]\n    return young, middle_aged, old"}
{"task_id": "DSP/751", "completion": "def get_num_people_by_age_category(dataframe):\n    young, middle_aged, old = (0, 0, 0)\n    young = dataframe[dataframe['age']<=30].shape[0]\n    middle_aged = dataframe[(dataframe['age']>30) & (dataframe['age']<=60)].shape[0]\n    old = dataframe[dataframe['age']>60].shape[0]\n    return young, middle_aged, old"}
{"task_id": "DSP/752", "completion": "def get_second_highest_num_people(dataframe):\n    num_people, country = 0, \"\"\n    dataframe['native_country']=dataframe['native_country'].str.strip()\n    income_data_second_highest_num_people=dataframe.groupby('native_country').size().reset_index(name='counts')\n    income_data_second_highest_num_people=income_data_second_highest_num_people.sort_values('counts',ascending=False)\n    num_people=income_data_second_highest_num_people.iloc[1,1]\n    country=income_data_second_highest_num_people.iloc[1,0]\n    return num_people, country"}
{"task_id": "DSP/752", "completion": "def get_second_highest_num_people(dataframe):\n    num_people, country = 0, \"\"\n    dataframe['native_country']=dataframe['native_country'].str.strip()\n    income_data_second_highest_num_people=dataframe.groupby('native_country').size().reset_index(name='counts')\n    income_data_second_highest_num_people=income_data_second_highest_num_people.sort_values('counts',ascending=False)\n    num_people=income_data_second_highest_num_people.iloc[1,1]\n    country=income_data_second_highest_num_people.iloc[1,0]\n    return num_people, country"}
{"task_id": "DSP/753", "completion": "def get_mean_working_hours_by_income(dataframe):\n    df_OccupationMean=dataframe.groupby('occupation').mean() \n    df_OccupationMean=df_OccupationMean.sort_values('hours_per_week',ascending=False).reset_index()\n    df_OccupationMean=df_OccupationMean[['occupation','hours_per_week']]\n    df_OccupationMean['occupation']=df_OccupationMean['occupation'].str.strip()\n    dict_result=pd.Series(df_OccupationMean.hours_per_week.values,index=df_OccupationMean.occupation).to_dict()\n    return dict_result"}
{"task_id": "DSP/753", "completion": "def get_mean_working_hours_by_income(dataframe):\n    df_OccupationMean=dataframe.groupby('occupation').mean() \n    df_OccupationMean=df_OccupationMean.sort_values('hours_per_week',ascending=False).reset_index()\n    df_OccupationMean=df_OccupationMean[['occupation','hours_per_week']]\n    df_OccupationMean['occupation']=df_OccupationMean['occupation'].str.strip()\n    dict_result=pd.Series(df_OccupationMean.hours_per_week.values,index=df_OccupationMean.occupation).to_dict()\n    return dict_result"}
{"task_id": "DSP/754", "completion": "titanic_data = None\ntitanic_data = pd.read_csv('data/titanic.csv',\n                           index_col='PassengerId',\n                           names=['PassengerId','Survived','Class','Name','Sex','Age','SibSp','ParCh',\n                                  'Ticket','Fare','Cabin','Embarked'],\n                           skiprows=1)\ntitanic_data.Embarked=titanic_data[\"Embarked\"].fillna('N')\ntitanic_data.Embarked=titanic_data.Embarked.apply(lambda s: s.replace('C', 'Cherbourg'))\ntitanic_data.Embarked=titanic_data.Embarked.apply(lambda s: s.replace('Q', 'Queenstown'))\ntitanic_data.Embarked=titanic_data.Embarked.apply(lambda s: s.replace('S', 'Southampton'))\ntitanic_data.Embarked=titanic_data.Embarked.replace('N',np.NaN)\n\n# df[\"new\"]=df_s\n# df_s.new=df.Embarked.apply(lambda s: s.replace('S', 'Southampton'))"}
{"task_id": "DSP/754", "completion": "titanic_data = None\ntitanic_data = pd.read_csv('data/titanic.csv',\n                           index_col='PassengerId',\n                           names=['PassengerId','Survived','Class','Name','Sex','Age','SibSp','ParCh',\n                                  'Ticket','Fare','Cabin','Embarked'],\n                           skiprows=1)\ntitanic_data.Embarked=titanic_data[\"Embarked\"].fillna('N')\ntitanic_data.Embarked=titanic_data.Embarked.apply(lambda s: s.replace('C', 'Cherbourg'))\ntitanic_data.Embarked=titanic_data.Embarked.apply(lambda s: s.replace('Q', 'Queenstown'))\ntitanic_data.Embarked=titanic_data.Embarked.apply(lambda s: s.replace('S', 'Southampton'))\ntitanic_data.Embarked=titanic_data.Embarked.replace('N',np.NaN)\n\n# df[\"new\"]=df_s\n# df_s.new=df.Embarked.apply(lambda s: s.replace('S', 'Southampton'))"}
{"task_id": "DSP/755", "completion": "most_common_port = None\nss_embarked=titanic_data.groupby(\"Embarked\").size()\nmost_common_port=ss_embarked.sort_values().tail(1).index[0]\ntitanic_data.Embarked=titanic_data[\"Embarked\"].fillna(most_common_port)"}
{"task_id": "DSP/755", "completion": "most_common_port = None\nss_embarked=titanic_data.groupby(\"Embarked\").size()\nmost_common_port=ss_embarked.sort_values().tail(1).index[0]\ntitanic_data.Embarked=titanic_data[\"Embarked\"].fillna(most_common_port)"}
{"task_id": "DSP/756", "completion": "all_ages = None\nnum_passengers_by_sex = None\nall_fares = None\n\n# all_ages=titanic_data.groupby(\"Age\").size()\nall_ages, bins_ages = np.histogram(titanic_data.groupby(\"Age\").size(), bins=20)\nnum_passengers_by_sex=titanic_data.groupby(\"Sex\").size()\nall_fares, bins_fares = np.histogram(titanic_data.groupby(\"Fare\").size(), bins=20)\n\n# all_ages\n# len(all_fares)\n\n# assert_equal(len(all_ages), len(all_fares))\n\n# width = (bins_ages[1] - bins_ages[0])\n# center = (bins_ages[:-1] + bins_ages[1:]) / 2\n# plt.bar(center, all_ages, align = \"center\", width = width)\n# plt.show()\n\nplt.hist(all_ages, bins = 20)\nplt.title(\"Distribution of ages\")\nplt.show()\n\nplt.gca().set_aspect(\"equal\")\nplt.pie(num_passengers_by_sex, labels = num_passengers_by_sex.index, autopct = \"%.2f%%\")\nplt.title(\"Passengers per sex\")\nplt.show()\n\nplt.hist(all_fares, bins = 20)\nplt.title(\"Distribution of fares\")\nplt.show()"}
{"task_id": "DSP/756", "completion": "all_ages = None\nnum_passengers_by_sex = None\nall_fares = None\n\n# all_ages=titanic_data.groupby(\"Age\").size()\nall_ages, bins_ages = np.histogram(titanic_data.groupby(\"Age\").size(), bins=20)\nnum_passengers_by_sex=titanic_data.groupby(\"Sex\").size()\nall_fares, bins_fares = np.histogram(titanic_data.groupby(\"Fare\").size(), bins=20)\n\n# all_ages\n# len(all_fares)\n\n# assert_equal(len(all_ages), len(all_fares))\n\n# width = (bins_ages[1] - bins_ages[0])\n# center = (bins_ages[:-1] + bins_ages[1:]) / 2\n# plt.bar(center, all_ages, align = \"center\", width = width)\n# plt.show()\n\nplt.hist(all_ages, bins = 20)\nplt.title(\"Distribution of ages\")\nplt.show()\n\nplt.gca().set_aspect(\"equal\")\nplt.pie(num_passengers_by_sex, labels = num_passengers_by_sex.index, autopct = \"%.2f%%\")\nplt.title(\"Passengers per sex\")\nplt.show()\n\nplt.hist(all_fares, bins = 20)\nplt.title(\"Distribution of fares\")\nplt.show()"}
{"task_id": "DSP/757", "completion": "ages_by_class = None\nages_by_class = titanic_data.groupby(\"Class\").Age\n# print(type(ages_by_class))\n# ages_by_class\n# ages_by_class.size().tolist()"}
{"task_id": "DSP/757", "completion": "ages_by_class = None\nages_by_class = titanic_data.groupby(\"Class\").Age\n# print(type(ages_by_class))\n# ages_by_class\n# ages_by_class.size().tolist()"}
{"task_id": "DSP/758", "completion": "test_result = ttest_ind(first_class_ages, third_class_ages, equal_var = False)\n# YOUR CODE HERE\n# raise NotImplementedError()\nprint(test_result.pvalue)\nif test_result.pvalue <= 0.01:\n    print(\"The differences in age are significant. Reject H0.\")\nelse:\n    print(\"There's not enough evidence to reject H0. Don't accept or reject anything else.\")"}
{"task_id": "DSP/758", "completion": "test_result = ttest_ind(first_class_ages, third_class_ages, equal_var = False)\n# YOUR CODE HERE\n# raise NotImplementedError()\nprint(test_result.pvalue)\nif test_result.pvalue <= 0.01:\n    print(\"The differences in age are significant. Reject H0.\")\nelse:\n    print(\"There's not enough evidence to reject H0. Don't accept or reject anything else.\")"}
{"task_id": "DSP/759", "completion": "titanic_data_for_modelling = titanic_data_for_modelling[['Class','Sex','Embarked','Survived','Age','SibSp','ParCh','Fare','Sex_female','Embarked_Cherbourg','Embarked_Queenstown','Embarked_Southampton']]\n# titanic_data_for_modelling\n# raise NotImplementedError()"}
{"task_id": "DSP/759", "completion": "titanic_data_for_modelling = titanic_data_for_modelling[['Class','Sex','Embarked','Survived','Age','SibSp','ParCh','Fare','Sex_female','Embarked_Cherbourg','Embarked_Queenstown','Embarked_Southampton']]\n# titanic_data_for_modelling\n# raise NotImplementedError()"}
{"task_id": "DSP/760", "completion": "titanic_data_features\n\n#This is the numerics only\ntitanic_data_features_numerics = titanic_data_features.drop(['Sex','Embarked'], axis=1)\n\n#This is the transformed numerics\nscaler = MinMaxScaler()\ntitanic_data_features_numerics_transformed = scaler.fit_transform(titanic_data_features_numerics)\n\n#This is the output shape (891, 11)\ntitanic_data_features_scaled=titanic_data_features[['Sex','Embarked']]\ntitanic_data_features_scaled[\"Class\"] = titanic_data_features_numerics_transformed[:,0]\ntitanic_data_features_scaled[\"Age\"] = titanic_data_features_numerics_transformed[:,1]\ntitanic_data_features_scaled[\"SibSp\"] = titanic_data_features_numerics_transformed[:,2]\ntitanic_data_features_scaled[\"ParCh\"] = titanic_data_features_numerics_transformed[:,3]\ntitanic_data_features_scaled[\"Fare\"] = titanic_data_features_numerics_transformed[:,4]\ntitanic_data_features_scaled[\"Sex_female\"] = titanic_data_features_numerics_transformed[:,5]\ntitanic_data_features_scaled[\"Embarked_Cherbourg\"] = titanic_data_features_numerics_transformed[:,6]\ntitanic_data_features_scaled[\"Embarked_Queenstown\"] = titanic_data_features_numerics_transformed[:,7]\ntitanic_data_features_scaled[\"Embarked_Southampton\"] = titanic_data_features_numerics_transformed[:,8]"}
{"task_id": "DSP/760", "completion": "titanic_data_features\n\n#This is the numerics only\ntitanic_data_features_numerics = titanic_data_features.drop(['Sex','Embarked'], axis=1)\n\n#This is the transformed numerics\nscaler = MinMaxScaler()\ntitanic_data_features_numerics_transformed = scaler.fit_transform(titanic_data_features_numerics)\n\n#This is the output shape (891, 11)\ntitanic_data_features_scaled=titanic_data_features[['Sex','Embarked']]\ntitanic_data_features_scaled[\"Class\"] = titanic_data_features_numerics_transformed[:,0]\ntitanic_data_features_scaled[\"Age\"] = titanic_data_features_numerics_transformed[:,1]\ntitanic_data_features_scaled[\"SibSp\"] = titanic_data_features_numerics_transformed[:,2]\ntitanic_data_features_scaled[\"ParCh\"] = titanic_data_features_numerics_transformed[:,3]\ntitanic_data_features_scaled[\"Fare\"] = titanic_data_features_numerics_transformed[:,4]\ntitanic_data_features_scaled[\"Sex_female\"] = titanic_data_features_numerics_transformed[:,5]\ntitanic_data_features_scaled[\"Embarked_Cherbourg\"] = titanic_data_features_numerics_transformed[:,6]\ntitanic_data_features_scaled[\"Embarked_Queenstown\"] = titanic_data_features_numerics_transformed[:,7]\ntitanic_data_features_scaled[\"Embarked_Southampton\"] = titanic_data_features_numerics_transformed[:,8]"}
{"task_id": "DSP/761", "completion": "model = None\nmodel = LogisticRegression()\nmodel.fit(features_train, target_train)\n# YOUR CODE HERE\n# raise NotImplementedError()"}
{"task_id": "DSP/761", "completion": "model = None\nmodel = LogisticRegression()\nmodel.fit(features_train, target_train)\n# YOUR CODE HERE\n# raise NotImplementedError()"}
{"task_id": "DSP/762", "completion": "score = model.score(features_test, target_test)\nscore\n# features_test, target_test\n# YOUR CODE HERE\n# raise NotImplementedError()"}
{"task_id": "DSP/762", "completion": "score = model.score(features_test, target_test)\nscore\n# features_test, target_test\n# YOUR CODE HERE\n# raise NotImplementedError()"}
{"task_id": "DSP/763", "completion": "%pylab inline\n\ndef gen_cosine(n):\n    # YOUR CODE HERE\n    # Create n data point form 0 to 2pi\n    x = np.linspace(0, 2 * np.pi, n)    \n    \n    # Calculate Gaussian distribution parameter\n    mean = np.cos(x)\n    std = 0.2\n    \n    # Create t with Gaussian distribution\n    t = np.random.normal(mean, std, n)\n    \n    # transpose for correct dimension\n    x = x.transpose()\n    t = t.transpose()    \n    \n    #raise NotImplementedError()\n    return x, t"}
{"task_id": "DSP/763", "completion": "%pylab inline\n\ndef gen_cosine(n):\n    # YOUR CODE HERE\n    # Create n data point form 0 to 2pi\n    x = np.linspace(0, 2 * np.pi, n)    \n    \n    # Calculate Gaussian distribution parameter\n    mean = np.cos(x)\n    std = 0.2\n    \n    # Create t with Gaussian distribution\n    t = np.random.normal(mean, std, n)\n    \n    # transpose for correct dimension\n    x = x.transpose()\n    t = t.transpose()    \n    \n    #raise NotImplementedError()\n    return x, t"}
{"task_id": "DSP/764", "completion": "def designmatrix(x, M): # it is highly recommended to write a helper function that computes Phi\n    # YOUR CODE HERE\n    # Create empty matrix for Phi\n    Phi = np.zeros(shape=(x.size, M + 1))\n    \n    # Calculate each column of Phi\n    for Phi_column_idx in np.arange(M + 1):        \n        Phi[:,Phi_column_idx] = x ** Phi_column_idx                \n    \n    #raise NotImplementedError()\n    return Phi\n\ndef fit_polynomial(x, t, M):    \n    # YOUR CODE HERE\n        \n    # Get Phi from designmatrix\n    Phi = designmatrix(x, M)\n                       \n    # Calculate w_ml with closed form\n    w_ml = np.linalg.inv(Phi.T.dot(Phi)).dot(Phi.T).dot(t)\n    \n    #raise NotImplementedError()    \n    return w_ml, Phi"}
{"task_id": "DSP/764", "completion": "def designmatrix(x, M): # it is highly recommended to write a helper function that computes Phi\n    # YOUR CODE HERE\n    # Create empty matrix for Phi\n    Phi = np.zeros(shape=(x.size, M + 1))\n    \n    # Calculate each column of Phi\n    for Phi_column_idx in np.arange(M + 1):        \n        Phi[:,Phi_column_idx] = x ** Phi_column_idx                \n    \n    #raise NotImplementedError()\n    return Phi\n\ndef fit_polynomial(x, t, M):    \n    # YOUR CODE HERE\n        \n    # Get Phi from designmatrix\n    Phi = designmatrix(x, M)\n                       \n    # Calculate w_ml with closed form\n    w_ml = np.linalg.inv(Phi.T.dot(Phi)).dot(Phi.T).dot(t)\n    \n    #raise NotImplementedError()    \n    return w_ml, Phi"}
{"task_id": "DSP/765", "completion": "def fit_polynomial_reg(x, t, m, lamb):\n    # YOUR CODE HERE\n    \n    # get Phi by designmatrix function\n    Phi = designmatrix(x, m)\n    \n    # create identity matrix\n    I = np.eye(m + 1)\n    \n    # calculate regularized w_ml\n    w_ml = np.linalg.inv(lamb * I + Phi.T.dot(Phi)).dot(Phi.T).dot(t)\n    \n    #raise NotImplementedError()\n    \n    return w_ml, Phi"}
{"task_id": "DSP/765", "completion": "def fit_polynomial_reg(x, t, m, lamb):\n    # YOUR CODE HERE\n    \n    # get Phi by designmatrix function\n    Phi = designmatrix(x, m)\n    \n    # create identity matrix\n    I = np.eye(m + 1)\n    \n    # calculate regularized w_ml\n    w_ml = np.linalg.inv(lamb * I + Phi.T.dot(Phi)).dot(Phi.T).dot(t)\n    \n    #raise NotImplementedError()\n    \n    return w_ml, Phi"}
{"task_id": "DSP/766", "completion": "def pred_error(x_train, x_valid, t_train, t_valid, M, reg):\n    # YOUR CODE HERE\n    \n    # get w_ml with training data\n    w_train, Phi_train = fit_polynomial_reg(x_train, t_train, M, reg)\n    \n    # get Phi with test data\n    Phi_valid = designmatrix(x_valid, M)\n    \n    # calculate prediction error\n    pred_err = np.sum(np.square(t_valid - Phi_valid.dot(w_train))) \n    \n    #raise NotImplementedError()\n    \n    return pred_err"}
{"task_id": "DSP/766", "completion": "def pred_error(x_train, x_valid, t_train, t_valid, M, reg):\n    # YOUR CODE HERE\n    \n    # get w_ml with training data\n    w_train, Phi_train = fit_polynomial_reg(x_train, t_train, M, reg)\n    \n    # get Phi with test data\n    Phi_valid = designmatrix(x_valid, M)\n    \n    # calculate prediction error\n    pred_err = np.sum(np.square(t_valid - Phi_valid.dot(w_train))) \n    \n    #raise NotImplementedError()\n    \n    return pred_err"}
{"task_id": "DSP/767", "completion": "def gen_cosine2(n):\n    # YOUR CODE HERE\n    \n    # generate x with a uniform distribution between 0 and 2pi\n    x = np.random.uniform(low=0,high=2 * pi,size=10)\n    \n    # generate t with cos(x)\n    t = np.cos(x)\n    \n    # raise NotImplementedError()    \n    return x, t"}
{"task_id": "DSP/767", "completion": "def gen_cosine2(n):\n    # YOUR CODE HERE\n    \n    # generate x with a uniform distribution between 0 and 2pi\n    x = np.random.uniform(low=0,high=2 * pi,size=10)\n    \n    # generate t with cos(x)\n    t = np.cos(x)\n    \n    # raise NotImplementedError()    \n    return x, t"}
{"task_id": "DSP/768", "completion": "def fit_polynomial_bayes(x, t, M, alpha, beta):\n    # YOUR CODE HERE\n    \n    # generate identity matrix with M+1 dimension\n    I = np.eye(M + 1)\n    \n    # get Phi with designmatrix function\n    Phi = designmatrix(x, M)\n    \n    # calculate matrix S and vector m based on formula of covariance and mean of the posterior\n    S = np.linalg.inv((alpha * I + beta * Phi.T.dot(Phi)))\n    m = beta * S.dot(Phi.T).dot(t)\n    \n    #raise NotImplementedError() \n    return m, S, Phi"}
{"task_id": "DSP/768", "completion": "def fit_polynomial_bayes(x, t, M, alpha, beta):\n    # YOUR CODE HERE\n    \n    # generate identity matrix with M+1 dimension\n    I = np.eye(M + 1)\n    \n    # get Phi with designmatrix function\n    Phi = designmatrix(x, M)\n    \n    # calculate matrix S and vector m based on formula of covariance and mean of the posterior\n    S = np.linalg.inv((alpha * I + beta * Phi.T.dot(Phi)))\n    m = beta * S.dot(Phi.T).dot(t)\n    \n    #raise NotImplementedError() \n    return m, S, Phi"}
{"task_id": "DSP/769", "completion": "def predict_polynomial_bayes(x, m, S, beta):\n    # YOUR CODE HERE    \n    \n    # calculate Phi with designmatrix\n    Phi = designmatrix(x, m.shape[0] - 1)\n    \n    # calculate mean and sigma of distribution\n    mean = Phi.dot(m)    \n    sigma = 1 / beta + np.sum(Phi.dot(S) * Phi, axis=1)\n    \n    #raise NotImplementedError()\n    return mean, sigma, Phi"}
{"task_id": "DSP/769", "completion": "def predict_polynomial_bayes(x, m, S, beta):\n    # YOUR CODE HERE    \n    \n    # calculate Phi with designmatrix\n    Phi = designmatrix(x, m.shape[0] - 1)\n    \n    # calculate mean and sigma of distribution\n    mean = Phi.dot(m)    \n    sigma = 1 / beta + np.sum(Phi.dot(S) * Phi, axis=1)\n    \n    #raise NotImplementedError()\n    return mean, sigma, Phi"}
{"task_id": "DSP/770", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/770", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/771", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/771", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/772", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/772", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/773", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/773", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/774", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/774", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/775", "completion": "dictionary = dict(zip(var_a, var_b))"}
{"task_id": "DSP/775", "completion": "dictionary = dict(zip(var_a, var_b))"}
{"task_id": "DSP/776", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor element in lst:\n    if element % 2 == 0:\n        print (element)\n        inds.insert(element-1, element-1)"}
{"task_id": "DSP/776", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\nfor element in lst:\n    if element % 2 == 0:\n        print (element)\n        inds.insert(element-1, element-1)"}
{"task_id": "DSP/777", "completion": "def add2(input_1, input_2):   \n    return input_1 + input_2"}
{"task_id": "DSP/777", "completion": "def add2(input_1, input_2):   \n    return input_1 + input_2"}
{"task_id": "DSP/778", "completion": "other_dictionary = dict()\n\n\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nfor k, t in dictionary.items():\n    if t % 2 != 0:\n        key_value_pair = add2(t,1)\n        print(key_value_pair)\n        \n        other_dictionary['key_value_pair'] = key_value_pair\n    elif t % 2 == 0:\n        other_dictionary['key_value_pair'] = key_value_pair"}
{"task_id": "DSP/778", "completion": "other_dictionary = dict()\n\n\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\nfor k, t in dictionary.items():\n    if t % 2 != 0:\n        key_value_pair = add2(t,1)\n        print(key_value_pair)\n        \n        other_dictionary['key_value_pair'] = key_value_pair\n    elif t % 2 == 0:\n        other_dictionary['key_value_pair'] = key_value_pair"}
{"task_id": "DSP/779", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/779", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/780", "completion": "def validate_alpha(alpha):\n    if type(alpha) == str or type(alpha) == float:\n        if float(alpha) < 1 and float(alpha)>0:\n            return float(alpha)\n        else:\n            raise ValueError\n    else:\n        raise TypeError"}
{"task_id": "DSP/780", "completion": "def validate_alpha(alpha):\n    if type(alpha) == str or type(alpha) == float:\n        if float(alpha) < 1 and float(alpha)>0:\n            return float(alpha)\n        else:\n            raise ValueError\n    else:\n        raise TypeError"}
{"task_id": "DSP/781", "completion": "def validate_color(color):\n    if type(color) == str or type(color) == float or type(color) == int:\n        if float(color) <= 255 and float(color)>=0:\n            return int(color)\n        else:\n            raise ValueError\n    else:\n        raise TypeError"}
{"task_id": "DSP/781", "completion": "def validate_color(color):\n    if type(color) == str or type(color) == float or type(color) == int:\n        if float(color) <= 255 and float(color)>=0:\n            return int(color)\n        else:\n            raise ValueError\n    else:\n        raise TypeError"}
{"task_id": "DSP/782", "completion": "from collections import namedtuple\nimport numpy as np\nimport math\nrgbalpha = namedtuple(\"rgbalpha\",['r','g','b','alpha'])\nclass rgba(rgbalpha):\n    def __new__(cls, *args, **kwargs):\n        return super().__new__(cls, validate_color(args[0]),\n                          validate_color(args[1]),\n                          validate_color(args[2]),\n                          validate_alpha(args[3]))\n    def __init__(self, *args, name=\"null\"):\n        self.__name = name\n        \n    @property\n    def name(self):\n        return self.__name\n    @name.setter\n    def name(self):\n        return self.__name\n    \n    def invert_rgb(self): \n        \"\"\"\n        this function inverts the RGB color by subtracting \n        all color values from 255 and returns a new rgba object with the \n        new color values.\n        \n        alpha is not modified\n        \n        name\n        \"\"\"\n        return rgba(255 - self.r, 255-self.g, 255-self.b, self.alpha)\n    \n    def grayscale(self): \n\n        \"\"\"\n        this function converts RGB color to grayscale by using a \n        weight average formula: 0.299Red+0.587Green+0.114Blue\n        \"\"\"\n        waf = (self.r*0.299) + (self.g*0.587) + (self.b*0.114)\n        return rgba(waf, waf, waf, self.alpha)\n    \n    def __add__(self,color):\n        return rgba(((self.r+color.r)%256),\n                    ((self.g+color.g)%256),\n                    ((self.b+color.b)%256),\n                     max(self.alpha,color.alpha))\n    def __eq__(self,color):\n        if self.r == color.r and self.g == color.g and self.b == color.b:\n            return True\n    def __abs__(self):\n        return np.sqrt(self.r**2+self.g**2+self.b**2)\n    \n    def __str__(self):\n        return \"%03d, %03d, %03d, %3.2f\"%(self.r, self.g, self.b, self.alpha)\n    \n    def __repr__(self):\n        return \"rgba, %03d, %03d, %03d, %f\"%(self.r, self.g, self.b, self.alpha)"}
{"task_id": "DSP/782", "completion": "from collections import namedtuple\nimport numpy as np\nimport math\nrgbalpha = namedtuple(\"rgbalpha\",['r','g','b','alpha'])\nclass rgba(rgbalpha):\n    def __new__(cls, *args, **kwargs):\n        return super().__new__(cls, validate_color(args[0]),\n                          validate_color(args[1]),\n                          validate_color(args[2]),\n                          validate_alpha(args[3]))\n    def __init__(self, *args, name=\"null\"):\n        self.__name = name\n        \n    @property\n    def name(self):\n        return self.__name\n    @name.setter\n    def name(self):\n        return self.__name\n    \n    def invert_rgb(self): \n        \"\"\"\n        this function inverts the RGB color by subtracting \n        all color values from 255 and returns a new rgba object with the \n        new color values.\n        \n        alpha is not modified\n        \n        name\n        \"\"\"\n        return rgba(255 - self.r, 255-self.g, 255-self.b, self.alpha)\n    \n    def grayscale(self): \n\n        \"\"\"\n        this function converts RGB color to grayscale by using a \n        weight average formula: 0.299Red+0.587Green+0.114Blue\n        \"\"\"\n        waf = (self.r*0.299) + (self.g*0.587) + (self.b*0.114)\n        return rgba(waf, waf, waf, self.alpha)\n    \n    def __add__(self,color):\n        return rgba(((self.r+color.r)%256),\n                    ((self.g+color.g)%256),\n                    ((self.b+color.b)%256),\n                     max(self.alpha,color.alpha))\n    def __eq__(self,color):\n        if self.r == color.r and self.g == color.g and self.b == color.b:\n            return True\n    def __abs__(self):\n        return np.sqrt(self.r**2+self.g**2+self.b**2)\n    \n    def __str__(self):\n        return \"%03d, %03d, %03d, %3.2f\"%(self.r, self.g, self.b, self.alpha)\n    \n    def __repr__(self):\n        return \"rgba, %03d, %03d, %03d, %f\"%(self.r, self.g, self.b, self.alpha)"}
{"task_id": "DSP/783", "completion": "import numbers as nm\n\ndef d1a(tt,h=1):\n    \"This function (named d1a) computes the first derivative of a 1-D numpy array using a backward difference\"\n    if h<0:\n        raise ValueError\n    elif isinstance(h,nm.Number) and isinstance(tt,np.ndarray):\n        n01 = np.zeros(shape=(len(tt)))\n        n01[1:] = (tt[1:]-tt[0:-1])/h\n        return n01\n    else:\n        raise TypeError\n\nplt.plot(tt, d1a(fp1(tt)))"}
{"task_id": "DSP/783", "completion": "import numbers as nm\n\ndef d1a(tt,h=1):\n    \"This function (named d1a) computes the first derivative of a 1-D numpy array using a backward difference\"\n    if h<0:\n        raise ValueError\n    elif isinstance(h,nm.Number) and isinstance(tt,np.ndarray):\n        n01 = np.zeros(shape=(len(tt)))\n        n01[1:] = (tt[1:]-tt[0:-1])/h\n        return n01\n    else:\n        raise TypeError\n\nplt.plot(tt, d1a(fp1(tt)))"}
{"task_id": "DSP/784", "completion": "import numbers as nm\n\ndef d1b(tt,h=1):\n    \n    \"This function (named d1a) computes the first derivative of a 1-D numpy array using a centered difference\"\n    if h<0:\n        raise ValueError\n    elif isinstance(h,nm.Number) and isinstance(tt,np.ndarray):\n        n02 = np.zeros(shape=(len(tt)))\n        n02[1:-1]=((tt[2:]-tt[0:-2])/(2*h))\n        return n02\n    else:\n        raise TypeError\n\n\nplt.plot(tt, d1b(fp1(tt), h=0.1))"}
{"task_id": "DSP/784", "completion": "import numbers as nm\n\ndef d1b(tt,h=1):\n    \n    \"This function (named d1a) computes the first derivative of a 1-D numpy array using a centered difference\"\n    if h<0:\n        raise ValueError\n    elif isinstance(h,nm.Number) and isinstance(tt,np.ndarray):\n        n02 = np.zeros(shape=(len(tt)))\n        n02[1:-1]=((tt[2:]-tt[0:-2])/(2*h))\n        return n02\n    else:\n        raise TypeError\n\n\nplt.plot(tt, d1b(fp1(tt), h=0.1))"}
{"task_id": "DSP/785", "completion": "import numbers as nm\n\ndef d1c(tt,h=1):\n    \n    \"This function (named d1a) computes the first derivative of a 1-D numpy array using a Taylor Series Expansion\"\n    \n    if h<0:\n        raise ValueError\n    elif isinstance(h,nm.Number) and isinstance(tt,np.ndarray):\n        n03 = np.zeros(shape=(len(tt)))\n        n03[2:-3]=(((-1)*(tt[4:-1]))+(8*(tt[3:-2]))-(8*(tt[1:-4]))+(tt[0:-5]))/(12*h)\n        return n03\n    else:\n        raise TypeError\n\n\n\n\nplt.plot(tt, d1c(fp1(tt)))"}
{"task_id": "DSP/785", "completion": "import numbers as nm\n\ndef d1c(tt,h=1):\n    \n    \"This function (named d1a) computes the first derivative of a 1-D numpy array using a Taylor Series Expansion\"\n    \n    if h<0:\n        raise ValueError\n    elif isinstance(h,nm.Number) and isinstance(tt,np.ndarray):\n        n03 = np.zeros(shape=(len(tt)))\n        n03[2:-3]=(((-1)*(tt[4:-1]))+(8*(tt[3:-2]))-(8*(tt[1:-4]))+(tt[0:-5]))/(12*h)\n        return n03\n    else:\n        raise TypeError\n\n\n\n\nplt.plot(tt, d1c(fp1(tt)))"}
{"task_id": "DSP/786", "completion": "ts = symbols('ts')\ndef kinetics(t, A=200, b=0.46, k=0.35):\n    y = ((A*b)/(b-k))*((exp(-k*t))-(exp(-b*t)))\n    return y"}
{"task_id": "DSP/786", "completion": "ts = symbols('ts')\ndef kinetics(t, A=200, b=0.46, k=0.35):\n    y = ((A*b)/(b-k))*((exp(-k*t))-(exp(-b*t)))\n    return y"}
{"task_id": "DSP/787", "completion": "import pickle, gzip\n# changed to fname\ndef write_pickle(object1, fname= \"temp.pickle\", write_over= True or False ):\n    \n    \n    if os.path.exists(\"temp.pickle\") and write_over==False:\n        raise FileExistsError()\n    \n    \n    if write_over == True:\n        WP = gzip.open(fname, 'w')\n        pickle.dump(object1,WP)\n        WP.close()"}
{"task_id": "DSP/787", "completion": "import pickle, gzip\n# changed to fname\ndef write_pickle(object1, fname= \"temp.pickle\", write_over= True or False ):\n    \n    \n    if os.path.exists(\"temp.pickle\") and write_over==False:\n        raise FileExistsError()\n    \n    \n    if write_over == True:\n        WP = gzip.open(fname, 'w')\n        pickle.dump(object1,WP)\n        WP.close()"}
{"task_id": "DSP/788", "completion": "def bmi(h, w):\n    return w/((h*2.54/100.0)**2)"}
{"task_id": "DSP/788", "completion": "def bmi(h, w):\n    return w/((h*2.54/100.0)**2)"}
{"task_id": "DSP/789", "completion": "import math\n\ndef find_roots(a, b, c):\n    \"\"\"\n    This is a docstring. It is what the help() function returns\n    about this function.\n    \"\"\" \n    x1 = (((-1)*(b)) + ((math.sqrt((b**2)-4*a*c))))/(2*a)\n    x2 = (((-1)*(b)) - ((math.sqrt((b**2)-4*a*c))))/(2*a)\n    return x2 , x1"}
{"task_id": "DSP/789", "completion": "import math\n\ndef find_roots(a, b, c):\n    \"\"\"\n    This is a docstring. It is what the help() function returns\n    about this function.\n    \"\"\" \n    x1 = (((-1)*(b)) + ((math.sqrt((b**2)-4*a*c))))/(2*a)\n    x2 = (((-1)*(b)) - ((math.sqrt((b**2)-4*a*c))))/(2*a)\n    return x2 , x1"}
{"task_id": "DSP/790", "completion": "def age_string(age):\n    decade = None\n    if age < 10:\n        return(\"Age in 0s\")\n    elif age < 20:\n        return(\"Age in 10s\")\n    elif age < 30:\n        return(\"Age in 20s\")\n    elif age < 40:\n        return(\"Age in 30s\")\n    elif age < 50:\n        return(\"Age in 40s\")\n    elif age < 60:\n        return(\"Age in 50s\")\n    else:\n        return(\"Senior Citizen\")"}
{"task_id": "DSP/790", "completion": "def age_string(age):\n    decade = None\n    if age < 10:\n        return(\"Age in 0s\")\n    elif age < 20:\n        return(\"Age in 10s\")\n    elif age < 30:\n        return(\"Age in 20s\")\n    elif age < 40:\n        return(\"Age in 30s\")\n    elif age < 50:\n        return(\"Age in 40s\")\n    elif age < 60:\n        return(\"Age in 50s\")\n    else:\n        return(\"Senior Citizen\")"}
{"task_id": "DSP/791", "completion": "def hounsfield(I, I0, L):\n    MU = (-1)*((math.log(I/I0))/L)\n    return MU"}
{"task_id": "DSP/791", "completion": "def hounsfield(I, I0, L):\n    MU = (-1)*((math.log(I/I0))/L)\n    return MU"}
{"task_id": "DSP/792", "completion": "def get_history(report):\n    return report[(report.find(\"HISTORY:\")):(report.find(\"TECHNIQUE\"))]"}
{"task_id": "DSP/792", "completion": "def get_history(report):\n    return report[(report.find(\"HISTORY:\")):(report.find(\"TECHNIQUE\"))]"}
{"task_id": "DSP/793", "completion": "def get_impression(report):\n    return report[(report.find(\"IMPRESSION:\")):]"}
{"task_id": "DSP/793", "completion": "def get_impression(report):\n    return report[(report.find(\"IMPRESSION:\")):]"}
{"task_id": "DSP/794", "completion": "10**(-(ord(\"A\") - ord(\"!\"))/10)"}
{"task_id": "DSP/794", "completion": "10**(-(ord(\"A\") - ord(\"!\"))/10)"}
{"task_id": "DSP/795", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', skip_header = 30, delimiter = \",\")"}
{"task_id": "DSP/795", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', skip_header = 30, delimiter = \",\")"}
{"task_id": "DSP/796", "completion": "temp = data[:,2]\nmasses = pd.Series(temp[temp < 15]).dropna()"}
{"task_id": "DSP/796", "completion": "temp = data[:,2]\nmasses = pd.Series(temp[temp < 15]).dropna()"}
{"task_id": "DSP/797", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/797", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/798", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(lam = t1_avg, size = 500)\nsim2 = np.random.poisson(lam = t2_avg, size = 500)"}
{"task_id": "DSP/798", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(lam = t1_avg, size = 500)\nsim2 = np.random.poisson(lam = t2_avg, size = 500)"}
{"task_id": "DSP/799", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/799", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/800", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    return np.random.normal(loc = mu, scale = sigma, size = size)"}
{"task_id": "DSP/800", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    return np.random.normal(loc = mu, scale = sigma, size = size)"}
{"task_id": "DSP/801", "completion": "def fit_lambda(data):\n    \"\"\"Perform MLE to estimate the \u03bb parameter of the Poisson distribution.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The data to use in estimating lambda\n    \n    Returns\n    -------\n    lambda: float\n        The MLE value for lambda\n    \"\"\"\n    return sum(poisson(data).mean())/(len(data))"}
{"task_id": "DSP/801", "completion": "def fit_lambda(data):\n    \"\"\"Perform MLE to estimate the \u03bb parameter of the Poisson distribution.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The data to use in estimating lambda\n    \n    Returns\n    -------\n    lambda: float\n        The MLE value for lambda\n    \"\"\"\n    return sum(poisson(data).mean())/(len(data))"}
{"task_id": "DSP/802", "completion": "def hat(x, a, b):\n    return b * (x ** 4) - a * (x ** 2)"}
{"task_id": "DSP/802", "completion": "def hat(x, a, b):\n    return b * (x ** 4) - a * (x ** 2)"}
{"task_id": "DSP/803", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/803", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/804", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    return (np.identity(n, dtype = int) * (n - 1))"}
{"task_id": "DSP/804", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    return (np.identity(n, dtype = int) * (n - 1))"}
{"task_id": "DSP/805", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    return np.full((n, n), 1, dtype = int) -  np.identity(n, dtype = int)"}
{"task_id": "DSP/805", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    return np.full((n, n), 1, dtype = int) -  np.identity(n, dtype = int)"}
{"task_id": "DSP/806", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] + y[i])\n    return vec"}
{"task_id": "DSP/806", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] + y[i])\n    return vec"}
{"task_id": "DSP/807", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] - y[i])\n    return vec"}
{"task_id": "DSP/807", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] - y[i])\n    return vec"}
{"task_id": "DSP/808", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"    \n    vec = []\n    for i in range(0, len(x)):\n        vec.append(a * x[i])\n    return vec"}
{"task_id": "DSP/808", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"    \n    vec = []\n    for i in range(0, len(x)):\n        vec.append(a * x[i])\n    return vec"}
{"task_id": "DSP/809", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    total = 0.0\n    for a in range(0, len(x)):\n        total = total + x[a] * y[a]\n    return total"}
{"task_id": "DSP/809", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    total = 0.0\n    for a in range(0, len(x)):\n        total = total + x[a] * y[a]\n    return total"}
{"task_id": "DSP/810", "completion": "def L1(x):\n    # equation found at: http://mathworld.wolfram.com/L1-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + a\n    return total"}
{"task_id": "DSP/810", "completion": "def L1(x):\n    # equation found at: http://mathworld.wolfram.com/L1-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + a\n    return total"}
{"task_id": "DSP/811", "completion": "def L2(x):\n    # equation found at: http://mathworld.wolfram.com/L2-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + math.pow(a, 2)\n    return math.sqrt(total)"}
{"task_id": "DSP/811", "completion": "def L2(x):\n    # equation found at: http://mathworld.wolfram.com/L2-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + math.pow(a, 2)\n    return math.sqrt(total)"}
{"task_id": "DSP/812", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    #equation found at: https://www.cs.indiana.edu/~predrag/classes/2005springi400/lecture_notes_4_2.pdf\n    total = 0.0\n    for i in range(0, len(x)):\n        total += (x[i] - y[i])**2\n    return total/len(x)"}
{"task_id": "DSP/812", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    #equation found at: https://www.cs.indiana.edu/~predrag/classes/2005springi400/lecture_notes_4_2.pdf\n    total = 0.0\n    for i in range(0, len(x)):\n        total += (x[i] - y[i])**2\n    return total/len(x)"}
{"task_id": "DSP/813", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    total = 0.0\n    for i in range(0, len(x)):\n        total += x[i]\n    return total/len(x)"}
{"task_id": "DSP/813", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    total = 0.0\n    for i in range(0, len(x)):\n        total += x[i]\n    return total/len(x)"}
{"task_id": "DSP/814", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    total = 0.0\n    mu = mean(x)\n    for i in range(len(x)):\n        total += (x[i] - mu)**2\n    return total / len(x)"}
{"task_id": "DSP/814", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    total = 0.0\n    mu = mean(x)\n    for i in range(len(x)):\n        total += (x[i] - mu)**2\n    return total / len(x)"}
{"task_id": "DSP/815", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/815", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/816", "completion": "def euler1(x):\n    total = 0.0\n    for i in range(0, x, 3):\n        total += i\n    for i in range(0, x, 5):\n        if i%3 != 0:\n            total += i\n    return total"}
{"task_id": "DSP/816", "completion": "def euler1(x):\n    total = 0.0\n    for i in range(0, x, 3):\n        total += i\n    for i in range(0, x, 5):\n        if i%3 != 0:\n            total += i\n    return total"}
{"task_id": "DSP/817", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/817", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/818", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/818", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/819", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/819", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/820", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/820", "completion": "def same_digits(x, *args):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    x = set(list(str(x)))\n    for y in args:\n        yy = set(list(str(y)))\n        if x != yy:\n            return False\n    return True"}
{"task_id": "DSP/821", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', skip_header = 30, delimiter = \",\")"}
{"task_id": "DSP/821", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', skip_header = 30, delimiter = \",\")"}
{"task_id": "DSP/822", "completion": "temp = data[:,2]\nmasses = pd.Series(temp[temp < 15]).dropna()"}
{"task_id": "DSP/822", "completion": "temp = data[:,2]\nmasses = pd.Series(temp[temp < 15]).dropna()"}
{"task_id": "DSP/823", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/823", "completion": "s4 = df1.iloc[::2, -1]"}
{"task_id": "DSP/824", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(lam = t1_avg, size = 500)\nsim2 = np.random.poisson(lam = t2_avg, size = 500)"}
{"task_id": "DSP/824", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(lam = t1_avg, size = 500)\nsim2 = np.random.poisson(lam = t2_avg, size = 500)"}
{"task_id": "DSP/825", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/825", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/826", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    return np.random.normal(loc = mu, scale = sigma, size = size)"}
{"task_id": "DSP/826", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    return np.random.normal(loc = mu, scale = sigma, size = size)"}
{"task_id": "DSP/827", "completion": "def euler1(x):\n    total = 0.0\n    for i in range(0, x, 3):\n        total += i\n    for i in range(0, x, 5):\n        if i%3 != 0:\n            total += i\n    return total"}
{"task_id": "DSP/827", "completion": "def euler1(x):\n    total = 0.0\n    for i in range(0, x, 3):\n        total += i\n    for i in range(0, x, 5):\n        if i%3 != 0:\n            total += i\n    return total"}
{"task_id": "DSP/828", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] + y[i])\n    return vec"}
{"task_id": "DSP/828", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] + y[i])\n    return vec"}
{"task_id": "DSP/829", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] - y[i])\n    return vec"}
{"task_id": "DSP/829", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    vec = []\n    for i in range(0, len(x)):\n        vec.append(x[i] - y[i])\n    return vec"}
{"task_id": "DSP/830", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"    \n    vec = []\n    for i in range(0, len(x)):\n        vec.append(a * x[i])\n    return vec"}
{"task_id": "DSP/830", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"    \n    vec = []\n    for i in range(0, len(x)):\n        vec.append(a * x[i])\n    return vec"}
{"task_id": "DSP/831", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    total = 0.0\n    for a in range(0, len(x)):\n        total = total + x[a] * y[a]\n    return total"}
{"task_id": "DSP/831", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    total = 0.0\n    for a in range(0, len(x)):\n        total = total + x[a] * y[a]\n    return total"}
{"task_id": "DSP/832", "completion": "def L1(x):\n    # equation found at: http://mathworld.wolfram.com/L1-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + a\n    return total"}
{"task_id": "DSP/832", "completion": "def L1(x):\n    # equation found at: http://mathworld.wolfram.com/L1-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + a\n    return total"}
{"task_id": "DSP/833", "completion": "def L2(x):\n    # equation found at: http://mathworld.wolfram.com/L2-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + math.pow(a, 2)\n    return math.sqrt(total)"}
{"task_id": "DSP/833", "completion": "def L2(x):\n    # equation found at: http://mathworld.wolfram.com/L2-Norm.html\n    total = 0.0\n    for a in x:\n        total = total + math.pow(a, 2)\n    return math.sqrt(total)"}
{"task_id": "DSP/834", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    #equation found at: https://www.cs.indiana.edu/~predrag/classes/2005springi400/lecture_notes_4_2.pdf\n    total = 0.0\n    for i in range(0, len(x)):\n        total += (x[i] - y[i])**2\n    return total/len(x)"}
{"task_id": "DSP/834", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    #equation found at: https://www.cs.indiana.edu/~predrag/classes/2005springi400/lecture_notes_4_2.pdf\n    total = 0.0\n    for i in range(0, len(x)):\n        total += (x[i] - y[i])**2\n    return total/len(x)"}
{"task_id": "DSP/835", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    total = 0.0\n    for i in range(0, len(x)):\n        total += x[i]\n    return total/len(x)"}
{"task_id": "DSP/835", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    total = 0.0\n    for i in range(0, len(x)):\n        total += x[i]\n    return total/len(x)"}
{"task_id": "DSP/836", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    total = 0.0\n    mu = mean(x)\n    for i in range(len(x)):\n        total += (x[i] - mu)**2\n    return total / len(x)"}
{"task_id": "DSP/836", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    total = 0.0\n    mu = mean(x)\n    for i in range(len(x)):\n        total += (x[i] - mu)**2\n    return total / len(x)"}
{"task_id": "DSP/837", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/837", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/838", "completion": "def hat(x, a, b):\n    return b * (x ** 4) - a * (x ** 2)"}
{"task_id": "DSP/838", "completion": "def hat(x, a, b):\n    return b * (x ** 4) - a * (x ** 2)"}
{"task_id": "DSP/839", "completion": "def fit_lambda(data):\n    \"\"\"Perform MLE to estimate the \u03bb parameter of the Poisson distribution.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The data to use in estimating lambda\n    \n    Returns\n    -------\n    lambda: float\n        The MLE value for lambda\n    \"\"\"\n    return sum(poisson(data).mean())/(len(data))"}
{"task_id": "DSP/839", "completion": "def fit_lambda(data):\n    \"\"\"Perform MLE to estimate the \u03bb parameter of the Poisson distribution.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The data to use in estimating lambda\n    \n    Returns\n    -------\n    lambda: float\n        The MLE value for lambda\n    \"\"\"\n    return sum(poisson(data).mean())/(len(data))"}
{"task_id": "DSP/840", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    return (np.identity(n, dtype = int) * (n - 1))"}
{"task_id": "DSP/840", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    return (np.identity(n, dtype = int) * (n - 1))"}
{"task_id": "DSP/841", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    return np.full((n, n), 1, dtype = int) -  np.identity(n, dtype = int)"}
{"task_id": "DSP/841", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    return np.full((n, n), 1, dtype = int) -  np.identity(n, dtype = int)"}
{"task_id": "DSP/842", "completion": "10**(-(ord(\"A\") - ord(\"!\"))/10)"}
{"task_id": "DSP/842", "completion": "10**(-(ord(\"A\") - ord(\"!\"))/10)"}
{"task_id": "DSP/843", "completion": "def incr_list_by_1(l):\n    return [i+1 for i in l]"}
{"task_id": "DSP/843", "completion": "def incr_list_by_1(l):\n    return [i+1 for i in l]"}
{"task_id": "DSP/844", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    n_matrix = np.zeros((n,n), dtype=int)\n    for x in range(n):\n        for y in range(n):\n            if x == y:\n                n_matrix[x][y] = n - 1\n    return n_matrix"}
{"task_id": "DSP/844", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    n_matrix = np.zeros((n,n), dtype=int)\n    for x in range(n):\n        for y in range(n):\n            if x == y:\n                n_matrix[x][y] = n - 1\n    return n_matrix"}
{"task_id": "DSP/845", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    n_matrix = np.ones((n,n), dtype=int)\n    for x in range(n):\n        for y in range(n):\n            if x == y:\n                n_matrix[x][y] = 0\n    return n_matrix"}
{"task_id": "DSP/845", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    n_matrix = np.ones((n,n), dtype=int)\n    for x in range(n):\n        for y in range(n):\n            if x == y:\n                n_matrix[x][y] = 0\n    return n_matrix"}
{"task_id": "DSP/846", "completion": "t, W = wiener(1.0, 1000)"}
{"task_id": "DSP/846", "completion": "t, W = wiener(1.0, 1000)"}
{"task_id": "DSP/847", "completion": "def find_peaks(a):\n    \"\"\"Find the indices of the local maxima in a sequence.\"\"\"\n    # YOUR CODE HERE\n    maxima = []\n    for i in range(len(a)):\n        if i == 0:\n            if a[i] > a[i+1]:\n                maxima.append(i)\n        elif i == len(a)-1:\n            if a[i] > a[i-1]:\n                maxima.append(i)\n        elif a[i] > a[i+1] and a[i] > a[i-1]:\n            maxima.append(i)\n    \n    return maxima"}
{"task_id": "DSP/847", "completion": "def find_peaks(a):\n    \"\"\"Find the indices of the local maxima in a sequence.\"\"\"\n    # YOUR CODE HERE\n    maxima = []\n    for i in range(len(a)):\n        if i == 0:\n            if a[i] > a[i+1]:\n                maxima.append(i)\n        elif i == len(a)-1:\n            if a[i] > a[i-1]:\n                maxima.append(i)\n        elif a[i] > a[i+1] and a[i] > a[i-1]:\n            maxima.append(i)\n    \n    return maxima"}
{"task_id": "DSP/848", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    # YOUR CODE HERE\n    return np.random.uniform(mu - np.sqrt(3 * sigma ** 2), mu + np.sqrt(3 * sigma ** 2), size)"}
{"task_id": "DSP/848", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    # YOUR CODE HERE\n    return np.random.uniform(mu - np.sqrt(3 * sigma ** 2), mu + np.sqrt(3 * sigma ** 2), size)"}
{"task_id": "DSP/849", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    ex = str(x)\n    wye = str(y)\n    \n    if len(ex) == len(wye):\n        return sorted(ex) == sorted(wye)\n    else:\n        return False"}
{"task_id": "DSP/849", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    ex = str(x)\n    wye = str(y)\n    \n    if len(ex) == len(wye):\n        return sorted(ex) == sorted(wye)\n    else:\n        return False"}
{"task_id": "DSP/850", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    return list(map(lambda a,b: a + b, x, y))"}
{"task_id": "DSP/850", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    return list(map(lambda a,b: a + b, x, y))"}
{"task_id": "DSP/851", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    return list(map(lambda a,b: a - b, x, y))"}
{"task_id": "DSP/851", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    return list(map(lambda a,b: a - b, x, y))"}
{"task_id": "DSP/852", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    return list(map(lambda x: a * x, x))"}
{"task_id": "DSP/852", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    return list(map(lambda x: a * x, x))"}
{"task_id": "DSP/853", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    return sum(list(map(lambda a,b: a * b, x, y)))"}
{"task_id": "DSP/853", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    return sum(list(map(lambda a,b: a * b, x, y)))"}
{"task_id": "DSP/854", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    return sum(x)"}
{"task_id": "DSP/854", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    return sum(x)"}
{"task_id": "DSP/855", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    return math.sqrt(sum(x))"}
{"task_id": "DSP/855", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    return math.sqrt(sum(x))"}
{"task_id": "DSP/856", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    arr = list(map(lambda a,b: (b - a) ** 2, x, y))\n    return sum(arr)/len(arr)"}
{"task_id": "DSP/856", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    arr = list(map(lambda a,b: (b - a) ** 2, x, y))\n    return sum(arr)/len(arr)"}
{"task_id": "DSP/857", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    return sum(x)/len(x)"}
{"task_id": "DSP/857", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    return sum(x)/len(x)"}
{"task_id": "DSP/858", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    return mean(list(map(lambda a: (a - mean(x)) ** 2, x)))"}
{"task_id": "DSP/858", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    return mean(list(map(lambda a: (a - mean(x)) ** 2, x)))"}
{"task_id": "DSP/859", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/859", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return math.sqrt(var(x))"}
{"task_id": "DSP/860", "completion": "data = np.array(np.genfromtxt('open_exoplanet_catalogue.txt', dtype='float', comments='#', delimiter=',', skip_header=0))"}
{"task_id": "DSP/860", "completion": "data = np.array(np.genfromtxt('open_exoplanet_catalogue.txt', dtype='float', comments='#', delimiter=',', skip_header=0))"}
{"task_id": "DSP/861", "completion": "data = np.array(np.loadtxt('yearssn.dat'))\nyear = np.array([x[0] for x in data])\nssc = np.array([x[1] for x in data])"}
{"task_id": "DSP/861", "completion": "data = np.array(np.loadtxt('yearssn.dat'))\nyear = np.array([x[0] for x in data])\nssc = np.array([x[1] for x in data])"}
{"task_id": "DSP/862", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    # YOUR CODE HERE\n    return np.exp(mu + sigma * np.random.normal(size=size))"}
{"task_id": "DSP/862", "completion": "def log_normal(mu, sigma, size=1):\n    \"\"\"Return an array of size log-normal random variates.\"\"\"\n    # YOUR CODE HERE\n    return np.exp(mu + sigma * np.random.normal(size=size))"}
{"task_id": "DSP/863", "completion": "def fit(X, Y):\n    \"\"\"Fit X and Y data to the model Y ~ m*X + b and return (m,b)\"\"\"\n    # YOUR CODE HERE\n    def func(x, m, b):\n        return m * x + b\n    \n    a, b = curve_fit(func, X, Y)\n    \n    return a"}
{"task_id": "DSP/863", "completion": "def fit(X, Y):\n    \"\"\"Fit X and Y data to the model Y ~ m*X + b and return (m,b)\"\"\"\n    # YOUR CODE HERE\n    def func(x, m, b):\n        return m * x + b\n    \n    a, b = curve_fit(func, X, Y)\n    \n    return a"}
{"task_id": "DSP/864", "completion": "def bootstrap(X, Y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    X: ndarray\n        Input X array.\n    Y: ndarray\n    \n    Returns\n    -------\n    XX: ndarray\n        The boostrapped X array with the same shape as X and correlated random samples\n        drawn with replacement.\n    YY: ndarray\n        The bootstrapped Y array with the same shape as Y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    # YOUR CODE HERE\n    ind = np.random.randint(0, len(X), len(Y))\n    return X[ind], Y[ind]"}
{"task_id": "DSP/864", "completion": "def bootstrap(X, Y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    X: ndarray\n        Input X array.\n    Y: ndarray\n    \n    Returns\n    -------\n    XX: ndarray\n        The boostrapped X array with the same shape as X and correlated random samples\n        drawn with replacement.\n    YY: ndarray\n        The bootstrapped Y array with the same shape as Y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    # YOUR CODE HERE\n    ind = np.random.randint(0, len(X), len(Y))\n    return X[ind], Y[ind]"}
{"task_id": "DSP/865", "completion": "def fair(data):\n    \"\"\"Compute the fraction of the tosses that have a value of `H`.\"\"\"\n    # YOUR CODE HERE\n    heads = sum([d == 'H' for d in data])\n    return heads/len(data)"}
{"task_id": "DSP/865", "completion": "def fair(data):\n    \"\"\"Compute the fraction of the tosses that have a value of `H`.\"\"\"\n    # YOUR CODE HERE\n    heads = sum([d == 'H' for d in data])\n    return heads/len(data)"}
{"task_id": "DSP/866", "completion": "def bootstrap_data(data):\n    \"\"\"Perform a single boostrap resampling of the input data array.\"\"\"\n    # YOUR CODE HERE\n    return np.random.choice(data, len(data))"}
{"task_id": "DSP/866", "completion": "def bootstrap_data(data):\n    \"\"\"Perform a single boostrap resampling of the input data array.\"\"\"\n    # YOUR CODE HERE\n    return np.random.choice(data, len(data))"}
{"task_id": "DSP/867", "completion": "def bootstrap_function(data, f, n):\n    \"\"\"Compute a function on data bootstrapped n times.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The input data to be resampled.\n    f: function(data)\n        The function to be applied to the boostrapped data. The function should take a single\n        argument (the data) and return a float.\n    n: int\n        The number of times to resample the data\n        \n    Returns\n    -------\n    result: ndarray\n        An n element array of the values of the function applied to the resampled data.\n    \"\"\"\n    # YOUR CODE HERE\n    return np.array([f(bootstrap_data(data)) for x in range(n)])"}
{"task_id": "DSP/867", "completion": "def bootstrap_function(data, f, n):\n    \"\"\"Compute a function on data bootstrapped n times.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The input data to be resampled.\n    f: function(data)\n        The function to be applied to the boostrapped data. The function should take a single\n        argument (the data) and return a float.\n    n: int\n        The number of times to resample the data\n        \n    Returns\n    -------\n    result: ndarray\n        An n element array of the values of the function applied to the resampled data.\n    \"\"\"\n    # YOUR CODE HERE\n    return np.array([f(bootstrap_data(data)) for x in range(n)])"}
{"task_id": "DSP/868", "completion": "\u03bb1 = t1_avg\n\u03bb2 = t2_avg\nsim1 = np.random.poisson(\u03bb1, n)\nsim2 = np.random.poisson(\u03bb2, n)\nprint(sim1.mean(), sim2.mean())"}
{"task_id": "DSP/868", "completion": "\u03bb1 = t1_avg\n\u03bb2 = t2_avg\nsim1 = np.random.poisson(\u03bb1, n)\nsim2 = np.random.poisson(\u03bb2, n)\nprint(sim1.mean(), sim2.mean())"}
{"task_id": "DSP/869", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/869", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/870", "completion": "import pandas as pd\nimport numpy as np\n\names_data = pd.read_table(\"ames_train.csv\", sep = \",\")\n\nprint(ames_data.head())"}
{"task_id": "DSP/870", "completion": "import pandas as pd\nimport numpy as np\n\names_data = pd.read_table(\"ames_train.csv\", sep = \",\")\n\nprint(ames_data.head())"}
{"task_id": "DSP/871", "completion": "ames_data['sqft_sum'] = ames_data[\"1stFlrSF\"] + ames_data[\"2ndFlrSF\"]\nplt.scatter(ames_data[\"sqft_sum\"], ames_data[\"SalePrice\"])\noutlier = ames_data.index[ames_data[\"sqft_sum\"] > 4500].tolist()\nprint(outlier)\nprint(list(ames_data.shape)) # shape before outliers are dropped\names_data.drop([523,1298], axis = 0, inplace = True)\nplt.scatter(ames_data[\"sqft_sum\"], ames_data[\"SalePrice\"])\nprint(list(ames_data.shape))"}
{"task_id": "DSP/871", "completion": "ames_data['sqft_sum'] = ames_data[\"1stFlrSF\"] + ames_data[\"2ndFlrSF\"]\nplt.scatter(ames_data[\"sqft_sum\"], ames_data[\"SalePrice\"])\noutlier = ames_data.index[ames_data[\"sqft_sum\"] > 4500].tolist()\nprint(outlier)\nprint(list(ames_data.shape)) # shape before outliers are dropped\names_data.drop([523,1298], axis = 0, inplace = True)\nplt.scatter(ames_data[\"sqft_sum\"], ames_data[\"SalePrice\"])\nprint(list(ames_data.shape))"}
{"task_id": "DSP/872", "completion": "from sklearn.model_selection import train_test_split\n\nX = ames_data[[\"sqft_sum\", \"Fireplaces\"]]\ny = ames_data['SalePrice']\n# Now we will split your data into training and test, for evaluation\n# Note the function below\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state=12323)\n# train_test_split(): Split arrays or matrices into random train and test subsets"}
{"task_id": "DSP/872", "completion": "from sklearn.model_selection import train_test_split\n\nX = ames_data[[\"sqft_sum\", \"Fireplaces\"]]\ny = ames_data['SalePrice']\n# Now we will split your data into training and test, for evaluation\n# Note the function below\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state=12323)\n# train_test_split(): Split arrays or matrices into random train and test subsets"}
{"task_id": "DSP/873", "completion": "from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\n\nlr = LinearRegression()\nlr.fit(X_train, y_train) # train my model\ny_preds = lr.predict(X_test) # predict y values based off of x values\n\nrmse = np.sqrt(mean_squared_error(y_preds, y_test))\n# The RMSD (or RMSE) represents the sample standard deviation of the differences between \n# predicted values and observed values.\n\nlr.score(X_train, y_train) # r^2 value (coefficient of determination)\nlr.score(X_test,y_test)\nlr.coef_\n\n# Documentation:\n# http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html"}
{"task_id": "DSP/873", "completion": "from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\n\nlr = LinearRegression()\nlr.fit(X_train, y_train) # train my model\ny_preds = lr.predict(X_test) # predict y values based off of x values\n\nrmse = np.sqrt(mean_squared_error(y_preds, y_test))\n# The RMSD (or RMSE) represents the sample standard deviation of the differences between \n# predicted values and observed values.\n\nlr.score(X_train, y_train) # r^2 value (coefficient of determination)\nlr.score(X_test,y_test)\nlr.coef_\n\n# Documentation:\n# http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html"}
{"task_id": "DSP/874", "completion": "def add2(a, b):\n    return a + b"}
{"task_id": "DSP/874", "completion": "def add2(a, b):\n    return a + b"}
{"task_id": "DSP/875", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/875", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/876", "completion": "from math import sqrt\n### END SOLUTION\n\ndef sqrt_initial(n2):\n    \"\"\"determine an approximate value for the square root of n2\n    \n       This function uses math.sqrt on the first 12 or 13 digits\n       of n2 for an even or odd number of digits of n2, respectively,\n       to obtain an integer approximation for the square root of n2.\n       The result can serve as an input for determining the square root\n       of an integer by means of Newton's method.\n    \n    \"\"\"\n    ### BEGIN SOLUTION\n    n2_str = str(n2)\n    nrdigits = len(n2_str)\n    keepdigits = 12 + (nrdigits % 2)\n    if keepdigits > nrdigits:\n        return int(sqrt(n2))\n    leadingdigits = n2_str[:keepdigits]\n    lead_sqrt_estimate = sqrt(float(leadingdigits))\n    return int(lead_sqrt_estimate)*10**((nrdigits-keepdigits)//2)\n    ### END SOLUTION"}
{"task_id": "DSP/876", "completion": "from math import sqrt\n### END SOLUTION\n\ndef sqrt_initial(n2):\n    \"\"\"determine an approximate value for the square root of n2\n    \n       This function uses math.sqrt on the first 12 or 13 digits\n       of n2 for an even or odd number of digits of n2, respectively,\n       to obtain an integer approximation for the square root of n2.\n       The result can serve as an input for determining the square root\n       of an integer by means of Newton's method.\n    \n    \"\"\"\n    ### BEGIN SOLUTION\n    n2_str = str(n2)\n    nrdigits = len(n2_str)\n    keepdigits = 12 + (nrdigits % 2)\n    if keepdigits > nrdigits:\n        return int(sqrt(n2))\n    leadingdigits = n2_str[:keepdigits]\n    lead_sqrt_estimate = sqrt(float(leadingdigits))\n    return int(lead_sqrt_estimate)*10**((nrdigits-keepdigits)//2)\n    ### END SOLUTION"}
{"task_id": "DSP/877", "completion": "def int_agm_iteration(a, b):\n    \"\"\"perform one arithmetic-geometric iteration for\n       a pair of integers\n    \n       This function takes two integers a and b as\n       a_n and b_n and returns a_{n+1}, b_{n+1},\n       and the difference of their squares.\n    \"\"\"\n    # BEGIN SOLUTION\n    a, b = (a+b)//2, int_sqrt(a*b, sqrt_initial(a*b))\n    c2 = a*a-b*b\n    return a, b, c2\n    # END SOLUTION"}
{"task_id": "DSP/877", "completion": "def int_agm_iteration(a, b):\n    \"\"\"perform one arithmetic-geometric iteration for\n       a pair of integers\n    \n       This function takes two integers a and b as\n       a_n and b_n and returns a_{n+1}, b_{n+1},\n       and the difference of their squares.\n    \"\"\"\n    # BEGIN SOLUTION\n    a, b = (a+b)//2, int_sqrt(a*b, sqrt_initial(a*b))\n    c2 = a*a-b*b\n    return a, b, c2\n    # END SOLUTION"}
{"task_id": "DSP/878", "completion": "def pi_agm_int(scale):\n    \"\"\"determine pi by means of the arithmetic-geometric mean\n       using integer arithmetic after expanding the fraction by\n       scale**2\n       \n       scale: numerator and denominator are expanded by the\n              square of this parameter, typically a power of ten\n    \"\"\"\n    ### BEGIN SOLUTION\n    a = scale\n    halfscaled = scale**2//2\n    b = int_sqrt(halfscaled, sqrt_initial(halfscaled))\n    denominator = scale**2\n    factor_two = 2\n    while a != b:\n        a, b, c2 = int_agm_iteration(a, b)\n        factor_two = 2*factor_two\n        denominator = denominator-factor_two*c2\n    numerator = 4*a**2\n    return numerator*scale//denominator\n    ### END SOLUTION"}
{"task_id": "DSP/878", "completion": "def pi_agm_int(scale):\n    \"\"\"determine pi by means of the arithmetic-geometric mean\n       using integer arithmetic after expanding the fraction by\n       scale**2\n       \n       scale: numerator and denominator are expanded by the\n              square of this parameter, typically a power of ten\n    \"\"\"\n    ### BEGIN SOLUTION\n    a = scale\n    halfscaled = scale**2//2\n    b = int_sqrt(halfscaled, sqrt_initial(halfscaled))\n    denominator = scale**2\n    factor_two = 2\n    while a != b:\n        a, b, c2 = int_agm_iteration(a, b)\n        factor_two = 2*factor_two\n        denominator = denominator-factor_two*c2\n    numerator = 4*a**2\n    return numerator*scale//denominator\n    ### END SOLUTION"}
{"task_id": "DSP/879", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n# metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n###END SOLUTION"}
{"task_id": "DSP/879", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n# metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n###END SOLUTION"}
{"task_id": "DSP/880", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/880", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/881", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/881", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/882", "completion": "def k_nearest_classes(x, k=1):\n    ### BEGIN SOLUTION\n    dists = distances(x)\n    if k==1:\n        return np.array[train_labels[np.argmin(dists)]]\n    return train_labels[np.argsort(dists)[:k]]\n    \n    ###END SOLUTION"}
{"task_id": "DSP/882", "completion": "def k_nearest_classes(x, k=1):\n    ### BEGIN SOLUTION\n    dists = distances(x)\n    if k==1:\n        return np.array[train_labels[np.argmin(dists)]]\n    return train_labels[np.argsort(dists)[:k]]\n    \n    ###END SOLUTION"}
{"task_id": "DSP/883", "completion": "def classify(x, k=1):\n    ### BEGIN SOLUTION\n    if len(x.shape)>1:\n        return np.array([np.bincount(k_nearest_classes(t, k)).argmax() for t in x])\n    return np.bincount(k_nearest_classes(x, k)).argmax()\n    \n    ###END SOLUTION"}
{"task_id": "DSP/883", "completion": "def classify(x, k=1):\n    ### BEGIN SOLUTION\n    if len(x.shape)>1:\n        return np.array([np.bincount(k_nearest_classes(t, k)).argmax() for t in x])\n    return np.bincount(k_nearest_classes(x, k)).argmax()\n    \n    ###END SOLUTION"}
{"task_id": "DSP/884", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test, k)==test_labels)/len(test_labels)    \n###END SOLUTION"}
{"task_id": "DSP/884", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test, k)==test_labels)/len(test_labels)    \n###END SOLUTION"}
{"task_id": "DSP/885", "completion": "class kNNClassifier():\n    def __init__(self, n_neighbors):\n        pass\n    #zapamietaj dane treningowe\n    def fit(self, train, train_labels):\n        pass\n    #metoda wyznaczjaca odleg\u0142o\u015bci\n    def distances(self, x):\n        pass\n    #znajd\u017a klasy k s\u0105siad\u00f3w\n    def kneighbors(self, x, k):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    \n    def __init__(self, n_neighbors):\n        self.k = n_neighbors\n        \n    def fit(self, train, train_labels):\n        self.train = train\n        self.train_labels = train_labels\n    \n    def distances(self, x):\n        return np.sqrt(np.sum( (x - self.train)**2, axis=1))\n        \n    def kneighbors(self, x, k):  \n        dists = self.distances(x)\n        if k==1:\n            return [self.train_labels[np.argmin(dists)]]\n        return self.train_labels[np.argsort(dists)[:k]]\n        \n    def predict(self, test):\n        if len(test.shape)>1:\n            return np.array([np.bincount(self.kneighbors(t, self.k)).argmax() for t in test])\n        return np.bincount(self.kneighbors(test, self.k)).argmax()\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/885", "completion": "class kNNClassifier():\n    def __init__(self, n_neighbors):\n        pass\n    #zapamietaj dane treningowe\n    def fit(self, train, train_labels):\n        pass\n    #metoda wyznaczjaca odleg\u0142o\u015bci\n    def distances(self, x):\n        pass\n    #znajd\u017a klasy k s\u0105siad\u00f3w\n    def kneighbors(self, x, k):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    \n    def __init__(self, n_neighbors):\n        self.k = n_neighbors\n        \n    def fit(self, train, train_labels):\n        self.train = train\n        self.train_labels = train_labels\n    \n    def distances(self, x):\n        return np.sqrt(np.sum( (x - self.train)**2, axis=1))\n        \n    def kneighbors(self, x, k):  \n        dists = self.distances(x)\n        if k==1:\n            return [self.train_labels[np.argmin(dists)]]\n        return self.train_labels[np.argsort(dists)[:k]]\n        \n    def predict(self, test):\n        if len(test.shape)>1:\n            return np.array([np.bincount(self.kneighbors(t, self.k)).argmax() for t in test])\n        return np.bincount(self.kneighbors(test, self.k)).argmax()\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/886", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n#metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n### END SOLUTION"}
{"task_id": "DSP/886", "completion": "%matplotlib inline\nimport numpy as np \nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets \nfrom sklearn.neighbors import NearestCentroid\nimport matplotlib.pyplot as plt\n\n#metoda generujaca dane treningowe i testowe\nfrom sklearn.datasets import make_blobs\n\nblobs_data = None\nblobs_target = None\n\n### BEGIN SOLUTION\nblobs_data, blobs_target = make_blobs(n_samples = 500, n_features=2, centers=3, random_state=2)\n### END SOLUTION"}
{"task_id": "DSP/887", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/887", "completion": "def normalize(v):\n### BEGIN SOLUTION\n    return (v-np.mean(v,axis=0))/np.std(v,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/888", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/888", "completion": "train, test, train_labels, test_labels = None, None, None, None\n\n### BEGIN SOLUTION\ntrain, test, train_labels, test_labels = \\\n                        train_test_split(blobs_data_normalized, blobs_target, test_size=0.3, random_state=123)\n###END SOLUTION"}
{"task_id": "DSP/889", "completion": "class_means = None\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/889", "completion": "class_means = None\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/890", "completion": "def distances(x):\n    ### BEGIN SOLUTION\n    return np.stack([ np.sqrt(np.sum( (x - class_means[i])**2, axis=1)) for i in range(len(class_means)) ]).T\n    \n    ###END SOLUTION"}
{"task_id": "DSP/890", "completion": "def distances(x):\n    ### BEGIN SOLUTION\n    return np.stack([ np.sqrt(np.sum( (x - class_means[i])**2, axis=1)) for i in range(len(class_means)) ]).T\n    \n    ###END SOLUTION"}
{"task_id": "DSP/891", "completion": "def classify(x):\n    ### BEGIN SOLUTION\n    return np.argmin(distances(x), axis=1)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/891", "completion": "def classify(x):\n    ### BEGIN SOLUTION\n    return np.argmin(distances(x), axis=1)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/892", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test)==test_labels)/len(test_labels)\n    \n###END SOLUTION"}
{"task_id": "DSP/892", "completion": "score = None\n### BEGIN SOLUTION\nscore = np.sum(classify(test)==test_labels)/len(test_labels)\n    \n###END SOLUTION"}
{"task_id": "DSP/893", "completion": "class MinimumDistanceClassifier():\n    #wyznacza elementy reprezentatywne\n    def fit(self, train, train_labels):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    def fit(self, train, train_labels):\n        self.class_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) \\\n                                                              for i in np.unique(train_labels) ])\n    \n    def predict(self, test):\n        dists = np.stack([ np.sqrt(np.sum( (test - self.class_means[i])**2, axis=1)) \\\n                                                                  for i in range(len(self.class_means)) ]).T\n        return np.argmin(dists, axis=1)\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/893", "completion": "class MinimumDistanceClassifier():\n    #wyznacza elementy reprezentatywne\n    def fit(self, train, train_labels):\n        pass\n    #wyznacza klas\u0119 dla ka\u017cdej danej testowej\n    def predict(self, test):\n        pass\n    #wyznacza dok\u0142adno\u015b\u0107 klasyfikatora\n    def score(self, test, test_labels):\n        pass\n    ### BEGIN SOLUTION\n    def fit(self, train, train_labels):\n        self.class_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) \\\n                                                              for i in np.unique(train_labels) ])\n    \n    def predict(self, test):\n        dists = np.stack([ np.sqrt(np.sum( (test - self.class_means[i])**2, axis=1)) \\\n                                                                  for i in range(len(self.class_means)) ]).T\n        return np.argmin(dists, axis=1)\n    \n    def score(self, test, test_labels):\n        return np.sum(self.predict(test)==test_labels)/len(test_labels)\n    \n    ###END SOLUTION"}
{"task_id": "DSP/894", "completion": "Nlabels = None\n### BEGIN SOLUTION\nNlabels = np.unique(train_targets)\nNlabels\n### END SOLUTION"}
{"task_id": "DSP/894", "completion": "Nlabels = None\n### BEGIN SOLUTION\nNlabels = np.unique(train_targets)\nNlabels\n### END SOLUTION"}
{"task_id": "DSP/895", "completion": "correct = None\n### BEGIN SOLUTION\ncorrect = np.sum(Z==test_targets)/np.size(Z)\n### END SOLUTION"}
{"task_id": "DSP/895", "completion": "correct = None\n### BEGIN SOLUTION\ncorrect = np.sum(Z==test_targets)/np.size(Z)\n### END SOLUTION"}
{"task_id": "DSP/896", "completion": "p = None\n### BEGIN SOLUTION\np = [np.sum(train_targets==ith)/train_targets.shape[0] for ith in range(3) ]\n### END SOLUTION"}
{"task_id": "DSP/896", "completion": "p = None\n### BEGIN SOLUTION\np = [np.sum(train_targets==ith)/train_targets.shape[0] for ith in range(3) ]\n### END SOLUTION"}
{"task_id": "DSP/897", "completion": "mu = None\n### BEGIN SOLUTION\nmu = np.stack([np.mean(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/897", "completion": "mu = None\n### BEGIN SOLUTION\nmu = np.stack([np.mean(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/898", "completion": "sigma2 = None\n### BEGIN SOLUTION\nsigma2 = np.stack([np.var(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/898", "completion": "sigma2 = None\n### BEGIN SOLUTION\nsigma2 = np.stack([np.var(train[train_targets == ith],axis=0) for ith in [0,1,2]])\n### END SOLUTION"}
{"task_id": "DSP/899", "completion": "prediction = None\n### BEGIN SOLUTION\nprediction = np.argmax(P,axis=1)\n### END SOLUTION"}
{"task_id": "DSP/899", "completion": "prediction = None\n### BEGIN SOLUTION\nprediction = np.argmax(P,axis=1)\n### END SOLUTION"}
{"task_id": "DSP/900", "completion": "import numpy as np\n### END SOLUTION"}
{"task_id": "DSP/900", "completion": "import numpy as np\n### END SOLUTION"}
{"task_id": "DSP/901", "completion": "v = np.zeros(10)\n### END SOLUTION"}
{"task_id": "DSP/901", "completion": "v = np.zeros(10)\n### END SOLUTION"}
{"task_id": "DSP/902", "completion": "def memof(a):\n### BEGIN SOLUTION\n    return  a.nbytes\n### END SOLUTION"}
{"task_id": "DSP/902", "completion": "def memof(a):\n### BEGIN SOLUTION\n    return  a.nbytes\n### END SOLUTION"}
{"task_id": "DSP/903", "completion": "def make_v(n):\n### BEGIN SOLUTION\n    v = np.zeros(n)\n    v[4] = 1\n    return v\n### END SOLUTION"}
{"task_id": "DSP/903", "completion": "def make_v(n):\n### BEGIN SOLUTION\n    v = np.zeros(n)\n    v[4] = 1\n    return v\n### END SOLUTION"}
{"task_id": "DSP/904", "completion": "def make10_49():\n### BEGIN SOLUTION\n    v = np.arange(10,50)\n    return v\n### END SOLUTION"}
{"task_id": "DSP/904", "completion": "def make10_49():\n### BEGIN SOLUTION\n    v = np.arange(10,50)\n    return v\n### END SOLUTION"}
{"task_id": "DSP/905", "completion": "def reverse(v):\n### BEGIN SOLUTION\n    return v[::-1]\n### END SOLUTION"}
{"task_id": "DSP/905", "completion": "def reverse(v):\n### BEGIN SOLUTION\n    return v[::-1]\n### END SOLUTION"}
{"task_id": "DSP/906", "completion": "def identity_matrix(n=3):\n### BEGIN SOLUTION\n    return np.eye(n)\n### END SOLUTION"}
{"task_id": "DSP/906", "completion": "def identity_matrix(n=3):\n### BEGIN SOLUTION\n    return np.eye(n)\n### END SOLUTION"}
{"task_id": "DSP/907", "completion": "def n2_col(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n)\n### END SOLUTION\ndef n2_row(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n).T\n### END SOLUTION"}
{"task_id": "DSP/907", "completion": "def n2_col(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n)\n### END SOLUTION\ndef n2_row(n=3):\n### BEGIN SOLUTION\n    return np.arange(1,n**2+1).reshape(n,n).T\n### END SOLUTION"}
{"task_id": "DSP/908", "completion": "def rand1(n=3, m=4):\n### BEGIN SOLUTION\n    return np.random.random((n,m))\n### END SOLUTION\ndef rand2(n=3, m=4, a=6, b=7):\n### BEGIN SOLUTION\n    return np.random.randint(a,b,size=(n,m))\n### END SOLUTION"}
{"task_id": "DSP/908", "completion": "def rand1(n=3, m=4):\n### BEGIN SOLUTION\n    return np.random.random((n,m))\n### END SOLUTION\ndef rand2(n=3, m=4, a=6, b=7):\n### BEGIN SOLUTION\n    return np.random.randint(a,b,size=(n,m))\n### END SOLUTION"}
{"task_id": "DSP/909", "completion": "def is_zero(x):\n### BEGIN SOLUTION\n    return np.where(x==0)[0]\n### END SOLUTION"}
{"task_id": "DSP/909", "completion": "def is_zero(x):\n### BEGIN SOLUTION\n    return np.where(x==0)[0]\n### END SOLUTION"}
{"task_id": "DSP/910", "completion": "def mystats(x):\n### BEGIN SOLUTION\n    return  np.nanmin(x),np.nanmax(x),np.nanmean(x)\n### END SOLUTION"}
{"task_id": "DSP/910", "completion": "def mystats(x):\n### BEGIN SOLUTION\n    return  np.nanmin(x),np.nanmax(x),np.nanmean(x)\n### END SOLUTION"}
{"task_id": "DSP/911", "completion": "def zeros_padded(n=4):\n### BEGIN SOLUTION\n    return  np.pad(np.zeros((n-2,n-2)),1,'constant',constant_values=1)\n### END SOLUTION"}
{"task_id": "DSP/911", "completion": "def zeros_padded(n=4):\n### BEGIN SOLUTION\n    return  np.pad(np.zeros((n-2,n-2)),1,'constant',constant_values=1)\n### END SOLUTION"}
{"task_id": "DSP/912", "completion": "def pad3(x):\n### BEGIN SOLUTION\n    return  np.pad(x,1,'constant',constant_values=3)\n### END SOLUTION"}
{"task_id": "DSP/912", "completion": "def pad3(x):\n### BEGIN SOLUTION\n    return  np.pad(x,1,'constant',constant_values=3)\n### END SOLUTION"}
{"task_id": "DSP/913", "completion": "def maxto0(x):\n### BEGIN SOLUTION\n    x = x.copy()\n    max_x = np.max(x)\n    x[x == max_x] = 0 \n    return  x\n### END SOLUTION"}
{"task_id": "DSP/913", "completion": "def maxto0(x):\n### BEGIN SOLUTION\n    x = x.copy()\n    max_x = np.max(x)\n    x[x == max_x] = 0 \n    return  x\n### END SOLUTION"}
{"task_id": "DSP/914", "completion": "def data_stats(x):\n### BEGIN SOLUTION\n    x_avg = np.sum(x,axis=0)/x.shape[0]\n    Delta = x - x_avg[np.newaxis,:]\n    sigma = np.sum((x - x_avg[np.newaxis,:])**2,axis=0)/x.shape[0]\n    return  x_avg,Delta,sigma\n### END SOLUTION"}
{"task_id": "DSP/914", "completion": "def data_stats(x):\n### BEGIN SOLUTION\n    x_avg = np.sum(x,axis=0)/x.shape[0]\n    Delta = x - x_avg[np.newaxis,:]\n    sigma = np.sum((x - x_avg[np.newaxis,:])**2,axis=0)/x.shape[0]\n    return  x_avg,Delta,sigma\n### END SOLUTION"}
{"task_id": "DSP/915", "completion": "def s1(a,b):\n    ### BEGIN SOLUTION\n    if(len(a) != len(b)):\n        raise ValueError(\"Given vectors should have the same length!.\")\n    return sum([i*j for i,j in zip(a,b)])\n    ### END SOLUTION\n\ndef s2(a,b):\n    ### BEGIN SOLUTION\n    return np.dot(a,b)\n    ### END SOLUTION"}
{"task_id": "DSP/915", "completion": "def s1(a,b):\n    ### BEGIN SOLUTION\n    if(len(a) != len(b)):\n        raise ValueError(\"Given vectors should have the same length!.\")\n    return sum([i*j for i,j in zip(a,b)])\n    ### END SOLUTION\n\ndef s2(a,b):\n    ### BEGIN SOLUTION\n    return np.dot(a,b)\n    ### END SOLUTION"}
{"task_id": "DSP/916", "completion": "def y1(A,x):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != x.shape[0]):\n        raise ValueError(\"Second dimension of matrix should be the same as dimension of vector!.\")\n    return([sum([i*j for i,j in zip(z,x)]) for z in A])\n    ### END SOLUTION \n\ndef y2(A,x):\n    ### BEGIN SOLUTION\n    return(np.array([np.dot(row,x) for row in A]))\n    ### END SOLUTION\n    \ndef y3(A,x):\n    ### BEGIN SOLUTION\n    return(np.dot(A,x))\n    #return(np.tensordot(A,x,[1,1,1],1)\n    ### END SOLUTION"}
{"task_id": "DSP/916", "completion": "def y1(A,x):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != x.shape[0]):\n        raise ValueError(\"Second dimension of matrix should be the same as dimension of vector!.\")\n    return([sum([i*j for i,j in zip(z,x)]) for z in A])\n    ### END SOLUTION \n\ndef y2(A,x):\n    ### BEGIN SOLUTION\n    return(np.array([np.dot(row,x) for row in A]))\n    ### END SOLUTION\n    \ndef y3(A,x):\n    ### BEGIN SOLUTION\n    return(np.dot(A,x))\n    #return(np.tensordot(A,x,[1,1,1],1)\n    ### END SOLUTION"}
{"task_id": "DSP/917", "completion": "def C1(A,B):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != np.shape(B)[0]):\n        raise ValueError(\"Second dimension of 1st matrix should be the same as first dimension of 2nd matrix!.\")\n    return(np.asarray([[sum([i*j for i,j in zip(z,B[:,f])]) for z in A] for f in range(np.shape(B)[1])]).T)\n    ### END SOLUTION\n    \ndef C2(A,B):\n    ### BEGIN SOLUTION\n    return(np.asarray([[s1(z,B[:,f]) for z in A] for f in range(np.shape(B)[1])]).T) \n    ### END SOLUTION\n    \ndef C3(A,B):\n    ### BEGIN SOLUTION\n    return(np.dot(A,B))\n    ### END SOLUTION"}
{"task_id": "DSP/917", "completion": "def C1(A,B):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[1] != np.shape(B)[0]):\n        raise ValueError(\"Second dimension of 1st matrix should be the same as first dimension of 2nd matrix!.\")\n    return(np.asarray([[sum([i*j for i,j in zip(z,B[:,f])]) for z in A] for f in range(np.shape(B)[1])]).T)\n    ### END SOLUTION\n    \ndef C2(A,B):\n    ### BEGIN SOLUTION\n    return(np.asarray([[s1(z,B[:,f]) for z in A] for f in range(np.shape(B)[1])]).T) \n    ### END SOLUTION\n    \ndef C3(A,B):\n    ### BEGIN SOLUTION\n    return(np.dot(A,B))\n    ### END SOLUTION"}
{"task_id": "DSP/918", "completion": "def Tr(A):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[0] != np.shape(A)[1]):\n        raise ValueError('The matrix should be square matrix!.')\n    return(sum([A[p,p] for p in range(np.shape(A)[1])]))\n    ### END SOLUTION"}
{"task_id": "DSP/918", "completion": "def Tr(A):\n    ### BEGIN SOLUTION\n    if(np.shape(A)[0] != np.shape(A)[1]):\n        raise ValueError('The matrix should be square matrix!.')\n    return(sum([A[p,p] for p in range(np.shape(A)[1])]))\n    ### END SOLUTION"}
{"task_id": "DSP/919", "completion": "def Le(A):\n    ### BEGIN SOLUTION\n    if A.shape == (1,1):\n        return A[0,0]\n    else:\n        j = 0\n        d = 0\n        for i in range(A.shape[0]):\n            M = np.concatenate( [np.concatenate( [A[:i,:j], A[:i,j+1:]], axis=1 ),\\\n                                 np.concatenate( [A[i+1:,:j], A[i+1:,j+1:]], axis=1 )],axis=0)\n            d += (-1)**(i+j)*A[i,j]*Le(M)\n        return d\n    ### END SOLUTION"}
{"task_id": "DSP/919", "completion": "def Le(A):\n    ### BEGIN SOLUTION\n    if A.shape == (1,1):\n        return A[0,0]\n    else:\n        j = 0\n        d = 0\n        for i in range(A.shape[0]):\n            M = np.concatenate( [np.concatenate( [A[:i,:j], A[:i,j+1:]], axis=1 ),\\\n                                 np.concatenate( [A[i+1:,:j], A[i+1:,j+1:]], axis=1 )],axis=0)\n            d += (-1)**(i+j)*A[i,j]*Le(M)\n        return d\n    ### END SOLUTION"}
{"task_id": "DSP/920", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/x.shape[0]*np.sum( (sigmoid(w*x+b)-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/920", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/x.shape[0]*np.sum( (sigmoid(w*x+b)-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/921", "completion": "dw, db = None, None\n\n### BEGIN SOLUTION\ndw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\ndb = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n### END SOLUTION"}
{"task_id": "DSP/921", "completion": "dw, db = None, None\n\n### BEGIN SOLUTION\ndw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\ndb = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n### END SOLUTION"}
{"task_id": "DSP/922", "completion": "dw_num, db_num = None, None\n\n### BEGIN SOLUTION\ndw_num = (L(w+0.001,b)-L(w,b))/0.001\ndb_num = (L(w,b+0.001)-L(w,b))/0.001\n### END SOLUTION"}
{"task_id": "DSP/922", "completion": "dw_num, db_num = None, None\n\n### BEGIN SOLUTION\ndw_num = (L(w+0.001,b)-L(w,b))/0.001\ndb_num = (L(w,b+0.001)-L(w,b))/0.001\n### END SOLUTION"}
{"task_id": "DSP/923", "completion": "alpha = 1.0\nw, b = 1., 3.\nfor i in range(100):\n    pass  \n### BEGIN SOLUTION\n    \n    dw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\n    db = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n    \n    w = w - alpha*dw\n    b = b - alpha*db\n### END SOLUTION\n    \nprint(L(w,b),w,b,dw,db)"}
{"task_id": "DSP/923", "completion": "alpha = 1.0\nw, b = 1., 3.\nfor i in range(100):\n    pass  \n### BEGIN SOLUTION\n    \n    dw = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b)*x)\n    db = 1/m*(sigmoid(w*x+b)-y).dot(sigmoid_p(w*x+b))\n    \n    w = w - alpha*dw\n    b = b - alpha*db\n### END SOLUTION\n    \nprint(L(w,b),w,b,dw,db)"}
{"task_id": "DSP/924", "completion": "C = np.cov(X.T)\n### END SOLUTION\nC"}
{"task_id": "DSP/924", "completion": "C = np.cov(X.T)\n### END SOLUTION\nC"}
{"task_id": "DSP/925", "completion": "def kowariancja(X):\n### BEGIN SOLUTION\n    m = np.mean(X,axis=0)\n    C = 1/(X.shape[0]-1)*np.dot( (X-m).T,X-m)\n    return C\n### END SOLUTION"}
{"task_id": "DSP/925", "completion": "def kowariancja(X):\n### BEGIN SOLUTION\n    m = np.mean(X,axis=0)\n    C = 1/(X.shape[0]-1)*np.dot( (X-m).T,X-m)\n    return C\n### END SOLUTION"}
{"task_id": "DSP/926", "completion": "C = None\n### BEGIN SOLUTION\nC = np.cov(Xorig.T)\n### END SOLUTION"}
{"task_id": "DSP/926", "completion": "C = None\n### BEGIN SOLUTION\nC = np.cov(Xorig.T)\n### END SOLUTION"}
{"task_id": "DSP/927", "completion": "class Network:\n    def __init__(self, inputs):\n        self.layers = []\n        self.numberOfInputs = inputs\n        self.numberOfLayers = 0\n        \n    def addLayer(self, neurons):\n        ### BEGIN SOLUTION\n        if self.numberOfLayers == 0:\n            self.layers.append(Layer(neurons, self.numberOfInputs))\n        else:\n            self.layers.append(Layer(neurons, self.layers[self.numberOfLayers - 1].numberOfNeurons))\n        self.numberOfLayers += 1\n        ### END SOLUTION\n        \n    def forward(self, inputVector):\n        ### BEGIN SOLUTION\n        tmp = inputVector\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[i].forward(tmp)\n        return tmp\n        ### END SOLUTION\n    \n    def backward(self, gradient):\n        ### BEGIN SOLUTION\n        tmp = gradient\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[self.numberOfLayers - 1 - i].backward(tmp)\n        return tmp\n        ### END SOLUTION\n            \n    def learn(self,learningRate):\n        ### BEGIN SOLUTION\n        for i in range(self.numberOfLayers):\n            self.layers[i].learn(learningRate)\n        ### END SOLUTION"}
{"task_id": "DSP/927", "completion": "class Network:\n    def __init__(self, inputs):\n        self.layers = []\n        self.numberOfInputs = inputs\n        self.numberOfLayers = 0\n        \n    def addLayer(self, neurons):\n        ### BEGIN SOLUTION\n        if self.numberOfLayers == 0:\n            self.layers.append(Layer(neurons, self.numberOfInputs))\n        else:\n            self.layers.append(Layer(neurons, self.layers[self.numberOfLayers - 1].numberOfNeurons))\n        self.numberOfLayers += 1\n        ### END SOLUTION\n        \n    def forward(self, inputVector):\n        ### BEGIN SOLUTION\n        tmp = inputVector\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[i].forward(tmp)\n        return tmp\n        ### END SOLUTION\n    \n    def backward(self, gradient):\n        ### BEGIN SOLUTION\n        tmp = gradient\n        for i in range(self.numberOfLayers):\n            tmp = self.layers[self.numberOfLayers - 1 - i].backward(tmp)\n        return tmp\n        ### END SOLUTION\n            \n    def learn(self,learningRate):\n        ### BEGIN SOLUTION\n        for i in range(self.numberOfLayers):\n            self.layers[i].learn(learningRate)\n        ### END SOLUTION"}
{"task_id": "DSP/928", "completion": "w = None\n### BEGIN SOLUTION\nw = svm.coef_[0]\nt = svm.intercept_[0]\n### END SOLUTION"}
{"task_id": "DSP/928", "completion": "w = None\n### BEGIN SOLUTION\nw = svm.coef_[0]\nt = svm.intercept_[0]\n### END SOLUTION"}
{"task_id": "DSP/929", "completion": "km = None\n### BEGIN SOLUTION\nkm = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n### END SOLUTION"}
{"task_id": "DSP/929", "completion": "km = None\n### BEGIN SOLUTION\nkm = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n### END SOLUTION"}
{"task_id": "DSP/930", "completion": "c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n### END SOLUTION"}
{"task_id": "DSP/930", "completion": "c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n### END SOLUTION"}
{"task_id": "DSP/931", "completion": "SSE = None\n### BEGIN SOLUTION\nSSE   = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n### END SOLUTION"}
{"task_id": "DSP/931", "completion": "SSE = None\n### BEGIN SOLUTION\nSSE   = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n### END SOLUTION"}
{"task_id": "DSP/932", "completion": "for i in range(10):\n    km = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n\n    c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n    \n    SSE = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n    \n    print( SSE )\n    \n### END SOLUTION"}
{"task_id": "DSP/932", "completion": "for i in range(10):\n    km = np.argmin(np.sum( (c[np.newaxis,:,:]-X[:,np.newaxis,:])**2,axis=-1),axis=-1)\n\n    c  = np.stack([np.mean(X[km==c_],axis=0) for c_ in range(n_clusters)])\n    \n    SSE = np.sum(np.var(X[km==c_,:]) for c_ in range(n_clusters))\n    \n    print( SSE )\n    \n### END SOLUTION"}
{"task_id": "DSP/933", "completion": "n = 10\nalpha = 0.1\nw, b = 1, 0.1\nhist = []\nfor i in range(100):    \n\n    ith = [ 3,4  ] ## randomize!\n    x = None\n    y = None\n### BEGIN SOLUTION\n    ith = np.random.choice(m,n,replace=False)\n    x = x_orig[ith]\n    y = y_orig[ith]\n### END SOLUTION\n    \n    dw = 1/n*(w*x+b-y).dot(x)\n    db = 1/n*np.sum(w*x+b-y)\n\n    w = w - alpha*dw\n    b = b - alpha*db\n    \n    if i%10==0:\n        print(L(w,b),w,b,end='\\r')\n        l.set_data(xlin,w*xlin+b)\n        fig.canvas.draw()\n    hist.append(L(w,b))\n    #sleep(0.1)"}
{"task_id": "DSP/933", "completion": "n = 10\nalpha = 0.1\nw, b = 1, 0.1\nhist = []\nfor i in range(100):    \n\n    ith = [ 3,4  ] ## randomize!\n    x = None\n    y = None\n### BEGIN SOLUTION\n    ith = np.random.choice(m,n,replace=False)\n    x = x_orig[ith]\n    y = y_orig[ith]\n### END SOLUTION\n    \n    dw = 1/n*(w*x+b-y).dot(x)\n    db = 1/n*np.sum(w*x+b-y)\n\n    w = w - alpha*dw\n    b = b - alpha*db\n    \n    if i%10==0:\n        print(L(w,b),w,b,end='\\r')\n        l.set_data(xlin,w*xlin+b)\n        fig.canvas.draw()\n    hist.append(L(w,b))\n    #sleep(0.1)"}
{"task_id": "DSP/934", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/m*np.sum( (np.dot(X,w)+b-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/934", "completion": "L = None\n### BEGIN SOLUTION\nL = lambda w,b: 0.5/m*np.sum( (np.dot(X,w)+b-y)**2 )\n### END SOLUTION"}
{"task_id": "DSP/935", "completion": "w, b = np.ones(N), 0.1\n\n### BEGIN SOLUTION\ndw = 1/m*((np.dot(X,w)+b-y).dot(X)) #+ 0.0*w\ndb = 1/m*np.sum(np.dot(X,w)+b-y)\n### END SOLUTION\ndw,db"}
{"task_id": "DSP/935", "completion": "w, b = np.ones(N), 0.1\n\n### BEGIN SOLUTION\ndw = 1/m*((np.dot(X,w)+b-y).dot(X)) #+ 0.0*w\ndb = 1/m*np.sum(np.dot(X,w)+b-y)\n### END SOLUTION\ndw,db"}
{"task_id": "DSP/936", "completion": "dw1 = None\n\n### BEGIN SOLUTION\ndw1 = X[:,None]*( error*(y1*(1-y1)) )[None,:]\ndw1 = np.outer(X, error*(y1*(1-y1)) )\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/936", "completion": "dw1 = None\n\n### BEGIN SOLUTION\ndw1 = X[:,None]*( error*(y1*(1-y1)) )[None,:]\ndw1 = np.outer(X, error*(y1*(1-y1)) )\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/937", "completion": "db = None\n\n### BEGIN SOLUTION\ndb1 = error*(y1*(1-y1)) \n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/937", "completion": "db = None\n\n### BEGIN SOLUTION\ndb1 = error*(y1*(1-y1)) \n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/938", "completion": "dw1 = np.mean(X[:,:,None]*( error*(y1*(1-y1)) )[:,None,:],axis=0)\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/938", "completion": "dw1 = np.mean(X[:,:,None]*( error*(y1*(1-y1)) )[:,None,:],axis=0)\n### END SOLUTION\n\ndw1"}
{"task_id": "DSP/939", "completion": "db1 = None\n### BEGIN SOLUTION\ndb1 = np.mean(( error*(y1*(1-y1)) )[:,:],axis=0)\n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/939", "completion": "db1 = None\n### BEGIN SOLUTION\ndb1 = np.mean(( error*(y1*(1-y1)) )[:,:],axis=0)\n### END SOLUTION\n\ndb1"}
{"task_id": "DSP/940", "completion": "Gini = None \n\n### BEGIN SOLUTION\n\nGini =  lambda Ni:1-sum(ni**2/sum(Ni)**2 for ni in Ni)\n\n### END SOLUTION"}
{"task_id": "DSP/940", "completion": "Gini = None \n\n### BEGIN SOLUTION\n\nGini =  lambda Ni:1-sum(ni**2/sum(Ni)**2 for ni in Ni)\n\n### END SOLUTION"}
{"task_id": "DSP/941", "completion": "Ni = [12,22]\nGini(Ni)"}
{"task_id": "DSP/941", "completion": "Ni = [12,22]\nGini(Ni)"}
{"task_id": "DSP/942", "completion": "Ni1, Ni2 = [11,2], [1,20]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/942", "completion": "Ni1, Ni2 = [11,2], [1,20]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/943", "completion": "Ni1,Ni2 = [6,11], [6,11]\n\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/943", "completion": "Ni1,Ni2 = [6,11], [6,11]\n\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\n\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/944", "completion": "Ni1,Ni2 = [10,10], [7,7]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/944", "completion": "Ni1,Ni2 = [10,10], [7,7]\nassert sum(Ni) == sum(Ni1)+sum(Ni2)\nGt = None\n### BEGIN SOLUTION\nGt = sum(Ni1)/sum(Ni)*Gini(Ni1) + sum(Ni2)/sum(Ni)*Gini(Ni2)\n### END SOLUTION\n\nprint(Gt)"}
{"task_id": "DSP/945", "completion": "classes = [2,3,4,5,6] # niepoprawne \n\n### BEGIN SOLUTION\nclasses = np.unique(y)\n### END SOLUTION"}
{"task_id": "DSP/945", "completion": "classes = [2,3,4,5,6] # niepoprawne \n\n### BEGIN SOLUTION\nclasses = np.unique(y)\n### END SOLUTION"}
{"task_id": "DSP/946", "completion": "Sw = None\n### BEGIN SOLUTION\nSw = sum([ np.cov(X[y==c_].T) for c_ in classes] )\n### END SOLUTION"}
{"task_id": "DSP/946", "completion": "Sw = None\n### BEGIN SOLUTION\nSw = sum([ np.cov(X[y==c_].T) for c_ in classes] )\n### END SOLUTION"}
{"task_id": "DSP/947", "completion": "mu = np.mean(X, axis=0)\nSc = None \n### BEGIN SOLUTION\nSc = sum( \n    np.sum(y==c_) * np.outer(np.mean(X[y==c_],axis=0)-mu,\n                             np.mean(X[y==c_],axis=0)-mu) \n    for c_ in classes)\n ### END SOLUTION"}
{"task_id": "DSP/947", "completion": "mu = np.mean(X, axis=0)\nSc = None \n### BEGIN SOLUTION\nSc = sum( \n    np.sum(y==c_) * np.outer(np.mean(X[y==c_],axis=0)-mu,\n                             np.mean(X[y==c_],axis=0)-mu) \n    for c_ in classes)\n ### END SOLUTION"}
{"task_id": "DSP/948", "completion": "lam, v = None, None\n### BEGIN SOLUTION\n\nlam, v = np.linalg.eig(np.linalg.inv(Sw).dot(Sc))\n                           \nlam = np.real_if_close(lam)\n\n### END SOLUTION                                     \n\nlam"}
{"task_id": "DSP/948", "completion": "lam, v = None, None\n### BEGIN SOLUTION\n\nlam, v = np.linalg.eig(np.linalg.inv(Sw).dot(Sc))\n                           \nlam = np.real_if_close(lam)\n\n### END SOLUTION                                     \n\nlam"}
{"task_id": "DSP/949", "completion": "idx = [1,2] # niepoprawne \n### BEGIN SOLUTION\n\nidx = np.argsort(lam)[-2:][::-1]\n\n### END SOLUTION"}
{"task_id": "DSP/949", "completion": "idx = [1,2] # niepoprawne \n### BEGIN SOLUTION\n\nidx = np.argsort(lam)[-2:][::-1]\n\n### END SOLUTION"}
{"task_id": "DSP/950", "completion": "W = None \n\n### BEGIN SOLUTION\nW = np.real_if_close(v[:,idx]).astype(np.float)\nW = W.T\n### END SOLUTION"}
{"task_id": "DSP/950", "completion": "W = None \n\n### BEGIN SOLUTION\nW = np.real_if_close(v[:,idx]).astype(np.float)\nW = W.T\n### END SOLUTION"}
{"task_id": "DSP/951", "completion": "L1 = None\n### BEGIN SOLUTION\nL1 = np.sum(np.abs(x))\n### END SOLUTION"}
{"task_id": "DSP/951", "completion": "L1 = None\n### BEGIN SOLUTION\nL1 = np.sum(np.abs(x))\n### END SOLUTION"}
{"task_id": "DSP/952", "completion": "eta = 1\nw = np.ones(N+1)*0\nhist  = [ ]\nOK = False\nfor k in range(35):\n    OK = True\n    for xi,yi in zip(x,y): \n\n    \n\n        if yi*w.dot(xi) <= 0:\n\n            w += 0\n### BEGIN SOLUTION        \n            w += eta*yi*xi\n### END SOLUTION        \n    \n            clear_output(wait=True)\n            plot(x,y,w,grid=100)\n            OK = False\n            #print(OK,np.sum([ y1*w.dot(xi) != 1 for xi,yi in zip(x,y)]))\n     \n        hist.append([k,*list(w)])\n    if OK:\n        print(\"OK(\",k,\") \",xi)\n        break\n        \nprint(OK,w)\n# from pprint import pprint \n# pprint(hist)"}
{"task_id": "DSP/952", "completion": "eta = 1\nw = np.ones(N+1)*0\nhist  = [ ]\nOK = False\nfor k in range(35):\n    OK = True\n    for xi,yi in zip(x,y): \n\n    \n\n        if yi*w.dot(xi) <= 0:\n\n            w += 0\n### BEGIN SOLUTION        \n            w += eta*yi*xi\n### END SOLUTION        \n    \n            clear_output(wait=True)\n            plot(x,y,w,grid=100)\n            OK = False\n            #print(OK,np.sum([ y1*w.dot(xi) != 1 for xi,yi in zip(x,y)]))\n     \n        hist.append([k,*list(w)])\n    if OK:\n        print(\"OK(\",k,\") \",xi)\n        break\n        \nprint(OK,w)\n# from pprint import pprint \n# pprint(hist)"}
{"task_id": "DSP/953", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot(x,y,w)\n\nfor k in range(5):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        if yi*np.sum(a*y*x.dot(xi)) <= 0:\n            a[i] += 0\n### BEGIN SOLUTION \n            \n            a[i] += 1\n### END SOLUTION        \n\n            w = np.dot(a*y,x)\n            clear_output(wait=True)\n            \n            plot(x,y,w)\n            \n            print(k,i,w,np.sum(w**2)) \n            time.sleep(0.2)\n            \n        if np.all(np.sign(x.dot(w)) == y):\n            break\n    if np.all(np.sign(x.dot(w)) == y):\n        break"}
{"task_id": "DSP/953", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot(x,y,w)\n\nfor k in range(5):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        if yi*np.sum(a*y*x.dot(xi)) <= 0:\n            a[i] += 0\n### BEGIN SOLUTION \n            \n            a[i] += 1\n### END SOLUTION        \n\n            w = np.dot(a*y,x)\n            clear_output(wait=True)\n            \n            plot(x,y,w)\n            \n            print(k,i,w,np.sum(w**2)) \n            time.sleep(0.2)\n            \n        if np.all(np.sign(x.dot(w)) == y):\n            break\n    if np.all(np.sign(x.dot(w)) == y):\n        break"}
{"task_id": "DSP/954", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot_dual(x,y,a)\n\nfor k in range(215):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        ### BEGIN SOLUTION \n\n        if yi*np.sum(a*y*(x.dot(xi))**2 ) <= 0:\n            a[i] += 1\n            clear_output(wait=True)\n            plot_dual(x,y,a,grid=85)\n            time.sleep(0.01)\n        ### END SOLUTION \n        pass"}
{"task_id": "DSP/954", "completion": "import time \na = np.zeros(x.shape[0])\nw = np.zeros(N+1)\n\nperm = np.random.choice(m,m,replace=False)\nx = x[perm]\ny = y[perm]\n\nplot_dual(x,y,a)\n\nfor k in range(215):\n  \n    for i,(xi,yi) in enumerate(zip(x,y)): \n        ### BEGIN SOLUTION \n\n        if yi*np.sum(a*y*(x.dot(xi))**2 ) <= 0:\n            a[i] += 1\n            clear_output(wait=True)\n            plot_dual(x,y,a,grid=85)\n            time.sleep(0.01)\n        ### END SOLUTION \n        pass"}
{"task_id": "DSP/955", "completion": "s = None\n### BEGIN SOLUTION\ns = lambda x:1/(1+np.exp(-x))\n### END SOLUTION"}
{"task_id": "DSP/955", "completion": "s = None\n### BEGIN SOLUTION\ns = lambda x:1/(1+np.exp(-x))\n### END SOLUTION"}
{"task_id": "DSP/956", "completion": "W1,b1 = None,None\nW2,b2 = None,None\nW3,b3 = None,None\n\n### BEGIN SOLUTION\nW1,b1 = 0.1*1*np.ones((3,4)),0.2*1*np.ones(4)\nW2,b2 = 0.1*2*np.ones((4,2)),0.2*2*np.ones(2)\nW3,b3 = 0.1*3*np.ones((2,3)),0.2*3*np.ones(3)\n### END SOLUTION"}
{"task_id": "DSP/956", "completion": "W1,b1 = None,None\nW2,b2 = None,None\nW3,b3 = None,None\n\n### BEGIN SOLUTION\nW1,b1 = 0.1*1*np.ones((3,4)),0.2*1*np.ones(4)\nW2,b2 = 0.1*2*np.ones((4,2)),0.2*2*np.ones(2)\nW3,b3 = 0.1*3*np.ones((2,3)),0.2*3*np.ones(3)\n### END SOLUTION"}
{"task_id": "DSP/957", "completion": "y1 = None # Wyjscie z pierwszej warstwy\ny2 = None\ny3 = None\n\n\n### BEGIN SOLUTION\n\nz1 = X.dot(W1) + b1\ny1 = s(z1)\n\nz2 = y1.dot(W2) + b2\ny2 = s(z2)\n\nz3 = y2.dot(W3) + b3\ny3 = s(z3)\n\n### END SOLUTION"}
{"task_id": "DSP/957", "completion": "y1 = None # Wyjscie z pierwszej warstwy\ny2 = None\ny3 = None\n\n\n### BEGIN SOLUTION\n\nz1 = X.dot(W1) + b1\ny1 = s(z1)\n\nz2 = y1.dot(W2) + b2\ny2 = s(z2)\n\nz3 = y2.dot(W3) + b3\ny3 = s(z3)\n\n### END SOLUTION"}
{"task_id": "DSP/958", "completion": "class_means = np.array([[-3,  2],[-.19,  3]])\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/958", "completion": "class_means = np.array([[-3,  2],[-.19,  3]])\n### BEGIN SOLUTION\nclass_means = np.vstack([ np.mean( train[np.ravel(train_labels==i)], axis=0) for i in np.unique(train_labels) ])\n###END SOLUTION"}
{"task_id": "DSP/959", "completion": "t = 0\nw = np.array([0,1])\nd_lin = np.zeros_like(xx)\n### BEGIN SOLUTION\n\nw = class_means[1]-class_means[0]\nt = w.dot(0.5*(class_means[0]+class_means[1]))\n\nd_lin = (np.tensordot(w,np.stack([xx,yy]),axes=[0,0])-t)>0\n\n### END SOLUTION"}
{"task_id": "DSP/959", "completion": "t = 0\nw = np.array([0,1])\nd_lin = np.zeros_like(xx)\n### BEGIN SOLUTION\n\nw = class_means[1]-class_means[0]\nt = w.dot(0.5*(class_means[0]+class_means[1]))\n\nd_lin = (np.tensordot(w,np.stack([xx,yy]),axes=[0,0])-t)>0\n\n### END SOLUTION"}
{"task_id": "DSP/960", "completion": "X = None\n### BEGIN SOLUTION\nX = data['data'][data['labels']==1]\n### END SOLUTION"}
{"task_id": "DSP/960", "completion": "X = None\n### BEGIN SOLUTION\nX = data['data'][data['labels']==1]\n### END SOLUTION"}
{"task_id": "DSP/961", "completion": "m1,m2 = None,None\ns1,s2 = None,None\n\n### BEGIN SOLUTION\nm1,m2 = np.mean(X,axis=0)\ns1,s2 = np.std(X,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/961", "completion": "m1,m2 = None,None\ns1,s2 = None,None\n\n### BEGIN SOLUTION\nm1,m2 = np.mean(X,axis=0)\ns1,s2 = np.std(X,axis=0)\n### END SOLUTION"}
{"task_id": "DSP/962", "completion": "Recall = None\n### BEGIN SOLUTION\nRecall = TP/(TP+FN)\n### END SOLUTION\nRecall, recall_score(actual,predicted)"}
{"task_id": "DSP/962", "completion": "Recall = None\n### BEGIN SOLUTION\nRecall = TP/(TP+FN)\n### END SOLUTION\nRecall, recall_score(actual,predicted)"}
{"task_id": "DSP/963", "completion": "Precision = None\n### BEGIN SOLUTION\nPrecision = TP/(TP+FP)\n### END SOLUTION"}
{"task_id": "DSP/963", "completion": "Precision = None\n### BEGIN SOLUTION\nPrecision = TP/(TP+FP)\n### END SOLUTION"}
{"task_id": "DSP/964", "completion": "Accuracy = None\n### BEGIN SOLUTION\nAccuracy = (TP+TN)/N, \n### END SOLUTION\n\n\naccuracy_score(actual,predicted)"}
{"task_id": "DSP/964", "completion": "Accuracy = None\n### BEGIN SOLUTION\nAccuracy = (TP+TN)/N, \n### END SOLUTION\n\n\naccuracy_score(actual,predicted)"}
{"task_id": "DSP/965", "completion": "def separate_by_class(X, y):\n    '''\n    Separate the training set (\"X\") by class value (\"y\")\n    so that we can calculate statistics for each class.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array\n    y: A 1d numpy array\n    Returns\n    -------\n    A dictionary of 2d numpy arrays\n    '''\n    # unique values of y\n    keys = np.unique(y) \n    \n    # create an empty dictionary\n    separated = {}\n    \n    for i in keys:\n        # find index\n        separated[i] = X[np.where(y == i)]\n        \n    return separated"}
{"task_id": "DSP/965", "completion": "def separate_by_class(X, y):\n    '''\n    Separate the training set (\"X\") by class value (\"y\")\n    so that we can calculate statistics for each class.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array\n    y: A 1d numpy array\n    Returns\n    -------\n    A dictionary of 2d numpy arrays\n    '''\n    # unique values of y\n    keys = np.unique(y) \n    \n    # create an empty dictionary\n    separated = {}\n    \n    for i in keys:\n        # find index\n        separated[i] = X[np.where(y == i)]\n        \n    return separated"}
{"task_id": "DSP/966", "completion": "def calculate_mean(array):\n    '''\n    Calculates the mean of each column, i.e. each attribute.\n    \n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    \n    # take the mean of each column\n    mean = np.mean(array, axis = 0)\n    \n    return mean"}
{"task_id": "DSP/966", "completion": "def calculate_mean(array):\n    '''\n    Calculates the mean of each column, i.e. each attribute.\n    \n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    \n    # take the mean of each column\n    mean = np.mean(array, axis = 0)\n    \n    return mean"}
{"task_id": "DSP/967", "completion": "def calculate_stdev(array):\n    '''\n    Calculates the standard deviation (N-1 method) of each column, i.e. each attribute.\n\n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    \n    # YOUR CODE HERE\n    # ddof means delta degree of freedom, default = 0\n    stdev = np.std(array, axis = 0, ddof = 1)\n    \n    return stdev"}
{"task_id": "DSP/967", "completion": "def calculate_stdev(array):\n    '''\n    Calculates the standard deviation (N-1 method) of each column, i.e. each attribute.\n\n    Parameters\n    ----------\n    A 1d or 2d numpy array\n    \n    Returns\n    -------\n    A 1d or 2d numpy array\n    '''\n    \n    # YOUR CODE HERE\n    # ddof means delta degree of freedom, default = 0\n    stdev = np.std(array, axis = 0, ddof = 1)\n    \n    return stdev"}
{"task_id": "DSP/968", "completion": "def summarize(X):\n    '''\n    For a given list of instances (for a class value),\n    calculates the mean and the standard deviation for each attribute.\n    \n    Parameters\n    ----------\n    A 2d numpy array\n    \n    Returns\n    -------\n    A 2d numpy array\n    '''\n    \n    # YOUR CODE HERE\n    mean = calculate_mean(X)\n    stdev = calculate_stdev(X)\n    \n    # np.vstack function\n    summary = np.vstack((mean, stdev)).T\n    \n    return summary"}
{"task_id": "DSP/968", "completion": "def summarize(X):\n    '''\n    For a given list of instances (for a class value),\n    calculates the mean and the standard deviation for each attribute.\n    \n    Parameters\n    ----------\n    A 2d numpy array\n    \n    Returns\n    -------\n    A 2d numpy array\n    '''\n    \n    # YOUR CODE HERE\n    mean = calculate_mean(X)\n    stdev = calculate_stdev(X)\n    \n    # np.vstack function\n    summary = np.vstack((mean, stdev)).T\n    \n    return summary"}
{"task_id": "DSP/969", "completion": "def summarize_by_class(X, y):\n    '''\n    Separates a training set into instances grouped by class.\n    It then calculates the summaries for each attribute.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array. Represents training attributes.\n    y: A 1d numpy array. Represents class labels.\n    Returns\n    -------\n    A dictionary of 2d numpy arrays. Uses each class label as keys\n    and summary for each class label as values.\n    '''\n    \n    # YOUR CODE HERE\n    # separate X data into classes\n    class_data = separate_by_class(X, y)\n    \n    # create an empty dictionary\n    summaries = {}\n    \n    for i in class_data:\n        summaries[i] = summarize(class_data[i])\n        \n    return summaries"}
{"task_id": "DSP/969", "completion": "def summarize_by_class(X, y):\n    '''\n    Separates a training set into instances grouped by class.\n    It then calculates the summaries for each attribute.\n    \n    Parameters\n    ----------\n    X: A 2d numpy array. Represents training attributes.\n    y: A 1d numpy array. Represents class labels.\n    Returns\n    -------\n    A dictionary of 2d numpy arrays. Uses each class label as keys\n    and summary for each class label as values.\n    '''\n    \n    # YOUR CODE HERE\n    # separate X data into classes\n    class_data = separate_by_class(X, y)\n    \n    # create an empty dictionary\n    summaries = {}\n    \n    for i in class_data:\n        summaries[i] = summarize(class_data[i])\n        \n    return summaries"}
{"task_id": "DSP/970", "completion": "def calculate_log_probability(x, mean, stdev):\n    '''\n    Calculates log of Gaussian function to estimate\n    the log probability of a given attribute value.\n    Assume x, mean, stdev have the same length.\n    \n    Parameters\n    ----------\n    x: A float or 1d numpy array\n    mean: A float or 1d numpy array\n    stdev: A float or 1d numpy array\n    \n    Returns\n    -------\n    A float or 1d numpy array\n    '''\n\n    # We can use logpdf function: Log of the probability density function\n    from scipy.stats import norm\n    \n    # Stack arrays in sequence vertically (row wise), then transpose it\n    comb = np.vstack([x, mean, stdev]).T  \n    \n    # map logpdf function to the list\n    log_probability = list(map(lambda x: norm.logpdf(*x), comb)) \n\n    return log_probability"}
{"task_id": "DSP/970", "completion": "def calculate_log_probability(x, mean, stdev):\n    '''\n    Calculates log of Gaussian function to estimate\n    the log probability of a given attribute value.\n    Assume x, mean, stdev have the same length.\n    \n    Parameters\n    ----------\n    x: A float or 1d numpy array\n    mean: A float or 1d numpy array\n    stdev: A float or 1d numpy array\n    \n    Returns\n    -------\n    A float or 1d numpy array\n    '''\n\n    # We can use logpdf function: Log of the probability density function\n    from scipy.stats import norm\n    \n    # Stack arrays in sequence vertically (row wise), then transpose it\n    comb = np.vstack([x, mean, stdev]).T  \n    \n    # map logpdf function to the list\n    log_probability = list(map(lambda x: norm.logpdf(*x), comb)) \n\n    return log_probability"}
{"task_id": "DSP/971", "completion": "def calculate_class_log_probabilities(summaries, input_array):\n    '''\n    Combines the probabilities of all of the attribute values for a data instance\n    and comes up with a probability of the entire data instance belonging to the class.\n\n    Parameters\n    ----------\n    summaries: A dictionary of 2d numpy arrays\n    input_array: A numpy array of instances; each instance is a numpy array of attributes\n    \n    Returns\n    -------\n    A dictionary of 1d numpy arrays of summed log probabilities\n    '''\n\n    # YOUR CODE HERE\n    # create an empty dictionary\n    log_probabilities = {}\n    \n    # create an empty list\n    temp = []\n    \n    for i in summaries:\n        for j in range(len(input_array)):\n            temp.append(calculate_log_probability(input_array[j].ravel(), \n                                                    summaries[i][0][:, np.newaxis][0], \n                                                    summaries[i][0][:, np.newaxis][1]))\n    \n    temp = np.reshape(temp, (len(summaries), len(input_array)))\n    \n    for k in summaries:\n        log_probabilities[k] = temp[k]\n    \n    return log_probabilities"}
{"task_id": "DSP/971", "completion": "def calculate_class_log_probabilities(summaries, input_array):\n    '''\n    Combines the probabilities of all of the attribute values for a data instance\n    and comes up with a probability of the entire data instance belonging to the class.\n\n    Parameters\n    ----------\n    summaries: A dictionary of 2d numpy arrays\n    input_array: A numpy array of instances; each instance is a numpy array of attributes\n    \n    Returns\n    -------\n    A dictionary of 1d numpy arrays of summed log probabilities\n    '''\n\n    # YOUR CODE HERE\n    # create an empty dictionary\n    log_probabilities = {}\n    \n    # create an empty list\n    temp = []\n    \n    for i in summaries:\n        for j in range(len(input_array)):\n            temp.append(calculate_log_probability(input_array[j].ravel(), \n                                                    summaries[i][0][:, np.newaxis][0], \n                                                    summaries[i][0][:, np.newaxis][1]))\n    \n    temp = np.reshape(temp, (len(summaries), len(input_array)))\n    \n    for k in summaries:\n        log_probabilities[k] = temp[k]\n    \n    return log_probabilities"}
{"task_id": "DSP/972", "completion": "def predict(summaries, input_array):\n    '''\n    Calculates the probability of each data instance belonging to each class value,\n    looks for the largest probability, and return the associated class.\n    \n    Parameters\n    ----------\n    summaries: A dictionary of numpy arrays\n    input_array: A numpy array of instances; each instance is a numpy array of attributes\n    \n    Returns\n    -------\n    A 1d numpy array\n    '''\n\n    # YOUR CODE HERE\n    probs = calculate_class_log_probabilities(summaries, input_array)\n    best_class = []\n    \n    for i in range(len(input_array)):\n        if probs[0][i] < probs[1][i]:\n            best_class.append(1)\n        else:\n            best_class.append(0)\n    \n    best_class = np.array(best_class)\n    \n    return best_class"}
{"task_id": "DSP/972", "completion": "def predict(summaries, input_array):\n    '''\n    Calculates the probability of each data instance belonging to each class value,\n    looks for the largest probability, and return the associated class.\n    \n    Parameters\n    ----------\n    summaries: A dictionary of numpy arrays\n    input_array: A numpy array of instances; each instance is a numpy array of attributes\n    \n    Returns\n    -------\n    A 1d numpy array\n    '''\n\n    # YOUR CODE HERE\n    probs = calculate_class_log_probabilities(summaries, input_array)\n    best_class = []\n    \n    for i in range(len(input_array)):\n        if probs[0][i] < probs[1][i]:\n            best_class.append(1)\n        else:\n            best_class.append(0)\n    \n    best_class = np.array(best_class)\n    \n    return best_class"}
{"task_id": "DSP/973", "completion": "var_a=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\"]\nvar_b=(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/973", "completion": "var_a=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\"]\nvar_b=(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/974", "completion": "dictionary = dict(zip(var_a, var_b))"}
{"task_id": "DSP/974", "completion": "dictionary = dict(zip(var_a, var_b))"}
{"task_id": "DSP/975", "completion": "lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\ninds = []\n\n# YOUR CODE HERE\nfor i in range(len(lst)):\n    element=lst[i]\n    if element%2==0:\n        inds.append(i)\n    else:\n        pass"}
{"task_id": "DSP/975", "completion": "lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\ninds = []\n\n# YOUR CODE HERE\nfor i in range(len(lst)):\n    element=lst[i]\n    if element%2==0:\n        inds.append(i)\n    else:\n        pass"}
{"task_id": "DSP/976", "completion": "def squared_diff(a, b):\n    return ((a-b)**2)"}
{"task_id": "DSP/976", "completion": "def squared_diff(a, b):\n    return ((a-b)**2)"}
{"task_id": "DSP/977", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/977", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/978", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', delimiter=',')"}
{"task_id": "DSP/978", "completion": "data = np.genfromtxt('data/open_exoplanet_catalogue.txt', delimiter=',')"}
{"task_id": "DSP/979", "completion": "masses = pd.Series(data[:, 2]).dropna()\nmasses = masses[masses < 15]\nlen(masses)"}
{"task_id": "DSP/979", "completion": "masses = pd.Series(data[:, 2]).dropna()\nmasses = masses[masses < 15]\nlen(masses)"}
{"task_id": "DSP/980", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    str_x = str(x)\n    str_y = str(y)\n    if len(str_x) != len(str_y):\n        return False\n    for i in str_x:\n        if i not in str_y:\n            return False\n    return True"}
{"task_id": "DSP/980", "completion": "def same_digits(x, y):\n    \"\"\"Do the integers x and y have the same digits, regardless of order.\"\"\"\n    str_x = str(x)\n    str_y = str(y)\n    if len(str_x) != len(str_y):\n        return False\n    for i in str_x:\n        if i not in str_y:\n            return False\n    return True"}
{"task_id": "DSP/981", "completion": "def bootstrap(x, y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    x: ndarray\n        Input x array.\n    y: ndarray\n        Input y array.\n    \n    Returns\n    -------\n    xx: ndarray\n        The boostrapped x array with the same shape as x and correlated random samples\n        drawn with replacement.\n    yy: ndarray\n        The bootstrapped y array with the same shape as y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    indices = np.random.choice(range(len(x)), len(x))\n    xx = x[indices]\n    yy = y[indices]\n    return xx, yy"}
{"task_id": "DSP/981", "completion": "def bootstrap(x, y):\n    \"\"\"Return boostrapped versions of the input X and Y arrays, perserving correlations.\n    \n    Parameters\n    ----------\n    x: ndarray\n        Input x array.\n    y: ndarray\n        Input y array.\n    \n    Returns\n    -------\n    xx: ndarray\n        The boostrapped x array with the same shape as x and correlated random samples\n        drawn with replacement.\n    yy: ndarray\n        The bootstrapped y array with the same shape as y and correlated random samples\n        drawn with replacement.\n    \"\"\"\n    indices = np.random.choice(range(len(x)), len(x))\n    xx = x[indices]\n    yy = y[indices]\n    return xx, yy"}
{"task_id": "DSP/982", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(t1_avg, size=n)\nsim2 = np.random.poisson(t2_avg, size=n)"}
{"task_id": "DSP/982", "completion": "np.random.seed(0) # keep this line to reset the random number generator\nsim1 = np.random.poisson(t1_avg, size=n)\nsim2 = np.random.poisson(t2_avg, size=n)"}
{"task_id": "DSP/983", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/983", "completion": "spread = sim2 - sim1"}
{"task_id": "DSP/984", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = (3*sigma**2)**.5\n    a = mu - d\n    b = mu + d\n    return np.random.uniform(a, b, size)"}
{"task_id": "DSP/984", "completion": "def uniform2(mu, sigma, size=1):\n    \"\"\"Return uniform random variates with mean mu and standard dev sigma.\"\"\"\n    d = (3*sigma**2)**.5\n    a = mu - d\n    b = mu + d\n    return np.random.uniform(a, b, size)"}
{"task_id": "DSP/985", "completion": "with open('speed_of_light.txt', 'r') as f:\n    nums = np.array(f.read().split()).astype(int)\n\ndata = pd.DataFrame(nums, columns = ['raw'])"}
{"task_id": "DSP/985", "completion": "with open('speed_of_light.txt', 'r') as f:\n    nums = np.array(f.read().split()).astype(int)\n\ndata = pd.DataFrame(nums, columns = ['raw'])"}
{"task_id": "DSP/986", "completion": "data['time'] = data['raw'] + offset\ndata['speed'] = distance/data['time']"}
{"task_id": "DSP/986", "completion": "data['time'] = data['raw'] + offset\ndata['speed'] = distance/data['time']"}
{"task_id": "DSP/987", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    arr = np.zeros((n,n), dtype = int)\n    for i in range(n):\n        arr[i][i] = n-1\n    return arr"}
{"task_id": "DSP/987", "completion": "def complete_deg(n):\n    \"\"\"Return the integer valued degree matrix D for the complete graph K_n.\"\"\"\n    arr = np.zeros((n,n), dtype = int)\n    for i in range(n):\n        arr[i][i] = n-1\n    return arr"}
{"task_id": "DSP/988", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    arr = np.ones((n, n), dtype=int)\n    for i in range(n):\n        arr[i][i] = 0\n    return arr"}
{"task_id": "DSP/988", "completion": "def complete_adj(n):\n    \"\"\"Return the integer valued adjacency matrix A for the complete graph K_n.\"\"\"\n    arr = np.ones((n, n), dtype=int)\n    for i in range(n):\n        arr[i][i] = 0\n    return arr"}
{"task_id": "DSP/989", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    # YOUR CODE HERE\n    add = list(x)\n    for i in range(len(x)):\n        add[i] = x[i] + y[i]    \n    return add"}
{"task_id": "DSP/989", "completion": "def vector_sum(x, y):\n    \"\"\"Compute the vector sum of x and y as a Python list.\"\"\"\n    # YOUR CODE HERE\n    add = list(x)\n    for i in range(len(x)):\n        add[i] = x[i] + y[i]    \n    return add"}
{"task_id": "DSP/990", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    # YOUR CODE HERE\n    sub = list(x)\n    for i in range(len(x)):\n        sub[i] = x[i] - y[i]    \n    return sub"}
{"task_id": "DSP/990", "completion": "def vector_diff(x, y):\n    \"\"\"Compute the vector difference of x and y as a Python list.\"\"\"\n    # YOUR CODE HERE\n    sub = list(x)\n    for i in range(len(x)):\n        sub[i] = x[i] - y[i]    \n    return sub"}
{"task_id": "DSP/991", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    # YOUR CODE HERE\n    mul = list(x)\n    for i in range(len(x)):\n        mul[i] = x[i] * a    \n    return mul"}
{"task_id": "DSP/991", "completion": "def vector_scalar_mul(a, x):\n    \"\"\"Compute a*x as a Python list.\"\"\"\n    # YOUR CODE HERE\n    mul = list(x)\n    for i in range(len(x)):\n        mul[i] = x[i] * a    \n    return mul"}
{"task_id": "DSP/992", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    # YOUR CODE HERE\n    dot = 0\n    for i in range(len(x)):\n        dot += x[i] * y[i]    \n    return dot"}
{"task_id": "DSP/992", "completion": "def vector_dot(x, y):\n    \"\"\"Compute the dot product of vectors a and b.\"\"\"\n    # YOUR CODE HERE\n    dot = 0\n    for i in range(len(x)):\n        dot += x[i] * y[i]    \n    return dot"}
{"task_id": "DSP/993", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    # YOUR CODE HERE\n    norm = 0\n    for i in range(len(x)):\n        norm += x[i]   \n    return norm"}
{"task_id": "DSP/993", "completion": "def L1(x):\n    \"\"\"Compute the L1 norm of x.\"\"\"\n    # YOUR CODE HERE\n    norm = 0\n    for i in range(len(x)):\n        norm += x[i]   \n    return norm"}
{"task_id": "DSP/994", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    # YOUR CODE HERE\n    norm = 0\n    for i in range(len(x)):\n        norm += (x[i] ** 2)\n    return norm ** .5"}
{"task_id": "DSP/994", "completion": "def L2(x):\n    \"\"\"Compute the L2 norm of x.\"\"\"\n    # YOUR CODE HERE\n    norm = 0\n    for i in range(len(x)):\n        norm += (x[i] ** 2)\n    return norm ** .5"}
{"task_id": "DSP/995", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    # YOUR CODE HERE\n    error = 0\n    for i in range(len(x)):\n        error += (x[i] - y[i])**2\n    return error/len(x)"}
{"task_id": "DSP/995", "completion": "def mse(x, y):\n    \"\"\"Compute the mean squared error between x and y.\"\"\"\n    # YOUR CODE HERE\n    error = 0\n    for i in range(len(x)):\n        error += (x[i] - y[i])**2\n    return error/len(x)"}
{"task_id": "DSP/996", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    # YOUR CODE HERE\n    avg = 0\n    length = len(x)\n    for i in range(length):\n        avg += x[i]\n    return avg/length"}
{"task_id": "DSP/996", "completion": "def mean(x):\n    \"\"\"Compute the mean of the elements of x.\"\"\"\n    # YOUR CODE HERE\n    avg = 0\n    length = len(x)\n    for i in range(length):\n        avg += x[i]\n    return avg/length"}
{"task_id": "DSP/997", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    # YOUR CODE HERE\n    avg = mean(x)\n    variance = 0\n    for i in x:\n        variance += (avg - i)**2\n    return variance/len(x)"}
{"task_id": "DSP/997", "completion": "def var(x):\n    \"\"\"Compute the variance of the elements of x.\"\"\"\n    # YOUR CODE HERE\n    avg = mean(x)\n    variance = 0\n    for i in x:\n        variance += (avg - i)**2\n    return variance/len(x)"}
{"task_id": "DSP/998", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return var(x)**.5"}
{"task_id": "DSP/998", "completion": "def std(x):\n    \"\"\"Compute the standard deviation of the elements of x.\"\"\"\n    return var(x)**.5"}
{"task_id": "DSP/999", "completion": "def fit_lambda(data):\n    \"\"\"Perform MLE to estimate the \u03bb parameter of the Poisson distribution.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The data to use in estimating lambda\n    \n    Returns\n    -------\n    lambda: float\n        The MLE value for lambda\n    \"\"\"\n    nllh = lambda x: -1*sum(np.array(poisson.logpmf(data, x)))\n    val = minimize(nllh, sum(data)/len(data))\n    return val.x"}
{"task_id": "DSP/999", "completion": "def fit_lambda(data):\n    \"\"\"Perform MLE to estimate the \u03bb parameter of the Poisson distribution.\n    \n    Parameters\n    ----------\n    data: ndarray\n        The data to use in estimating lambda\n    \n    Returns\n    -------\n    lambda: float\n        The MLE value for lambda\n    \"\"\"\n    nllh = lambda x: -1*sum(np.array(poisson.logpmf(data, x)))\n    val = minimize(nllh, sum(data)/len(data))\n    return val.x"}
{"task_id": "DSP/1000", "completion": "def hat(x, a, b):\n    return -a*x**2 + b*x**4"}
{"task_id": "DSP/1000", "completion": "def hat(x, a, b):\n    return -a*x**2 + b*x**4"}
{"task_id": "DSP/1001", "completion": "def add2(input1, input2):\n    return input1 + input2"}
{"task_id": "DSP/1001", "completion": "def add2(input1, input2):\n    return input1 + input2"}
{"task_id": "DSP/1002", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/1002", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/1003", "completion": "mpg_data = pd.read_fwf('http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data',\n                       names = ['mpg', 'cylinders', 'displacement', 'horsepower', 'weight', 'acceleration', 'model_year', 'origin', 'car_name'])"}
{"task_id": "DSP/1003", "completion": "mpg_data = pd.read_fwf('http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data',\n                       names = ['mpg', 'cylinders', 'displacement', 'horsepower', 'weight', 'acceleration', 'model_year', 'origin', 'car_name'])"}
{"task_id": "DSP/1004", "completion": "mpg_data.horsepower = pd.to_numeric(mpg_data.horsepower, downcast='signed', errors='coerce')"}
{"task_id": "DSP/1004", "completion": "mpg_data.horsepower = pd.to_numeric(mpg_data.horsepower, downcast='signed', errors='coerce')"}
{"task_id": "DSP/1005", "completion": "mpg_data = mpg_data.dropna()"}
{"task_id": "DSP/1005", "completion": "mpg_data = mpg_data.dropna()"}
{"task_id": "DSP/1006", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    smallest_cylinders_count = dataframe.cylinders.min()\n    car_names = dataframe.loc[dataframe.cylinders == smallest_cylinders_count].car_name\n    return car_names"}
{"task_id": "DSP/1006", "completion": "def get_model_names_smallest_cylinders(dataframe):\n    \"\"\"\n    Returns the names of the cars with the smallest number of cylinders\n    \"\"\"\n    smallest_cylinders_count = dataframe.cylinders.min()\n    car_names = dataframe.loc[dataframe.cylinders == smallest_cylinders_count].car_name\n    return car_names"}
{"task_id": "DSP/1007", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/1007", "completion": "def calculate_correlation(dataframe, first_column, second_column):\n    \"\"\"\n    Calculates and returns the correlation coefficient between the two columns in the dataframe.\n    \"\"\"\n    correlation = dataframe[first_column].corr(dataframe[second_column])\n    return correlation"}
{"task_id": "DSP/1008", "completion": "page1 = skimage.io.imread(\"images/page1.jpg\")\npage2 = skimage.io.imread(\"images/page2.jpg\")"}
{"task_id": "DSP/1008", "completion": "page1 = skimage.io.imread(\"images/page1.jpg\")\npage2 = skimage.io.imread(\"images/page2.jpg\")"}
{"task_id": "DSP/1009", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\nresized = resize_images([page1_left_cropped, page1_right_cropped, page2_cropped])\n      \ndef concatenate_images(images):\n    resized = resize_images(images)\n    return np.concatenate(resized, axis=0)"}
{"task_id": "DSP/1009", "completion": "def resize_images(images):\n    \"\"\"\n    Resizes all images to have the same width\n    \"\"\"\n    max_width = max([image.shape[1] for image in images])\n    padded_images = [np.pad(image, ((0, 0), (0, max_width - image.shape[1])), mode = \"constant\", constant_values = 255) for image in images]\n    return padded_images\n\nresized = resize_images([page1_left_cropped, page1_right_cropped, page2_cropped])\n      \ndef concatenate_images(images):\n    resized = resize_images(images)\n    return np.concatenate(resized, axis=0)"}
{"task_id": "DSP/1010", "completion": "menu_content = \"\"\nwith open(\"output/menu.txt\", \"r\", encoding=\"utf-8\") as f:\n    menu_content = f.read()\n\nprint(menu_content)"}
{"task_id": "DSP/1010", "completion": "menu_content = \"\"\nwith open(\"output/menu.txt\", \"r\", encoding=\"utf-8\") as f:\n    menu_content = f.read()\n\nprint(menu_content)"}
{"task_id": "DSP/1011", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    arr = meals_string.split('*')\n    arr_len = np.size(arr)\n    category_list, name_list, price_list = [], [], []\n    for i in range(0, arr_len):\n        current = arr[i].split('\\n')\n        current = list(filter(None, current))\n        category = current[0].lower()\n        current_len = np.size(current)\n        for j in range(1, current_len):\n            name_and_price = current[j].split('=')\n            name = name_and_price[0]\n            price = name_and_price[1]\n            \n            category_list.append(category)\n            name_list.append(name)\n            price_list.append(price)\n\n    table = { 'category': np.asarray(category_list), 'meal name': np.asarray(name_list), 'price': np.asarray(price_list, dtype=\"float\") }\n    df = pd.DataFrame(data=table)\n    return df"}
{"task_id": "DSP/1011", "completion": "meals_string = menu_content[:menu_content.index(\"Wine by the Glass\")]\ndef generate_meals_table(meals_string):\n    arr = meals_string.split('*')\n    arr_len = np.size(arr)\n    category_list, name_list, price_list = [], [], []\n    for i in range(0, arr_len):\n        current = arr[i].split('\\n')\n        current = list(filter(None, current))\n        category = current[0].lower()\n        current_len = np.size(current)\n        for j in range(1, current_len):\n            name_and_price = current[j].split('=')\n            name = name_and_price[0]\n            price = name_and_price[1]\n            \n            category_list.append(category)\n            name_list.append(name)\n            price_list.append(price)\n\n    table = { 'category': np.asarray(category_list), 'meal name': np.asarray(name_list), 'price': np.asarray(price_list, dtype=\"float\") }\n    df = pd.DataFrame(data=table)\n    return df"}
{"task_id": "DSP/1012", "completion": "num_items_total = None\nnum_categories_total = None\nnum_items_by_category = None\nmean_price_by_category = None\n\nnum_items_total = np.shape(meals_table)[0]\nnum_categories_total = np.size(meals_table.category.unique())\nnum_items_by_category = meals_table.category.value_counts()\nmean_price_by_category = meals_table[\"price\"].groupby(meals_table[\"category\"]).mean()"}
{"task_id": "DSP/1012", "completion": "num_items_total = None\nnum_categories_total = None\nnum_items_by_category = None\nmean_price_by_category = None\n\nnum_items_total = np.shape(meals_table)[0]\nnum_categories_total = np.size(meals_table.category.unique())\nnum_items_by_category = meals_table.category.value_counts()\nmean_price_by_category = meals_table[\"price\"].groupby(meals_table[\"category\"]).mean()"}
{"task_id": "DSP/1013", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\",\n                         names = [\"age\", \"workclass\", \"fnlwgt\",\"education\", \"education-num\", \"marital-status\", \n                                  \"occupation\", \"relationship\", \"race\", \"sex\", \"capital-gain\", \"capital-loss\", \n                                  \"hours-per-week\", \"native-country\", \"income\"])\n\nincome_data_obj = income_data.select_dtypes(['object'])\nincome_data[income_data_obj.columns] = income_data_obj.apply(lambda x: x.str.strip())"}
{"task_id": "DSP/1013", "completion": "income_data = pd.read_csv(\"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\",\n                         names = [\"age\", \"workclass\", \"fnlwgt\",\"education\", \"education-num\", \"marital-status\", \n                                  \"occupation\", \"relationship\", \"race\", \"sex\", \"capital-gain\", \"capital-loss\", \n                                  \"hours-per-week\", \"native-country\", \"income\"])\n\nincome_data_obj = income_data.select_dtypes(['object'])\nincome_data[income_data_obj.columns] = income_data_obj.apply(lambda x: x.str.strip())"}
{"task_id": "DSP/1014", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    return len(dataframe.loc[(dataframe[\"capital-gain\"] >= threshold_gain)])"}
{"task_id": "DSP/1014", "completion": "def get_num_people_with_higher_gain(dataframe, threshold_gain):\n    return len(dataframe.loc[(dataframe[\"capital-gain\"] >= threshold_gain)])"}
{"task_id": "DSP/1015", "completion": "def most_prominent_marital_status(dataframe):\n    status = \"\"\n    num_people = 0\n    num_people = dataframe[\"marital-status\"].value_counts().max()\n    statuses = dataframe[\"marital-status\"].value_counts().index\n    status = statuses[0]\n    return (status, num_people)"}
{"task_id": "DSP/1015", "completion": "def most_prominent_marital_status(dataframe):\n    status = \"\"\n    num_people = 0\n    num_people = dataframe[\"marital-status\"].value_counts().max()\n    statuses = dataframe[\"marital-status\"].value_counts().index\n    status = statuses[0]\n    return (status, num_people)"}
{"task_id": "DSP/1016", "completion": "def get_num_people_by_age_category(dataframe):\n    young, middle_aged, old = (0, 0, 0)\n    young = len(dataframe.loc[(dataframe[\"age\"] <= 30)])\n    middle_aged = len(dataframe.loc[(dataframe[\"age\"] > 30) & (dataframe[\"age\"] <= 60)])\n    old = len(dataframe.loc[(dataframe[\"age\"] > 60)])\n    return young, middle_aged, old"}
{"task_id": "DSP/1016", "completion": "def get_num_people_by_age_category(dataframe):\n    young, middle_aged, old = (0, 0, 0)\n    young = len(dataframe.loc[(dataframe[\"age\"] <= 30)])\n    middle_aged = len(dataframe.loc[(dataframe[\"age\"] > 30) & (dataframe[\"age\"] <= 60)])\n    old = len(dataframe.loc[(dataframe[\"age\"] > 60)])\n    return young, middle_aged, old"}
{"task_id": "DSP/1017", "completion": "def get_second_highest_num_people(dataframe):\n    num_people, country = 0, \"\"\n    num_people_arr = dataframe[\"native-country\"].value_counts()\n    countries = dataframe[\"native-country\"].value_counts().index\n    num_people = num_people_arr[1]\n    country = countries[1]\n\n    return num_people, country"}
{"task_id": "DSP/1017", "completion": "def get_second_highest_num_people(dataframe):\n    num_people, country = 0, \"\"\n    num_people_arr = dataframe[\"native-country\"].value_counts()\n    countries = dataframe[\"native-country\"].value_counts().index\n    num_people = num_people_arr[1]\n    country = countries[1]\n\n    return num_people, country"}
{"task_id": "DSP/1018", "completion": "def get_mean_working_hours_by_income(dataframe):\n    hours = (dataframe.groupby('occupation')['hours-per-week'].mean())\n    return hours"}
{"task_id": "DSP/1018", "completion": "def get_mean_working_hours_by_income(dataframe):\n    hours = (dataframe.groupby('occupation')['hours-per-week'].mean())\n    return hours"}
{"task_id": "DSP/1019", "completion": "failed_student_times = np.random.uniform(1, 3, 12)\npassed_student_times = np.random.uniform(7, 10, 8)\nall_times = np.concatenate([failed_student_times, passed_student_times])\nexam_result = np.concatenate([np.zeros(12), np.ones(8)])\nprint(exam_result)"}
{"task_id": "DSP/1019", "completion": "failed_student_times = np.random.uniform(1, 3, 12)\npassed_student_times = np.random.uniform(7, 10, 8)\nall_times = np.concatenate([failed_student_times, passed_student_times])\nexam_result = np.concatenate([np.zeros(12), np.ones(8)])\nprint(exam_result)"}
{"task_id": "DSP/1020", "completion": "all_times = np.random.uniform(1, 10, 20)\nexam_result = np.zeros(20)\nfor i in range(0, 19):\n    if all_times[i] <= 3:\n        exam_result[i] = 0\n    elif all_times[i] >= 7:\n        exam_result[i] = 1\n    else:\n        exam_result[i] = np.random.randint(0, 2)\nprint(exam_result)"}
{"task_id": "DSP/1020", "completion": "all_times = np.random.uniform(1, 10, 20)\nexam_result = np.zeros(20)\nfor i in range(0, 19):\n    if all_times[i] <= 3:\n        exam_result[i] = 0\n    elif all_times[i] >= 7:\n        exam_result[i] = 1\n    else:\n        exam_result[i] = np.random.randint(0, 2)\nprint(exam_result)"}
{"task_id": "DSP/1021", "completion": "def error_0(x):\n    return -1 * np.log(1 - x)\n\ndef error_1(x):\n    return -1 * np.log(x)"}
{"task_id": "DSP/1021", "completion": "def error_0(x):\n    return -1 * np.log(1 - x)\n\ndef error_1(x):\n    return -1 * np.log(x)"}
{"task_id": "DSP/1022", "completion": "def gen_cosine(n):\n    N = n\n    sigma = 0.2\n    \n    x = np.linspace(0, 2*(math.pi),N)\n    t = []\n    t = [np.random.normal(math.cos(x[i]), sigma) for i in range(0, N)]\n\n    \n    return x, np.array(t)"}
{"task_id": "DSP/1022", "completion": "def gen_cosine(n):\n    N = n\n    sigma = 0.2\n    \n    x = np.linspace(0, 2*(math.pi),N)\n    t = []\n    t = [np.random.normal(math.cos(x[i]), sigma) for i in range(0, N)]\n\n    \n    return x, np.array(t)"}
{"task_id": "DSP/1023", "completion": "def designmatrix(x, M): # it is highly recommended to write a helper function that computes Phi\n    phi = [np.power(x,i) for i in range(0,M+1)]\n    phi = np.transpose(phi)    \n    return phi\n\n\ndef fit_polynomial(x, t, M):\n    \n    Phi = designmatrix(x, M)\n    Phi_trns = np.transpose(Phi)\n    PhiMult = np.matmul(Phi_trns,Phi)\n    inversMult = inv(PhiMult)\n    PhiForWML = np.matmul(inversMult,Phi_trns)\n    \n    w_ml = np.matmul(PhiForWML,t)\n    return w_ml, Phi"}
{"task_id": "DSP/1023", "completion": "def designmatrix(x, M): # it is highly recommended to write a helper function that computes Phi\n    phi = [np.power(x,i) for i in range(0,M+1)]\n    phi = np.transpose(phi)    \n    return phi\n\n\ndef fit_polynomial(x, t, M):\n    \n    Phi = designmatrix(x, M)\n    Phi_trns = np.transpose(Phi)\n    PhiMult = np.matmul(Phi_trns,Phi)\n    inversMult = inv(PhiMult)\n    PhiForWML = np.matmul(inversMult,Phi_trns)\n    \n    w_ml = np.matmul(PhiForWML,t)\n    return w_ml, Phi"}
{"task_id": "DSP/1024", "completion": "def fit_polynomial_reg(x, t, m, lamb):        \n       \n    Phi = designmatrix(x, m)    \n    Phi_trns = Phi.T\n    PhiMult = np.matmul(Phi_trns,Phi)\n    \n    lamb_unit = lamb* np.identity(m+1)\n    inversMult = inv(lamb_unit + PhiMult)\n    \n    PhiForWML = np.matmul(inversMult,Phi_trns)\n    w_ml = np.matmul(PhiForWML,t)\n    \n    return w_ml, Phi"}
{"task_id": "DSP/1024", "completion": "def fit_polynomial_reg(x, t, m, lamb):        \n       \n    Phi = designmatrix(x, m)    \n    Phi_trns = Phi.T\n    PhiMult = np.matmul(Phi_trns,Phi)\n    \n    lamb_unit = lamb* np.identity(m+1)\n    inversMult = inv(lamb_unit + PhiMult)\n    \n    PhiForWML = np.matmul(inversMult,Phi_trns)\n    w_ml = np.matmul(PhiForWML,t)\n    \n    return w_ml, Phi"}
{"task_id": "DSP/1025", "completion": "def pred_error(x_train, x_valid, t_train, t_valid, M, reg):\n    w, Phi = fit_polynomial_reg(x_train, t_train, M, reg)\n    Phi_valid = designmatrix(x_valid, M)\n    valid_pred = np.matmul(Phi_valid, w)\n    pred_err= (1/2) * np.matmul((valid_pred - t_valid).T, (valid_pred - t_valid)) \n    return pred_err"}
{"task_id": "DSP/1025", "completion": "def pred_error(x_train, x_valid, t_train, t_valid, M, reg):\n    w, Phi = fit_polynomial_reg(x_train, t_train, M, reg)\n    Phi_valid = designmatrix(x_valid, M)\n    valid_pred = np.matmul(Phi_valid, w)\n    pred_err= (1/2) * np.matmul((valid_pred - t_valid).T, (valid_pred - t_valid)) \n    return pred_err"}
{"task_id": "DSP/1026", "completion": "def gen_cosine2(n):\n    x = np.random.uniform(0, 2*np.pi, size = n)\n    t = [np.random.normal(math.cos(x[i]), scale = 0.2) for i in range(n)]\n    return np.array(x), np.array(t)"}
{"task_id": "DSP/1026", "completion": "def gen_cosine2(n):\n    x = np.random.uniform(0, 2*np.pi, size = n)\n    t = [np.random.normal(math.cos(x[i]), scale = 0.2) for i in range(n)]\n    return np.array(x), np.array(t)"}
{"task_id": "DSP/1027", "completion": "def fit_polynomial_bayes(x, t, M, alpha, beta):\n   \n    Phi = designmatrix(x, M)\n\n    #Compute S\n    S = np.linalg.inv(alpha * np.identity(M+1) + beta * np.dot(np.transpose(Phi), Phi))\n\n    #Compute m\n    m = beta *np.dot(S, np.dot( np.transpose(Phi), t))\n    \n    return m, S, Phi"}
{"task_id": "DSP/1027", "completion": "def fit_polynomial_bayes(x, t, M, alpha, beta):\n   \n    Phi = designmatrix(x, M)\n\n    #Compute S\n    S = np.linalg.inv(alpha * np.identity(M+1) + beta * np.dot(np.transpose(Phi), Phi))\n\n    #Compute m\n    m = beta *np.dot(S, np.dot( np.transpose(Phi), t))\n    \n    return m, S, Phi"}
{"task_id": "DSP/1028", "completion": "def predict_polynomial_bayes(x, m, S, beta):\n    # Compute the design matrix.    \n    Phi = designmatrix(x, len(m) - 1)\n    \n    # Compute the variance. \n    sigma = np.zeros(x.shape[0])\n    for i, row in enumerate(Phi):\n        sigma[i] = 1/beta + np.dot(row,np.dot(S,row))\n\n    # Compute the mean.\n    mean = np.zeros(x.shape[0])\n    for i, row in enumerate(Phi):\n        mean[i] = np.dot(m,row)\n\n    return mean, sigma, Phi"}
{"task_id": "DSP/1028", "completion": "def predict_polynomial_bayes(x, m, S, beta):\n    # Compute the design matrix.    \n    Phi = designmatrix(x, len(m) - 1)\n    \n    # Compute the variance. \n    sigma = np.zeros(x.shape[0])\n    for i, row in enumerate(Phi):\n        sigma[i] = 1/beta + np.dot(row,np.dot(S,row))\n\n    # Compute the mean.\n    mean = np.zeros(x.shape[0])\n    for i, row in enumerate(Phi):\n        mean[i] = np.dot(m,row)\n\n    return mean, sigma, Phi"}
{"task_id": "DSP/1029", "completion": "def masked_loss(preds, labels):\n    \n    '''\n    Inputs:\n        -preds: Model predictions [N_batch, 5138]\n        -labels: User ratings [N_batch, 5138]\n        \n    Returns the masked loss as described above.\n    '''\n    \n    loss = 0\n    \n    ### BEGIN SOLUTION\n    \n    mask = torch.where((labels!=0), torch.Tensor([1]),torch.Tensor([0]))\n    masked_preds = preds*mask\n    loss = torch.sum((masked_preds - labels)**2)/(torch.sum(mask))\n    \n    ### END SOLUTION\n    \n    return loss"}
{"task_id": "DSP/1029", "completion": "def masked_loss(preds, labels):\n    \n    '''\n    Inputs:\n        -preds: Model predictions [N_batch, 5138]\n        -labels: User ratings [N_batch, 5138]\n        \n    Returns the masked loss as described above.\n    '''\n    \n    loss = 0\n    \n    ### BEGIN SOLUTION\n    \n    mask = torch.where((labels!=0), torch.Tensor([1]),torch.Tensor([0]))\n    masked_preds = preds*mask\n    loss = torch.sum((masked_preds - labels)**2)/(torch.sum(mask))\n    \n    ### END SOLUTION\n    \n    return loss"}
{"task_id": "DSP/1030", "completion": "def transformation(W,X,b):\n    \"\"\"\n    Implement the transformation W*X + b, given the matrices W, X, and b.\n    \n    Note that all matrix calculations follow the general matrix arithmatic rules.\n    \n    Parameters: W,X,b\n    Output: transformed_X, i.e., W*X + b\n    \"\"\"\n    \n    # YOUR CODE HERE\n    transformed_X = np.dot(W,X) + b\n    \n    return transformed_X"}
{"task_id": "DSP/1030", "completion": "def transformation(W,X,b):\n    \"\"\"\n    Implement the transformation W*X + b, given the matrices W, X, and b.\n    \n    Note that all matrix calculations follow the general matrix arithmatic rules.\n    \n    Parameters: W,X,b\n    Output: transformed_X, i.e., W*X + b\n    \"\"\"\n    \n    # YOUR CODE HERE\n    transformed_X = np.dot(W,X) + b\n    \n    return transformed_X"}
{"task_id": "DSP/1031", "completion": "def activation_tanh(Y):\n    \"\"\"\n    Given a matrix Y, apply the tanh activation function to each element.\n    \n    Paramaters: Y\n    Output: H\n    \"\"\"\n    \n    # YOUR CODE HERE\n    H = 2/(1+np.exp(-2*Y)) - 1\n         \n    return H"}
{"task_id": "DSP/1031", "completion": "def activation_tanh(Y):\n    \"\"\"\n    Given a matrix Y, apply the tanh activation function to each element.\n    \n    Paramaters: Y\n    Output: H\n    \"\"\"\n    \n    # YOUR CODE HERE\n    H = 2/(1+np.exp(-2*Y)) - 1\n         \n    return H"}
{"task_id": "DSP/1032", "completion": "def activation_elu(Y, alpha):\n    \"\"\"\n    Given a matrix, Y, and a real number, alpha, apply the ELU activation function to each element.\n    \n    Paramaters: Y, alpha\n    Output: Z\n    \"\"\"\n    \n    # Hint: Use A = np.copy(B) to create deep copies of numpy array. A = B creates shallow copies of B.\n    \n    # YOUR CODE HERE\n    \n    Z = np.copy(Y)\n    Z[Z<0] = alpha * (np.exp(Z[Z<0]) - 1)\n        \n    return Z"}
{"task_id": "DSP/1032", "completion": "def activation_elu(Y, alpha):\n    \"\"\"\n    Given a matrix, Y, and a real number, alpha, apply the ELU activation function to each element.\n    \n    Paramaters: Y, alpha\n    Output: Z\n    \"\"\"\n    \n    # Hint: Use A = np.copy(B) to create deep copies of numpy array. A = B creates shallow copies of B.\n    \n    # YOUR CODE HERE\n    \n    Z = np.copy(Y)\n    Z[Z<0] = alpha * (np.exp(Z[Z<0]) - 1)\n        \n    return Z"}
{"task_id": "DSP/1033", "completion": "def nearest_redi(X,Y):\n    \"\"\"\n    Given matrices X and Y, the function returns a nearest redi vector. \n    The i-th element of the vector contains the index of nearest Redi \n    from the ith Homo BITSian.\n    \n    Parameters: X,Y\n    Returns: V\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    # YOUR CODE HERE\n    \n    V = np.argmin(D,1)\n    \n    return V"}
{"task_id": "DSP/1033", "completion": "def nearest_redi(X,Y):\n    \"\"\"\n    Given matrices X and Y, the function returns a nearest redi vector. \n    The i-th element of the vector contains the index of nearest Redi \n    from the ith Homo BITSian.\n    \n    Parameters: X,Y\n    Returns: V\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    # YOUR CODE HERE\n    \n    V = np.argmin(D,1)\n    \n    return V"}
{"task_id": "DSP/1034", "completion": "def num_redis(X,Y,r):\n    \"\"\"\n    Given matrices X and Y, the function returns a vector, where the i-th element \n    of the vector contains the number of Redis inside a radius of r,\n    centered at the i-th Homo BITSian.\n    \n    Parameters: X,Y,r\n    Returns: W\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    # YOUR CODE HERE\n    bool_less_r = D < r\n    W = np.sum(bool_less_r, axis = 1)\n    \n    return W"}
{"task_id": "DSP/1034", "completion": "def num_redis(X,Y,r):\n    \"\"\"\n    Given matrices X and Y, the function returns a vector, where the i-th element \n    of the vector contains the number of Redis inside a radius of r,\n    centered at the i-th Homo BITSian.\n    \n    Parameters: X,Y,r\n    Returns: W\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    # YOUR CODE HERE\n    bool_less_r = D < r\n    W = np.sum(bool_less_r, axis = 1)\n    \n    return W"}
{"task_id": "DSP/1035", "completion": "def softmax_vector(x):\n    \"\"\"\n    This function computes softmax on a vector (similar to 1D array).\n\n    Please use vectorized operations and numpy broadcasting for the task\n    instead of loops to make your code efficient.\n\n\n    You should make sure that your code works for a single\n    N-dimensional vector (treat the vector as a single row). Also,\n    make sure that the dimensions of the output match the input.\n\n    Arguments:\n    x -- An N dimensional vector \n\n    Return:\n    x -- You are allowed to modify x in-place\n    \"\"\"\n    orig_shape = x.shape\n    assert len(x.shape)==1\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n        \n    x=np.exp(x)/np.sum(np.exp(x))\n    \n    ##########################################################\n    ### END SOLUTION\n    assert x.shape == orig_shape #checks if output shape same as input shape\n    return x"}
{"task_id": "DSP/1035", "completion": "def softmax_vector(x):\n    \"\"\"\n    This function computes softmax on a vector (similar to 1D array).\n\n    Please use vectorized operations and numpy broadcasting for the task\n    instead of loops to make your code efficient.\n\n\n    You should make sure that your code works for a single\n    N-dimensional vector (treat the vector as a single row). Also,\n    make sure that the dimensions of the output match the input.\n\n    Arguments:\n    x -- An N dimensional vector \n\n    Return:\n    x -- You are allowed to modify x in-place\n    \"\"\"\n    orig_shape = x.shape\n    assert len(x.shape)==1\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n        \n    x=np.exp(x)/np.sum(np.exp(x))\n    \n    ##########################################################\n    ### END SOLUTION\n    assert x.shape == orig_shape #checks if output shape same as input shape\n    return x"}
{"task_id": "DSP/1036", "completion": "def softmax_matrix(x):\n    \"\"\"\n    This function computes softmax on a matrix (similar to 2D array).\n\n    Please use vectorized operations and numpy broadcasting for the task\n    instead of loops to make your code efficient.\n \n\n    You should make sure that your code works for M x N matrices. \n    Also, make sure that the dimensions of the output match the input.\n\n\n\n    Arguments:\n    x -- An M x N dimensional numpy matrix.\n\n    Return:\n    x -- You are allowed to modify x in-place\n    \"\"\"\n    orig_shape = x.shape\n    assert len(x.shape)>1\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n        \n    x=np.exp(x)/(np.sum(np.exp(x),axis=1)[:,None])\n    \n    ##########################################################\n    ### END SOLUTION\n    assert x.shape == orig_shape\n    return x"}
{"task_id": "DSP/1036", "completion": "def softmax_matrix(x):\n    \"\"\"\n    This function computes softmax on a matrix (similar to 2D array).\n\n    Please use vectorized operations and numpy broadcasting for the task\n    instead of loops to make your code efficient.\n \n\n    You should make sure that your code works for M x N matrices. \n    Also, make sure that the dimensions of the output match the input.\n\n\n\n    Arguments:\n    x -- An M x N dimensional numpy matrix.\n\n    Return:\n    x -- You are allowed to modify x in-place\n    \"\"\"\n    orig_shape = x.shape\n    assert len(x.shape)>1\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n        \n    x=np.exp(x)/(np.sum(np.exp(x),axis=1)[:,None])\n    \n    ##########################################################\n    ### END SOLUTION\n    assert x.shape == orig_shape\n    return x"}
{"task_id": "DSP/1037", "completion": "def softmax_shift(x):\n    \"\"\"\n    Compute the softmax function for each row of the input x (may be vector or matrix).\n\n    Please use vectorized operations and numpy broadcasting for the task\n    instead of loops to make your code efficient.\n\n    You should also make sure that your code works for a single\n    N-dimensional vector (treat the vector as a single row) and\n    for M x N matrices. Also,make sure that the dimensions \n    of the output match the input.\n\n    Arguments:\n    x -- A N dimensional vector or M x N dimensional numpy matrix.\n\n    Return:\n    x -- You are allowed to modify x in-place\n    \"\"\"\n    orig_shape = x.shape\n\n    if len(x.shape) > 1:\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n\n        x=(np.exp(x-(np.array(np.max(x,axis=1)))[:,None]))/(np.sum(np.exp(x-(np.array(np.max(x,axis=1)))[:,None]),axis=1)[:,None])\n\n    ##########################################################\n    ### END SOLUTION\n    else:\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n\n        x=np.exp(x-np.max(x))/np.sum(np.exp(x-np.max(x)))\n    ##########################################################\n    ### END SOLUTION\n    assert x.shape == orig_shape\n    return x"}
{"task_id": "DSP/1037", "completion": "def softmax_shift(x):\n    \"\"\"\n    Compute the softmax function for each row of the input x (may be vector or matrix).\n\n    Please use vectorized operations and numpy broadcasting for the task\n    instead of loops to make your code efficient.\n\n    You should also make sure that your code works for a single\n    N-dimensional vector (treat the vector as a single row) and\n    for M x N matrices. Also,make sure that the dimensions \n    of the output match the input.\n\n    Arguments:\n    x -- A N dimensional vector or M x N dimensional numpy matrix.\n\n    Return:\n    x -- You are allowed to modify x in-place\n    \"\"\"\n    orig_shape = x.shape\n\n    if len(x.shape) > 1:\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n\n        x=(np.exp(x-(np.array(np.max(x,axis=1)))[:,None]))/(np.sum(np.exp(x-(np.array(np.max(x,axis=1)))[:,None]),axis=1)[:,None])\n\n    ##########################################################\n    ### END SOLUTION\n    else:\n    ### BEGIN SOLUTION\n    ##########################################################\n                        #Your Code Here#\n\n        x=np.exp(x-np.max(x))/np.sum(np.exp(x-np.max(x)))\n    ##########################################################\n    ### END SOLUTION\n    assert x.shape == orig_shape\n    return x"}
{"task_id": "DSP/1038", "completion": "def convolve_image(img, kernel):\n    \"\"\" Both img and kernel are square matrices.\n        Assume kernel dimension is an odd number. \"\"\"\n    \n    ans_img = np.zeros_like(img)\n    \n    ### BEGIN SOLUTION\n    n = img.shape[0]\n    k = kernel.shape[0]\n    zImg = zero_pad(img,kernel)\n    \n    for i in range(n):\n        for j in range(n):\n            ans_img[i,j] = np.sum( zImg[i:i+k,j:j+k] * kernel )\n    ### END SOLUTION\n    \n    return ans_img"}
{"task_id": "DSP/1038", "completion": "def convolve_image(img, kernel):\n    \"\"\" Both img and kernel are square matrices.\n        Assume kernel dimension is an odd number. \"\"\"\n    \n    ans_img = np.zeros_like(img)\n    \n    ### BEGIN SOLUTION\n    n = img.shape[0]\n    k = kernel.shape[0]\n    zImg = zero_pad(img,kernel)\n    \n    for i in range(n):\n        for j in range(n):\n            ans_img[i,j] = np.sum( zImg[i:i+k,j:j+k] * kernel )\n    ### END SOLUTION\n    \n    return ans_img"}
{"task_id": "DSP/1039", "completion": "def nearest_redi(X,Y):\n    \"\"\"\n    Given matrices X and Y, the function returns a nearest redi vector. \n    The i-th element of the vector contains the index of nearest Redi \n    from the ith Homo BITSian.\n    \n    Parameters: X,Y\n    Returns: V\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    ### BEGIN SOLUTION\n    V = np.argmin(D,1)\n    ### END SOLUTION\n    \n    return V"}
{"task_id": "DSP/1039", "completion": "def nearest_redi(X,Y):\n    \"\"\"\n    Given matrices X and Y, the function returns a nearest redi vector. \n    The i-th element of the vector contains the index of nearest Redi \n    from the ith Homo BITSian.\n    \n    Parameters: X,Y\n    Returns: V\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    ### BEGIN SOLUTION\n    V = np.argmin(D,1)\n    ### END SOLUTION\n    \n    return V"}
{"task_id": "DSP/1040", "completion": "def num_redis(X,Y,r):\n    \"\"\"\n    Given matrices X and Y, the function returns a vector, where the i-th element \n    of the vector contains the number of Redis inside a radius of r,\n    centered at the i-th Homo BITSian.\n    \n    Parameters: X,Y,r\n    Returns: W\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    ### BEGIN SOLUTION\n    bool_less_r = D < r\n    W = np.sum(bool_less_r, axis = 1)\n    ### END SOLUTION\n    \n    return W"}
{"task_id": "DSP/1040", "completion": "def num_redis(X,Y,r):\n    \"\"\"\n    Given matrices X and Y, the function returns a vector, where the i-th element \n    of the vector contains the number of Redis inside a radius of r,\n    centered at the i-th Homo BITSian.\n    \n    Parameters: X,Y,r\n    Returns: W\n    \"\"\"\n    \n    D = distances(X,Y)\n    \n    ### BEGIN SOLUTION\n    bool_less_r = D < r\n    W = np.sum(bool_less_r, axis = 1)\n    ### END SOLUTION\n    \n    return W"}
{"task_id": "DSP/1041", "completion": "filepath_csv = './age_steps.csv'\ndf_steps = pd.read_csv(filepath_csv);"}
{"task_id": "DSP/1041", "completion": "filepath_csv = './age_steps.csv'\ndf_steps = pd.read_csv(filepath_csv);"}
{"task_id": "DSP/1042", "completion": "filepath_json = './name_income_id.json'\ndf_income = pd.read_json(filepath_json)"}
{"task_id": "DSP/1042", "completion": "filepath_json = './name_income_id.json'\ndf_income = pd.read_json(filepath_json)"}
{"task_id": "DSP/1043", "completion": "df_income = df_income.drop(['first_name', 'last_name'], axis=1)"}
{"task_id": "DSP/1043", "completion": "df_income = df_income.drop(['first_name', 'last_name'], axis=1)"}
{"task_id": "DSP/1044", "completion": "df = pd.merge(df_steps, df_income, on='id')"}
{"task_id": "DSP/1044", "completion": "df = pd.merge(df_steps, df_income, on='id')"}
{"task_id": "DSP/1045", "completion": "df = df[['id', 'age', 'steps', 'income']]"}
{"task_id": "DSP/1045", "completion": "df = df[['id', 'age', 'steps', 'income']]"}
{"task_id": "DSP/1046", "completion": "df2 = df.copy()\ndf3 = df.copy()"}
{"task_id": "DSP/1046", "completion": "df2 = df.copy()\ndf3 = df.copy()"}
{"task_id": "DSP/1047", "completion": "n_nan = df['income'].isnull().sum()"}
{"task_id": "DSP/1047", "completion": "n_nan = df['income'].isnull().sum()"}
{"task_id": "DSP/1048", "completion": "df = df.dropna(axis=0,how='any')"}
{"task_id": "DSP/1048", "completion": "df = df.dropna(axis=0,how='any')"}
{"task_id": "DSP/1049", "completion": "mean_income = df['income'].mean()\n#raise NotImplementedError()"}
{"task_id": "DSP/1049", "completion": "mean_income = df['income'].mean()\n#raise NotImplementedError()"}
{"task_id": "DSP/1050", "completion": "df2['income'].fillna((mean_income),inplace=True)"}
{"task_id": "DSP/1050", "completion": "df2['income'].fillna((mean_income),inplace=True)"}
{"task_id": "DSP/1051", "completion": "plt.hist(df['age'], bins=25)\n\nf1 = plt.gcf()"}
{"task_id": "DSP/1051", "completion": "plt.hist(df['age'], bins=25)\n\nf1 = plt.gcf()"}
{"task_id": "DSP/1052", "completion": "plt.hist(df['age'], bins=25)\n\nf2 = plt.gcf()"}
{"task_id": "DSP/1052", "completion": "plt.hist(df['age'], bins=25)\n\nf2 = plt.gcf()"}
{"task_id": "DSP/1053", "completion": "plt.hist(df['income'], bins=25)\n\nf3 = plt.gcf()"}
{"task_id": "DSP/1053", "completion": "plt.hist(df['income'], bins=25)\n\nf3 = plt.gcf()"}
{"task_id": "DSP/1054", "completion": "fd = pd.plotting.scatter_matrix(df[['age', 'steps', 'income']])"}
{"task_id": "DSP/1054", "completion": "fd = pd.plotting.scatter_matrix(df[['age', 'steps', 'income']])"}
{"task_id": "DSP/1055", "completion": "n_neg = sum(df['steps'] == -1)"}
{"task_id": "DSP/1055", "completion": "n_neg = sum(df['steps'] == -1)"}
{"task_id": "DSP/1056", "completion": "df = df[df['steps'] != -1]"}
{"task_id": "DSP/1056", "completion": "df = df[df['steps'] != -1]"}
{"task_id": "DSP/1057", "completion": "df['income'][df['income'] == 0] = 1"}
{"task_id": "DSP/1057", "completion": "df['income'][df['income'] == 0] = 1"}
{"task_id": "DSP/1058", "completion": "df['income'] = df['income'].apply(lambda x: np.log10(x))\n\nprint(df)"}
{"task_id": "DSP/1058", "completion": "df['income'] = df['income'].apply(lambda x: np.log10(x))\n\nprint(df)"}
{"task_id": "DSP/1059", "completion": "plt.hist(df['income'], bins=25)\n\nf4 = plt.gcf()"}
{"task_id": "DSP/1059", "completion": "plt.hist(df['income'], bins=25)\n\nf4 = plt.gcf()"}
{"task_id": "DSP/1060", "completion": "df = df[df['age'] >= 18]"}
{"task_id": "DSP/1060", "completion": "df = df[df['age'] >= 18]"}
{"task_id": "DSP/1061", "completion": "steps_std = df['steps'].std()\nsteps_mean = df['steps'].mean()\nstd3 = steps_std * 3\nprint(std3)\n\nstd_max = steps_mean + std3\nstd_min = steps_mean - std3\nprint(std_max)\nprint(std_min)"}
{"task_id": "DSP/1061", "completion": "steps_std = df['steps'].std()\nsteps_mean = df['steps'].mean()\nstd3 = steps_std * 3\nprint(std3)\n\nstd_max = steps_mean + std3\nstd_min = steps_mean - std3\nprint(std_max)\nprint(std_min)"}
{"task_id": "DSP/1062", "completion": "print(df.shape)\ndf = df[(df['steps'] > std_min) & (df['steps'] < std_max)]\nprint(df.shape)"}
{"task_id": "DSP/1062", "completion": "print(df.shape)\ndf = df[(df['steps'] > std_min) & (df['steps'] < std_max)]\nprint(df.shape)"}
{"task_id": "DSP/1063", "completion": "desc = df.describe()\nprint(desc)"}
{"task_id": "DSP/1063", "completion": "desc = df.describe()\nprint(desc)"}
{"task_id": "DSP/1064", "completion": "corrs = df.corr()\nprint(corrs)"}
{"task_id": "DSP/1064", "completion": "corrs = df.corr()\nprint(corrs)"}
{"task_id": "DSP/1065", "completion": "print(corrs.describe())\nage_corr = 'steps'\ninc_corr = 'age'"}
{"task_id": "DSP/1065", "completion": "print(corrs.describe())\nage_corr = 'steps'\ninc_corr = 'age'"}
{"task_id": "DSP/1066", "completion": "top_walker = df['steps'].quantile(q=0.9)\nprint(top_walker)"}
{"task_id": "DSP/1066", "completion": "top_walker = df['steps'].quantile(q=0.9)\nprint(top_walker)"}
{"task_id": "DSP/1067", "completion": "old_income = df['income'][df['age'] > 45].mean()\nprint(old_income)"}
{"task_id": "DSP/1067", "completion": "old_income = df['income'][df['age'] > 45].mean()\nprint(old_income)"}
{"task_id": "DSP/1068", "completion": "df_scaled = df['income'].apply(lambda x: 10**x)\n\n# Where the answers are stored\n[a1, b1]= np.polyfit(df['age'], df_scaled, 1)\n\nplt.scatter(df['age'], df_scaled)\nplt.xlabel('age')\nplt.ylabel('income')\nx=np.arange(100)\nplt.plot(x, a1*x+b1, '-', color='red')\nplt.show()\nprint(a1)\nprint(b1)"}
{"task_id": "DSP/1068", "completion": "df_scaled = df['income'].apply(lambda x: 10**x)\n\n# Where the answers are stored\n[a1, b1]= np.polyfit(df['age'], df_scaled, 1)\n\nplt.scatter(df['age'], df_scaled)\nplt.xlabel('age')\nplt.ylabel('income')\nx=np.arange(100)\nplt.plot(x, a1*x+b1, '-', color='red')\nplt.show()\nprint(a1)\nprint(b1)"}
{"task_id": "DSP/1069", "completion": "pred1 = 75 * a1 + b1\nprint(pred1)"}
{"task_id": "DSP/1069", "completion": "pred1 = 75 * a1 + b1\nprint(pred1)"}
{"task_id": "DSP/1070", "completion": "[a2, b2]= np.polyfit(df['steps'], df_scaled, 1)\n\nplt.scatter(df['steps'], df_scaled)\nplt.xlabel('steps')\nplt.ylabel('income')\nx=np.arange(30000)\nplt.plot(x, a2*x+b2, '-', color='red')\nplt.show()\nprint(a2)\nprint(b2)"}
{"task_id": "DSP/1070", "completion": "[a2, b2]= np.polyfit(df['steps'], df_scaled, 1)\n\nplt.scatter(df['steps'], df_scaled)\nplt.xlabel('steps')\nplt.ylabel('income')\nx=np.arange(30000)\nplt.plot(x, a2*x+b2, '-', color='red')\nplt.show()\nprint(a2)\nprint(b2)"}
{"task_id": "DSP/1071", "completion": "pred2 = a2 * 20000 + b2\nprint(pred2)"}
{"task_id": "DSP/1071", "completion": "pred2 = a2 * 20000 + b2\nprint(pred2)"}
{"task_id": "DSP/1072", "completion": "better_model = 'age'"}
{"task_id": "DSP/1072", "completion": "better_model = 'age'"}
{"task_id": "DSP/1073", "completion": "def predict_income(age):\n    return a1 * age + b1"}
{"task_id": "DSP/1073", "completion": "def predict_income(age):\n    return a1 * age + b1"}
{"task_id": "DSP/1074", "completion": "df3['predicted_income'] = my_predictions\nprint(df3['predicted_income'])"}
{"task_id": "DSP/1074", "completion": "df3['predicted_income'] = my_predictions\nprint(df3['predicted_income'])"}
{"task_id": "DSP/1075", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/1075", "completion": "var_a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\nvar_b = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)"}
{"task_id": "DSP/1076", "completion": "dictionary = dict(zip(var_a, var_b))"}
{"task_id": "DSP/1076", "completion": "dictionary = dict(zip(var_a, var_b))"}
{"task_id": "DSP/1077", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n# YOUR CODE HERE\nfor i, l in enumerate(lst):\n    if l % 2 == 0:\n        inds.append(i)"}
{"task_id": "DSP/1077", "completion": "lst = [1, 2, 3, 4, 5, 6]\ninds = []\n\n# Loop through the provided list 'lst'. For each element, check if it is an even number.\n#  If the element is an even number, add the INDEX of that element to the list 'inds'.\n#    Note that you are adding the index to 'inds', not the element itself.\n# Hint: to check if a number is even, you can use the modulo '%' operator.\n# Hint: to loop through an iterable, keeping track of the index, you can use the 'enumerate' function.\n\n# YOUR CODE HERE\nfor i, l in enumerate(lst):\n    if l % 2 == 0:\n        inds.append(i)"}
{"task_id": "DSP/1078", "completion": "def add2(a, b):\n    return a + b"}
{"task_id": "DSP/1078", "completion": "def add2(a, b):\n    return a + b"}
{"task_id": "DSP/1079", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n# YOUR CODE HERE\nfor key, value in dictionary.items():\n    if value % 2 == 1:\n        value = add2(1, value)\n    other_dictionary.update({key: value})"}
{"task_id": "DSP/1079", "completion": "other_dictionary = dict()\n\n# We will now fill 'other_dictionary', from data.\n#  Loop through the key-value pairs in 'dictionary'.\n#    For each key-value pair, if the value is odd, use the 'add2' to add 1 to the value.\n#       Add the key and incremented value to 'other_dictionary'.\n#    Otherwise, add the key-value pair to 'other_dictionary' as is.\n# Note: to loop through key-value pairs in a dictionary, check out the '.items' method.\n\n# YOUR CODE HERE\nfor key, value in dictionary.items():\n    if value % 2 == 1:\n        value = add2(1, value)\n    other_dictionary.update({key: value})"}
{"task_id": "DSP/1080", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/1080", "completion": "import numpy as np\nimport scipy as sp\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport sklearn as skl"}
{"task_id": "DSP/1081", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/1081", "completion": "a = 1\n### END SOLUTION"}
{"task_id": "DSP/1082", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/1082", "completion": "b = '2'\n### END SOLUTION"}
{"task_id": "DSP/1083", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/1083", "completion": "ds = True\n### END SOLUTION"}
{"task_id": "DSP/1084", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/1084", "completion": "array = np.array(range(5))\n### END SOLUTION"}
{"task_id": "DSP/1085", "completion": "def binarize(X):\n    threshold = 0.5\n    X = np.divide(X, 256)\n    return np.where(X<threshold, 0., 1.)"}
{"task_id": "DSP/1085", "completion": "def binarize(X):\n    threshold = 0.5\n    X = np.divide(X, 256)\n    return np.where(X<threshold, 0., 1.)"}
{"task_id": "DSP/1086", "completion": "def E_step(X, mu, pi):\n    gamma = np.zeros((len(X),len(pi)))\n    for n in range(len(X)):\n        likehood_list = pi*np.prod((mu**X[n,:])*((1-mu)**(1-X[n,:])), axis = 1)\n        for k in range(len(pi)):\n            gamma[n,k] = likehood_list[k]/np.sum(likehood_list)\n    return gamma"}
{"task_id": "DSP/1086", "completion": "def E_step(X, mu, pi):\n    gamma = np.zeros((len(X),len(pi)))\n    for n in range(len(X)):\n        likehood_list = pi*np.prod((mu**X[n,:])*((1-mu)**(1-X[n,:])), axis = 1)\n        for k in range(len(pi)):\n            gamma[n,k] = likehood_list[k]/np.sum(likehood_list)\n    return gamma"}
{"task_id": "DSP/1087", "completion": "def M_step(X, gamma):\n    effective_num = np.sum(gamma, axis = 0)\n    pi = effective_num  / len(X)\n    mu = np.zeros((shape(gamma)[1], shape(X)[1]))\n    for k in range(shape(gamma)[1]):\n        mu[k,:] = np.sum(gamma[:,k][:,np.newaxis]*X, axis = 0) / effective_num[k]\n    return mu, pi"}
{"task_id": "DSP/1087", "completion": "def M_step(X, gamma):\n    effective_num = np.sum(gamma, axis = 0)\n    pi = effective_num  / len(X)\n    mu = np.zeros((shape(gamma)[1], shape(X)[1]))\n    for k in range(shape(gamma)[1]):\n        mu[k,:] = np.sum(gamma[:,k][:,np.newaxis]*X, axis = 0) / effective_num[k]\n    return mu, pi"}
{"task_id": "DSP/1088", "completion": "def log_bernoulli_loss(x_hat, x):\n    first_component = torch.mul(x, torch.log(x_hat))\n    second_component = torch.mul(torch.add(torch.Tensor([1]), -x), torch.log(torch.add(torch.Tensor([1]), -x_hat)))\n    loss_per_point = torch.sum(first_component + second_component, dim=1)\n    \n    loss = torch.sum(loss_per_point, dim=0)    \n    loss = - loss / x.size()[0]\n    \n    return loss"}
{"task_id": "DSP/1088", "completion": "def log_bernoulli_loss(x_hat, x):\n    first_component = torch.mul(x, torch.log(x_hat))\n    second_component = torch.mul(torch.add(torch.Tensor([1]), -x), torch.log(torch.add(torch.Tensor([1]), -x_hat)))\n    loss_per_point = torch.sum(first_component + second_component, dim=1)\n    \n    loss = torch.sum(loss_per_point, dim=0)    \n    loss = - loss / x.size()[0]\n    \n    return loss"}
{"task_id": "DSP/1089", "completion": "def KL_loss(mu, logvar):\n    d = logvar.size()[1]\n    var = torch.exp(logvar)\n    loss = 1/2 * (-logvar.sum(dim=1) - d + var.sum(dim=1) + torch.diag(mu @ mu.t()))\n    \n    loss = loss.sum()\n    loss = loss / mu.size()[0]\n    \n    return loss"}
{"task_id": "DSP/1089", "completion": "def KL_loss(mu, logvar):\n    d = logvar.size()[1]\n    var = torch.exp(logvar)\n    loss = 1/2 * (-logvar.sum(dim=1) - d + var.sum(dim=1) + torch.diag(mu @ mu.t()))\n    \n    loss = loss.sum()\n    loss = loss / mu.size()[0]\n    \n    return loss"}
{"task_id": "DSP/1090", "completion": "def loss_function(x_hat, x, mu, logvar):   \n    loss = log_bernoulli_loss(x_hat, x) + KL_loss(mu, logvar)\n    return loss"}
{"task_id": "DSP/1090", "completion": "def loss_function(x_hat, x, mu, logvar):   \n    loss = log_bernoulli_loss(x_hat, x) + KL_loss(mu, logvar)\n    return loss"}
{"task_id": "DSP/1091", "completion": "def encode(self, x):\n    x = F.tanh(self.fc1(x))\n    mu = self.fc21(x)\n    logvar = self.fc22(x)\n    return mu, logvar"}
{"task_id": "DSP/1091", "completion": "def encode(self, x):\n    x = F.tanh(self.fc1(x))\n    mu = self.fc21(x)\n    logvar = self.fc22(x)\n    return mu, logvar"}
{"task_id": "DSP/1092", "completion": "def reparameterize(self, mu, logvar):\n    eps = torch.randn_like(mu)\n    z = mu + torch.mul(torch.sqrt(torch.exp(logvar)), eps)\n    return z"}
{"task_id": "DSP/1092", "completion": "def reparameterize(self, mu, logvar):\n    eps = torch.randn_like(mu)\n    z = mu + torch.mul(torch.sqrt(torch.exp(logvar)), eps)\n    return z"}
{"task_id": "DSP/1093", "completion": "def decode(self, z):\n    x_hat = F.tanh(self.fc3(z))\n    x_hat = F.sigmoid(self.fc4(x_hat))    \n    return x_hat"}
{"task_id": "DSP/1093", "completion": "def decode(self, z):\n    x_hat = F.tanh(self.fc3(z))\n    x_hat = F.sigmoid(self.fc4(x_hat))    \n    return x_hat"}
{"task_id": "DSP/1094", "completion": "def forward(self, x):\n    x = x.view(-1, 784)\n    mu, logvar = self.encode(x)\n    z = self.reparameterize(mu, logvar)\n    x_hat = self.decode(z)\n    \n    return x_hat, mu, logvar"}
{"task_id": "DSP/1094", "completion": "def forward(self, x):\n    x = x.view(-1, 784)\n    mu, logvar = self.encode(x)\n    z = self.reparameterize(mu, logvar)\n    x_hat = self.decode(z)\n    \n    return x_hat, mu, logvar"}
{"task_id": "DSP/1095", "completion": "def incr_list_by_1(lst):\n    add_one = [i + 1 for i in lst]\n    return add_one"}
{"task_id": "DSP/1095", "completion": "def incr_list_by_1(lst):\n    add_one = [i + 1 for i in lst]\n    return add_one"}
